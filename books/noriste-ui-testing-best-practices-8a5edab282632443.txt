Directory structure:
â””â”€â”€ noriste-ui-testing-best-practices/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ README.ZH.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ assets/
    â”‚   â””â”€â”€ images/
    â”‚       â”œâ”€â”€ viconblue.PNG
    â”‚       â”œâ”€â”€ perf-testing/
    â”‚       â”‚   â””â”€â”€ insights.PNG
    â”‚       â””â”€â”€ ui-state/
    â”‚           â””â”€â”€ devtools-network.PNG
    â””â”€â”€ sections/
        â”œâ”€â”€ draft.md
        â”œâ”€â”€ template.md
        â”œâ”€â”€ advanced/
        â”‚   â”œâ”€â”€ combinatorial-testing.md
        â”‚   â”œâ”€â”€ combinatorial-testing.zh.md
        â”‚   â”œâ”€â”€ email-testing.md
        â”‚   â”œâ”€â”€ email-testing.zh.md
        â”‚   â”œâ”€â”€ performance-testing.md
        â”‚   â”œâ”€â”€ performance-testing.zh.md
        â”‚   â”œâ”€â”€ test-flake.md
        â”‚   â”œâ”€â”€ test-flake.zh.md
        â”‚   â”œâ”€â”€ test-states.md
        â”‚   â””â”€â”€ test-states.zh.md
        â”œâ”€â”€ beginners/
        â”‚   â”œâ”€â”€ top-to-bottom-approach.md
        â”‚   â””â”€â”€ top-to-bottom-approach.zh.md
        â”œâ”€â”€ generic-best-practices/
        â”‚   â”œâ”€â”€ await-dont-sleep.md
        â”‚   â”œâ”€â”€ await-dont-sleep.zh.md
        â”‚   â”œâ”€â”€ name-test-files-wisely.md
        â”‚   â”œâ”€â”€ name-test-files-wisely.zh.md
        â”‚   â”œâ”€â”€ reaching-ui-state.md
        â”‚   â”œâ”€â”€ reaching-ui-state.zh.md
        â”‚   â”œâ”€â”€ test-code-with-debugging-in-mind.md
        â”‚   â”œâ”€â”€ test-code-with-debugging-in-mind.zh.md
        â”‚   â”œâ”€â”€ ui-tests-debugging-best-practices.md
        â”‚   â”œâ”€â”€ ui-tests-debugging-best-practices.zh.md
        â”‚   â”œâ”€â”€ use-your-testing-tool-as-your-primary-development-tool.md
        â”‚   â””â”€â”€ use-your-testing-tool-as-your-primary-development-tool.zh.md
        â”œâ”€â”€ real-life-examples/
        â”‚   â”œâ”€â”€ from-unreadable-react-component-tests-to-simple-ones.md
        â”‚   â”œâ”€â”€ from-unreadable-react-component-tests-to-simple-ones.zh.md
        â”‚   â”œâ”€â”€ test-front-end-with-integration-back-end-with-e2e.md
        â”‚   â””â”€â”€ test-front-end-with-integration-back-end-with-e2e.zh.md
        â”œâ”€â”€ server-communication-testing/
        â”‚   â”œâ”€â”€ monitoring-tests.md
        â”‚   â”œâ”€â”€ monitoring-tests.zh.md
        â”‚   â”œâ”€â”€ test-request-and-response-payload.md
        â”‚   â””â”€â”€ test-request-and-response-payload.zh.md
        â”œâ”€â”€ testing-perks/
        â”‚   â”œâ”€â”€ tests-as-documentation.md
        â”‚   â””â”€â”€ tests-as-documentation.zh.md
        â”œâ”€â”€ testing-strategy/
        â”‚   â”œâ”€â”€ avoid-perfectionism.md
        â”‚   â”œâ”€â”€ avoid-perfectionism.zh.md
        â”‚   â”œâ”€â”€ choose-a-reference-browser.md
        â”‚   â”œâ”€â”€ choose-a-reference-browser.zh.md
        â”‚   â”œâ”€â”€ component-vs-integration-vs-e2e-testing.md
        â”‚   â”œâ”€â”€ component-vs-integration-vs-e2e-testing.zh.md
        â”‚   â”œâ”€â”€ small-tests-or-long-ones.md
        â”‚   â”œâ”€â”€ small-tests-or-long-ones.zh.md
        â”‚   â”œâ”€â”€ write-test-then-fix-bug.md
        â”‚   â””â”€â”€ write-test-then-fix-bug.zh.md
        â””â”€â”€ tools/
            â”œâ”€â”€ cypress-and-storybook-exposing-component-from-story.md
            â”œâ”€â”€ cypress-and-storybook-exposing-component-from-story.zh.md
            â”œâ”€â”€ cypress-and-storybook.md
            â”œâ”€â”€ cypress-and-storybook.zh.md
            â”œâ”€â”€ cypress-react-component-test.md
            â”œâ”€â”€ cypress-react-component-test.zh.md
            â”œâ”€â”€ ui-testing-problems-cypress.md
            â”œâ”€â”€ ui-testing-problems-cypress.zh.md
            â”œâ”€â”€ visual-regression-testing.md
            â””â”€â”€ visual-regression-testing.zh.md

================================================
FILE: README.md
================================================
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD033 -->
<div align="right"><strong>ğŸ‡¬ğŸ‡§ English version</strong>  | <strong><a href="./README.ZH.md">ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (Chinese version)</a></strong></div>
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD033 -->

# UI Testing Best Practices

<h1 align="center">
  <img src="assets/images/banner-2.png" alt="UI testing Best Practices">
</h1>

<br/>

<div align="center">
  <img src="https://img.shields.io/badge/âš™%20Item%20count%20-%2026%20Chapters-blue.svg" alt="26 items"> <img src="https://img.shields.io/badge/%F0%9F%93%85%20Last%20update%20-%20Jun%202025-green.svg" alt="Last update: June, 2025">
</div>

<br/>

**Follow us on Twitter or LinkedIn!**:
- [**@NoriSte**](https://twitter.com/NoriSte/) - [Stefano Magni](https://www.linkedin.com/in/noriste/)
- [**@MuratKeremOzcan**](https://twitter.com/MuratKeremOzcan/) - [Murat Ozcan](https://www.linkedin.com/in/murat-ozcan-3489898/)

and reach out to us if you need a consultancy or a course.

###### Built and maintained by our [Steering Committee](#steering-committee) and [Collaborators](#collaborators)

## Table of Contents

1.  [Testing strategies (5)](#1-testing-strategies)
2.  [Generic Best Practices (6)](#2-generic-best-practices)
3.  [Server Communication Testing (3)](#3-server-communication-testing)
4.  [Beginners (1)](#4-beginners)
5.  [Generic testing perks (1)](#5-generic-testing-perks)
6.  [Tools (2)](#6-tools)
7.  [Advanced (5)](#7-advanced)
8.  [Real Life Examples (2)](#8-real-life-examples)
9.  [Obsolete chapters (3)](#9-obsolete-chapters)

<br/><br/>

# `1. Testing strategies`

## 1.1 Component tests vs (UI) Integration tests vs E2E tests

**TL;DR:** Identifying the test types is the starting point to understand and master all the UI testing strategies, the tools, and the pro/cons of them. UI integration tests are the most effective ones (you are going to love them), E2E tests give you the highest confidence, and Component tests allow you to test the units of the UI in isolation.

**Otherwise:** You end up writing a lot of E2E tests without leveraging other simpler kind of tests. E2E tests are the most confident type of tests but even the hardest, slowest and most brittle ones.

ğŸ”— [**Read More: Component vs (UI) Integration vs E2E tests**](/sections/testing-strategy/component-vs-integration-vs-e2e-testing.md)

<br/>

## 1.2 In the beginning, avoid perfectionism

**TL;DR:** Software Testing is an amazing topic but a limited experience could make you fighting with a new enemy instead of relying on a new ally. Avoid, if you can, to test every complex user flows since the beginning of your UI testing journey. The simpler your first tests are, the sooner you get the advantages.

**Otherwise:** You create complex and hard to be debugged tests. This kind of tests slow down your work and do not have any kind of usefulness.

ğŸ”— [**Read More: In the beginning, avoid perfectionism**](/sections/testing-strategy/avoid-perfectionism.md)

<br/>

## 1.3 Choose a reference browser

**TL;DR:** Cross-browser testing is way overrated. It's an important topic and it's the first thing you can think while starting evaluating the right testing tool. Don't worry: start by splitting functional testing from visual testing, that's the first step to correctly evaluate the need for cross-browser support (and to choose the right testing tool, too). Visual testing can be integrated into every testing tool, thank services like Applitools and Percy.

**Otherwise:** You could choose the wrong testing tool based on the cross-browser support.

ğŸ”— [**Read More: Choose a reference browser**](/sections/testing-strategy/choose-a-reference-browser.md)

<br/>

## 1.4 Found a bug? Write the test, then fix it

**TL;DR:** A test is a good ally when you need to be sure that you are able to systematically reproducing a bug. A test allows you to speed up the fixing flow and to be 100% confident that the same bug is caught forever.

**Otherwise:** You could not identify correctly the bug and you can not be sure that the bug will not present again in the future.

ğŸ”— [**Read More: Found a bug? Write the test, then fix it**](/sections/testing-strategy/write-test-then-fix-bug.md)

<br/>

## 1.5 One long E2E test or small, independent ones?

**TL;DR:** When dealing with E2E tests and their difficulties, opting for a lot of small and independent tests or for a long one is not an obvious choice. Either the solutions have pros and cons, deriving from the inner complexity of the E2E tests where you deal with a real back-end and real data.

**Otherwise:** You could create hard-to-maintain E2E tests.

ğŸ”— [**Read More: One long E2E test or small, independent ones?**](/sections/testing-strategy/small-tests-or-long-ones.md)

<br/><br/>

# `2. Generic Best Practices`

## 2.1 Await, don't sleep

**TL;DR:** When testing your UI, you define a sort of key points the app must pass through. Reaching these key
points is an asynchronous process because, almost 100% of the times, your UI does not update
synchronously. Those key points are called **deterministic events**, as known as something that you
know that must happen. You need to wait for these events to make your tests robust.

**Otherwise:** Sleeping the tests make your tests slow and brittle, it's one of the most common and biggest errors in UI testing.

ğŸ”— [**Read More: Await, don't sleep**](/sections/generic-best-practices/await-dont-sleep.md)

<br/>

## 2.2 Name your test files wisely

**TL;DR:** Lot of times you need to launch just a type of tests and it's super easy if you follow a
common pattern while naming your testing files.

**Otherwise:** You need to launch a long test suite just to have some of them run.

ğŸ”— [**Read More: Name the test files
wisely**](/sections/generic-best-practices/name-test-files-wisely.md)

<br/>

## 2.3 UI Tests Debugging Best Practices

**TL;DR:** Debugging a UI test could be really hard, especially if you use generic browser automation tools. Here is a list of simple rules that are at the base of the debugging process.

**Otherwise:** You are going to waste a lot of time without taming the exponential complexity of a UI test.

ğŸ”— [**Read More: UI Tests Debugging Best Practices**](/sections/generic-best-practices/ui-tests-debugging-best-practices.md)

<br/>

## 2.4 Reaching UI state for tests without using the UI

**TL;DR:** As a developer who wants to ensure quality, it is important to think about cost of tests vs the value they provide. Where reasonable, strive to not duplicate effort, and still get high value by considering alternatives for setting up state for a test.

ğŸ”— [**Read More: Reaching UI state**](./sections/generic-best-practices/reaching-ui-state.md)

<br/>

## 2.5 Use your testing tool as your primary development tool

**TL;DR:** Leveraging your testing tool to avoid manual tests is one of the biggest improvements you
could do to speed up your working flow. Testing tools are faster than you and the most modern ones include
some UI utilities that make easy to use them as a development tool.

**Otherwise:** You code the app the old way, losing a lot of time interacting manually with the UI itself.

ğŸ”— [**Read More: Use your testing tool as your primary development tool**](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md)

<br/>

## 2.6 Keep abstraction low to ease debugging the tests

**TL;DR:** Tests should be written with readability and debuggability in mind. Abstraction may be good in some instances, but it always incurs a cost in debuggability and therefore sometimes may not be worth it. This is especially important for UI tests; consequent of the complex stack, it can get harder to understand the real source of failures. Reducing abstraction for the sake of easier debugging is key for future proofing the test code.


**Otherwise:** There is a balance between abstraction and debuggability; the higher the abstraction, the harder it is going to be to debug the tests in the future.

ğŸ”— [**Read More: Keep abstraction low to ease debugging the tests**](/sections/generic-best-practices/test-code-with-debugging-in-mind.md)

<br/><br/>

# `3. Server Communication Testing`

## 3.1 Test the request and response payloads

**TL;DR:** The UI communicates continuously with the back-end, and usually every communication is critical. A bad request or a bad response could cause inconsistent data and inconsistent UI state. Remember that all the business is built around data and the user experience is scratched by every single UI failure. So, every single XHR request must be checked carefully. XHR request checks make your test more robust too, correct XHR management and testing are one of the most important aspects of a UI test.

**Otherwise:** You could miss some relevant communication inconsistencies and when you need to debug them, you are going to waste a lot of time because the test will not drive you directly to the issue.

ğŸ”— [**Read More: Test the request and response payloads**](/sections/server-communication-testing/test-request-and-response-payload.md)

<br/>

## 3.2 Test the server schema

**TL;DR:** A lot of times, the front-end application breaks because of a change in the back-end. Ask your back-end colleagues to allow you to export every schema that describes the back-end entities and the communication with the front-end. Some examples could be the GraphQL schema, the TypeScript types, the ElasticSearch mapping, the Pact contract, a Postman configuration etc. more in general, everything that can warn you that something changed in the back-end. Every back-end change could impact the front-end and you must discover it as soonest as possible.

**Otherwise:** You could miss some back-end change and your front-end application could break inadvertently.

<br/>

## 3.3 Monitoring tests

**TL;DR:** The more the test suites are launched periodically, the more confident you are that everything works as expected. UI tests should be based on the user perspective but there are a lot of small tests that could give you a lot of immediate feedback without debugging the expected user flows. Monitoring small and taken-for-granted tech details helps you preventing bigger test failures.

**Otherwise:** You mix tech-details tests with the user-oriented ones.

ğŸ”— [**Read More: Monitoring tests**](/sections/server-communication-testing/monitoring-tests.md)

<br/><br/>

# `4. Beginners`

## 4.1 Approach the testing pyramid from the top!

**TL;DR:** Approaching the testing world could be inefficient and not satisfactory. You start writing some unit tests but you are left with a lot of doubts. UI Testing allows you to start with a high confidence since the very first day.

**Otherwise:** The wrong approach could condition the way you think about testing and could leave you with the false idea of testing the right way when the truth is you're testing nothing.

ğŸ”— [**Read More: Approach the testing pyramid from the top!**](/sections/beginners/top-to-bottom-approach.md)

<br/><br/>

# `5. Generic testing perks`

## 5.1 Software tests as a documentation tool

**TL;DR:** Tests are a good way to have a concise, code-coupled, and updated documentation. Good storytelling test descriptions could make the comprehension of a codebase or a new project very simple.

**Otherwise:** You rely on the code documentation or, worse, on the readability of the code to comprehend that the code does.

ğŸ”— [**Read More: Software tests as a documentation tool**](/sections/testing-perks/tests-as-documentation.md)

<br/><br/>

# `6. Tools`

## 6.1 Some UI testing problems and the Cypress way

**TL;DR:** Why is testing a web application so hard? Why generic browser automation tools do not fit well the UI/E2E testing needs? Why does Cypress outstand?

**Otherwise:** A generic features comparison is not enough to understand what are the main UI Testing pains and how Cypress removes them.

> [!NOTE]
> All the modern front-end testing tools (Playwright, Storybook, Cypress, TestCafÃ©) all have the similar functionalities and UI tools, so this same contents applies to all of them, not just Cypress.

ğŸ”— [**Read More: Some UI testing problems and the Cypress way**](/sections/tools/ui-testing-problems-cypress.md)



<br/><br/>

## 6.2 Visual Regression Testing

**TL;DR:** Visual regression tests hard and why we should rely on premium services.

**Otherwise:** Another continuous chore for regressions we do not care about. Possibility of missing out visual differences.

ğŸ”— [**Read More: Visual Regression Testing**](/sections/tools/visual-regression-testing.md)

<br/><br/>



# `7. Advanced`

## 7.1 Test States

**TL;DR:** Tests should be repeatable, modular and should handle their own state setup. UI Tests should not be repeated in order to achieve state for another test.

ğŸ”— [**Read More: Test States**](./sections/advanced/test-states.md)

<br/>

## 7.2 Test Flake

**TL;DR:** Tests must produce consistent results every time. Repeatable pipeline execution results are the quorum.
If a test cannot produce reliable results, it reduces confidence in the tests and requires maintenance which reduces all value. In these cases it is best to manually test the functionality.

ğŸ”— [**Read More: Test Flake**](./sections/advanced/test-flake.md)

<br/>

## 7.3 Combinatorial Testing

**TL;DR:** Most software bugs and failures are caused by one or two parameters. Testing parameter combinations can provide more efficient fault detection than conventional methods. Combinatorial Testing is a proven method for more effective software testing at a lower cost.

ğŸ”— [**Read More: Combinatorial Testing**](./sections/advanced/combinatorial-testing.md)

<br/>

## 7.4 Performance Testing

**TL;DR:** Although this is a vast topic, Performance testing from a web development perspective can be simplified with modern tools and understanding. It is highly effective in ensuring user experience, satisfying non-functional requirements (NFRS), and detecting possible system-flake early on.

ğŸ”— [**Read More: Performance Testing**](./sections/advanced/performance-testing.md)

<br/>

## 7.5 Email Testing

**TL;DR:** Email testing is [critical for business success](https://www.industrialmarketer.com/why-email-testing-is-critical-for-email-marketing-success/). Modern services not only allow automated email testing but also provide a stateless, scalable solution while testing SaaS applications.

ğŸ”— [**Read More: Email Testing**](./sections/advanced/email-testing.md)

<br/><br/>

# `8. Real Life Examples`

## 8.1 Siemens - Test the front-end with the integration tests, the back-end with the E2E ones - in reference to [Component vs Integration vs E2e Testing](./sections/testing-strategy/component-vs-integration-vs-e2e-testing.md)

**TL;DR:** UI tests with a stubbed server are reliable and faster compared to full E2E tests. Full E2E tests are not always necessary to ensure front-end quality. We can instead have high confidence in front-end quality by using lower-cost UI integration tests and saving higher cost E2E tests for the back-end.

**Otherwise:** You waste time and resources with slow and brittle E2E tests while you can get a lot of confidence with a lot of UI integrations tests.

ğŸ”— [**Read More: Test the front-end with the integration tests, the back-end with the E2E ones**](./sections/real-life-examples/test-front-end-with-integration-back-end-with-e2e.md)

<br/>

## 8.2 WorkWave - From unreadable React Component Tests to simple, stupid ones

**TL;DR:** The test's code must be as straightforward as possible. The benefit is to save a lot of time to understand, update, refactor, fix it when needed. At the opposite, a terrible scenario happens when you are not able to read some tests, even if you are the author! Here are reported some examples explaining why the test's code is hard, and how they have been refactored.

**Otherwise:** You waste a lot of time reading and understanding the tests when you have to update or fix them.

ğŸ”— [**Read More: From unreadable React Component Tests to simple, stupid ones**](./sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md)

<br/> <br/>

# `9. Obsolete chapters`

## Unit Testing React components with Cypress

*This section is now marked as obsolete because it refers to a very old version of Cypress (that now fully supports component tests).*

**TL;DR:** Cypress v4.5.0 release allowed Unit Testing React components, an external tool like Storybook is not necessary anymore to test isolated components.

ğŸ”— [**Read More: Unit Testing React components with Cypress.**](/sections/tools/cypress-react-component-test.md)

<br/>

## [@daedalius](https://github.com/daedalius)'s approach: Exposing components from Storybook separating stories from tests

*This section is now marked as obsolete because it refers to a very old version of Cypress and Storybook (either of them now fully support component tests).*

**TL;DR:** You may expose the component reference from Storybook Story to test it whatever you wish in Cypress without breaking testing logic into pieces.

**Otherwise:** Splitted test logic and test data will make it difficult to read and support.

ğŸ”— [**Read More: Cypress + Storybook. Keeping test scenario, data and component rendering in one place.**](/sections/tools/cypress-and-storybook-exposing-component-from-story.md)

## [@NoriSte](https://github.com/NoriSte)'s approach: Testing a component with Cypress and Storybook

*This section is now marked as obsolete because it refers to a very old version of Cypress and Storybook (either of them now fully support component tests).*

**TL;DR:** Components ar the building blocks of your app, testing them in isolation is important to discover, as soon as possible, iof there is something wrong with them.

**Otherwise:** UI Tests without lower-level tests do not allow you to understand the source of the problem.

ğŸ”— [**Read More: Testing a component with Cypress and Storybook**](/sections/tools/cypress-and-storybook.md)

<br/> <br/>

## Steering Committee

Meet the steering committee members - the people who work together to provide guidance and future direction to the project.

<div>
<img align="left" width="100" height="100" src="assets/images/members/noriste.png">

Stefano Magni - [Twitter](https://twitter.com/NoriSte),
[GitHub](https://github.com/NoriSte),
[LinkedIn](https://www.linkedin.com/in/noriste/)



Passionate, positive-minded / Front-end Senior Engineer (design system) at [Preply](https://preply.com/) / Speaker / Instructor / Remote worker.

<br/>
<br/>
</div>

<div>

<img align="left" width="100" height="100" src="assets/images/members/muratkeremozcan.png">


Murat Ozcan - [Twitter](https://twitter.com/MuratKeremOzcan),
[GitHub](https://github.com/muratkeremozcan),
[LinkedIn](https://www.linkedin.com/in/murat-ozcan-3489898/), [YouTube](https://www.youtube.com/@MuratKeremOzcan), [Udemy](https://www.youtube.com/@MuratKeremOzcan)



Tech enthusiast in love with testing, development, devops, web and cloud. Staff Engineer, Test Architect at [Seon](https://seon.io/).

<br/>
<br/>

</div>


## Thank You Notes

We appreciate any contribution, from a single word fix to a new best practice. Below is a list of everyone who contributed to this project. A ğŸŒ» marks a successful pull request and a â­ marks an approved new best practice.

### Stars

An approved new best practice Be the first to collect a â­, contribute to this repository ğŸ˜

â­ [Murat Ozcan](https://github.com/muratkeremozcan)
â­ [Dmitriy Tishin](https://github.com/daedalius)
â­ [Nao](https://github.com/naodeng)

### Flowers

A successful PR gives you a ğŸŒ», be the first to collect it.

ğŸŒ» [Anoop Kumar Gupta](https://github.com/anoop-gupt)
ğŸŒ» [Ferdinando Santacroce](https://github.com/jesuswasrasta)
ğŸŒ» [Luca Piazzoni](https://github.com/bioz87)
ğŸŒ» [Luca Previtali](https://www.linkedin.com/in/previtaliluca/)
ğŸŒ» [Luca Previtali](https://www.linkedin.com/in/previtaliluca/)
ğŸŒ» [Filip Hric](https://github.com/filiphric)
ğŸŒ» [Dorottya K.](https://github.com/DoreyKiss)

<br/><br/><br/>

This repository is inspired by the [nodebestpractices](https://github.com/i0natan/nodebestpractices) one, thank you [Yoni](https://github.com/i0natan) and the whole [steering team](https://github.com/i0natan/nodebestpractices#steering-committee) to keep it updated and to allow the creation of this repository.

<br/><br/><br/>



================================================
FILE: README.ZH.md
================================================
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD033 -->
<div align="right"><strong><a href="./README.md">ğŸ‡¬ğŸ‡§ English version</a></strong>  | <strong>ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (Chinese version)</strong></div>
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD033 -->

# UI æµ‹è¯•æœ€ä½³å®è·µ

<h1 align="center">
  <img src="assets/images/banner-2.png" alt="UI testing Best Practices">
</h1>

<br/>

<div align="center">
  <img src="https://img.shields.io/badge/âš™%20Item%20count%20-%2026%20Chapters-blue.svg" alt="26 items"> <img src="https://img.shields.io/badge/%F0%9F%93%85%20Last%20update%20-%20Jun%202025-green.svg" alt="Last update: June, 2025">
</div>

<br/>

**åœ¨ Twitter ä¸Šå…³æ³¨æˆ‘ä»¬ï¼**:

- [**@NoriSte**](https://twitter.com/NoriSte/)
- [**@MuratKeremOzcan**](https://twitter.com/MuratKeremOzcan/)

<br/>

###### ç”±æˆ‘ä»¬çš„[æŒ‡å¯¼å§”å‘˜ä¼š](#æŒ‡å¯¼å§”å‘˜ä¼š)å’Œ[åˆä½œè€…](#collaborators)æ„å»ºå’Œç»´æŠ¤

## ç›®å½•

1. [æµ‹è¯•ç­–ç•¥ (5)](#1-æµ‹è¯•ç­–ç•¥)
2. [é€šç”¨æœ€ä½³å®è·µ (6)](#2-é€šç”¨æœ€ä½³å®è·µ)
3. [æœåŠ¡é€šä¿¡æµ‹è¯• (3)](#3-æœåŠ¡é€šä¿¡æµ‹è¯•)
4. [åˆå­¦è€… (1)](#4-åˆå­¦è€…)
5. [é€šç”¨æµ‹è¯•çš„å¥½å¤„ (1)](#5-é€šç”¨æµ‹è¯•çš„å¥½å¤„)
6. [å·¥å…· (2)](#6-å·¥å…·)
7. [è¿›é˜¶ (5)](#7-è¿›é˜¶)
8. [çœŸå®æ¡ˆä¾‹ (2)](#8-çœŸå®æ¡ˆä¾‹)
9. [è¿‡æ—¶ç« èŠ‚ (3)](#9-è¿‡æ—¶ç« èŠ‚)

<br/><br/>

# `1-æµ‹è¯•ç­–ç•¥`

## 1.1 ç»„ä»¶æµ‹è¯• vs é›†æˆæµ‹è¯• vs E2E æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** è¾¨è¯†æµ‹è¯•ç±»å‹æ˜¯ç†è§£å’ŒæŒæ¡æ‰€æœ‰ UI æµ‹è¯•ç­–ç•¥ã€å·¥å…·ä»¥åŠå®ƒä»¬çš„åˆ©å¼Šçš„èµ·ç‚¹ã€‚UI é›†æˆæµ‹è¯•æ˜¯æœ€æœ‰æ•ˆçš„ï¼ˆä½ ä¼šå–œæ¬¢ä¸Šå®ƒä»¬çš„ï¼‰ï¼ŒE2E æµ‹è¯•æä¾›æœ€é«˜çš„ä¿¡å¿ƒï¼Œè€Œç»„ä»¶æµ‹è¯•åˆ™å…è®¸ä½ ç‹¬ç«‹æµ‹è¯• UI çš„å„ä¸ªå•å…ƒã€‚

**åä¹‹ï¼š** å¦åˆ™ï¼Œä½ å¯èƒ½ä¼šé™·å…¥è¿‡å¤šç¼–å†™ E2E æµ‹è¯•çš„å›°å¢ƒï¼Œè€Œå¿½ç•¥å…¶ä»–æ›´ç®€å•çš„æµ‹è¯•ç±»å‹ã€‚E2E æµ‹è¯•æ˜¯æœ€ä¸ºå¯é çš„æµ‹è¯•ç±»å‹ï¼Œä½†åŒæ—¶ä¹Ÿæ˜¯æœ€éš¾ã€æœ€æ…¢ä¸”æœ€è„†å¼±çš„ä¸€ç§ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šç»„ä»¶æµ‹è¯• vs (UI) é›†æˆæµ‹è¯• vs E2E æµ‹è¯•**](/sections/testing-strategy/component-vs-integration-vs-e2e-testing.zh.md)

<br/>

## 1.2 åœ¨å¼€å§‹é˜¶æ®µï¼Œé¿å…è¿½æ±‚å®Œç¾ä¸»ä¹‰

**ç®€è€Œè¨€ä¹‹ï¼š** è½¯ä»¶æµ‹è¯•æ˜¯ä¸€ä¸ªä»¤äººæƒŠå¹çš„è¯é¢˜ï¼Œä½†æœ‰é™çš„ç»éªŒå¯èƒ½ä½¿ä½ é™·å…¥ä¸æ–°æ•Œäººçš„æ–—äº‰ï¼Œè€Œä¸æ˜¯ä¾èµ–æ–°ç›Ÿå‹ã€‚å¦‚æœå¯èƒ½çš„è¯ï¼Œåœ¨ UI æµ‹è¯•æ—…ç¨‹çš„åˆæœŸé¿å…æµ‹è¯•æ¯ä¸ªå¤æ‚çš„ç”¨æˆ·æµç¨‹ã€‚ä½ çš„ç¬¬ä¸€ä¸ªæµ‹è¯•è¶Šç®€å•ï¼Œä½ è¶Šæ—©è·å¾—ä¼˜åŠ¿ã€‚

**åä¹‹ï¼š** ä½ å°†åˆ›å»ºå¤æ‚ä¸”éš¾ä»¥è°ƒè¯•çš„æµ‹è¯•ã€‚è¿™ç§ç±»å‹çš„æµ‹è¯•ä¼šæ‹–æ…¢ä½ çš„å·¥ä½œï¼Œè€Œä¸”æ¯«æ— ç”¨å¤„ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šåœ¨å¼€å§‹é˜¶æ®µï¼Œé¿å…è¿½æ±‚å®Œç¾ä¸»ä¹‰**](/sections/testing-strategy/avoid-perfectionism.zh.md)

<br/>

## 1.3 é€‰æ‹©ä¸€ä¸ªå‚è€ƒæµè§ˆå™¨

**ç®€è€Œè¨€ä¹‹ï¼š** è·¨æµè§ˆå™¨æµ‹è¯•è¢«é«˜ä¼°äº†ã€‚è™½ç„¶è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„ä¸»é¢˜ï¼Œä¹Ÿæ˜¯åœ¨å¼€å§‹è¯„ä¼°åˆé€‚çš„æµ‹è¯•å·¥å…·æ—¶é¦–å…ˆè€ƒè™‘çš„äº‹é¡¹ï¼Œä½†ä¸å¿…è¿‡äºæ‹…å¿ƒã€‚é¦–å…ˆï¼Œè¦å°†åŠŸèƒ½æµ‹è¯•ä¸è§†è§‰æµ‹è¯•åˆ†å¼€ï¼Œè¿™æ˜¯æ­£ç¡®è¯„ä¼°æ˜¯å¦éœ€è¦è·¨æµè§ˆå™¨æ”¯æŒçš„ç¬¬ä¸€æ­¥ï¼Œä¹Ÿæ˜¯é€‰æ‹©åˆé€‚çš„æµ‹è¯•å·¥å…·çš„å…³é”®ã€‚è§†è§‰æµ‹è¯•å¯ä»¥é›†æˆåˆ°æ¯ä¸ªæµ‹è¯•å·¥å…·ä¸­ï¼Œè¿™å¾—ç›Šäºè¯¸å¦‚ Applitools å’Œ Percy è¿™æ ·çš„æœåŠ¡ã€‚

**åä¹‹ï¼š** åŸºäºè·¨æµè§ˆå™¨æ”¯æŒåšå‡ºé€‰æ‹©ï¼Œå¯èƒ½å¯¼è‡´é€‰æ‹©é”™è¯¯çš„æµ‹è¯•å·¥å…·ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šé€‰æ‹©ä¸€ä¸ªå‚è€ƒæµè§ˆå™¨**](/sections/testing-strategy/choose-a-reference-browser.zh.md)

<br/>

## 1.4 å‘ç°äº† bugï¼Ÿå…ˆç¼–å†™æµ‹è¯•ï¼Œç„¶åå†ç€æ‰‹ä¿®å¤

**ç®€è€Œè¨€ä¹‹ï¼š** åœ¨ä½ éœ€è¦ç¡®ä¿èƒ½å¤Ÿæœ‰ç³»ç»Ÿæ€§åœ°é‡ç°æŸä¸ªç¨‹åºæ¼æ´æ—¶ï¼Œæµ‹è¯•æ˜¯ä¸€ä¸ªæä½³çš„åŠ©æ‰‹ã€‚æµ‹è¯•å¯ä»¥åŠ é€Ÿä¿®å¤æµç¨‹ï¼ŒåŒæ—¶è®©ä½ ç™¾åˆ†ä¹‹ç™¾ç¡®ä¿¡åŒæ ·çš„æ¼æ´æ°¸è¿œéƒ½èƒ½è¢«æ•æ‰åˆ°ã€‚

**åä¹‹ï¼š** å¦‚æœä½ ä¸èƒ½æ­£ç¡®åœ°è¾¨åˆ«æ¼æ´ï¼Œé‚£ä¹ˆä½ æ— æ³•ç¡®å®šè¿™ä¸ªæ¼æ´å°†æ¥æ˜¯å¦è¿˜ä¼šå†æ¬¡å‡ºç°ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šå‘ç°äº† bugï¼Ÿå…ˆç¼–å†™æµ‹è¯•ï¼Œç„¶åå†ç€æ‰‹ä¿®å¤**](/sections/testing-strategy/write-test-then-fix-bug.zh.md)

<br/>

## 1.5 å•ä¸ªé•¿çš„ç«¯åˆ°ç«¯æµ‹è¯•è¿˜æ˜¯å¤šä¸ªå°çš„ç‹¬ç«‹æµ‹è¯•ï¼Ÿ

**ç®€è€Œè¨€ä¹‹ï¼š** åœ¨å¤„ç†ç«¯åˆ°ç«¯æµ‹è¯•åŠå…¶å›°éš¾æ—¶ï¼Œé€‰æ‹©è¿›è¡Œä¸€æ¬¡é•¿æ—¶é—´çš„æµ‹è¯•è¿˜æ˜¯é€‰æ‹©è®¸å¤šå°è€Œç‹¬ç«‹çš„æµ‹è¯•å¹¶éæ˜¾è€Œæ˜“è§ã€‚è¿™ä¸¤ç§è§£å†³æ–¹æ¡ˆéƒ½æœ‰å„è‡ªçš„ä¼˜åŠ£ï¼Œè¿™æºäºç«¯åˆ°ç«¯æµ‹è¯•çš„å†…åœ¨å¤æ‚æ€§ï¼Œå…¶ä¸­æ¶‰åŠçœŸå®åç«¯å’ŒçœŸå®æ•°æ®ã€‚

**åä¹‹ï¼š** ä½ å¯èƒ½ä¼šåˆ›å»ºéš¾ä»¥ç»´æŠ¤çš„ç«¯åˆ°ç«¯æµ‹è¯•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šå•ä¸ªé•¿çš„ç«¯åˆ°ç«¯æµ‹è¯•è¿˜æ˜¯å¤šä¸ªå°çš„ç‹¬ç«‹æµ‹è¯•ï¼Ÿ**](/sections/testing-strategy/small-tests-or-long-ones.zh.md)

<br/><br/>

# `2-é€šç”¨æœ€ä½³å®è·µ`

## 2.1 ç­‰å¾…ï¼Œä¸è¦ä¼‘çœ 

**ç®€è€Œè¨€ä¹‹ï¼š** åœ¨æµ‹è¯•ç”¨æˆ·ç•Œé¢æ—¶ï¼Œä½ è¦å®šä¹‰åº”ç”¨ç¨‹åºå¿…é¡»ç»è¿‡çš„å…³é”®ç‚¹ã€‚è¾¾åˆ°è¿™äº›å…³é”®ç‚¹æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„è¿‡ç¨‹ï¼Œå› ä¸ºå‡ ä¹ç™¾åˆ†ä¹‹ç™¾çš„æƒ…å†µä¸‹ï¼Œç”¨æˆ·ç•Œé¢ä¸ä¼šåŒæ­¥æ›´æ–°ã€‚è¿™äº›å…³é”®ç‚¹è¢«ç§°ä¸º**ç¡®å®šæ€§äº‹ä»¶**ï¼Œå³ä½ çŸ¥é“å¿…é¡»å‘ç”Ÿçš„äº‹æƒ…ã€‚ä½ éœ€è¦ç­‰å¾…è¿™äº›äº‹ä»¶ä»¥ç¡®ä¿ä½ çš„æµ‹è¯•æ›´åŠ å¥å£®ã€‚

**åä¹‹ï¼š** è®©æµ‹è¯•ä¼‘çœ ä¼šä½¿æµ‹è¯•å˜å¾—ç¼“æ…¢è€Œè„†å¼±ï¼Œè¿™æ˜¯ç”¨æˆ·ç•Œé¢æµ‹è¯•ä¸­æœ€å¸¸è§ä¸”æœ€ä¸¥é‡çš„é”™è¯¯ä¹‹ä¸€ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šç­‰å¾…ï¼Œä¸è¦ä¼‘çœ **](/sections/generic-best-practices/await-dont-sleep.zh.md)

<br/>

## 2.2 æ˜æ™ºåœ°ä¸ºæµ‹è¯•æ–‡ä»¶å‘½å

**ç®€è€Œè¨€ä¹‹ï¼š** å¾ˆå¤šæ—¶å€™ï¼Œä½ å¯èƒ½åªéœ€è¦è¿è¡ŒæŸä¸€ç±»æµ‹è¯•ï¼Œå¦‚æœä½ åœ¨ä¸ºæµ‹è¯•æ–‡ä»¶å‘½åæ—¶éµå¾ªä¸€ç§å¸¸è§çš„æ¨¡å¼ï¼Œé‚£å°†éå¸¸æ–¹ä¾¿ã€‚

**åä¹‹ï¼š** ä½ å¯èƒ½éœ€è¦è¿è¡Œä¸€ä¸ªå†—é•¿çš„æµ‹è¯•å¥—ä»¶ï¼Œè€Œå®é™…ä¸Šåªæ˜¯ä¸ºäº†è¿è¡Œå…¶ä¸­çš„ä¸€äº›æµ‹è¯•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šæ˜æ™ºåœ°ä¸ºæµ‹è¯•æ–‡ä»¶å‘½å**](/sections/generic-best-practices/name-test-files-wisely.zh.md)

<br/>

## 2.3 UI æµ‹è¯•è°ƒè¯•æœ€ä½³å®è·µ

**ç®€è€Œè¨€ä¹‹ï¼š** è°ƒè¯• UI æµ‹è¯•å¯èƒ½éå¸¸å›°éš¾ï¼Œç‰¹åˆ«æ˜¯å½“ä½ ä½¿ç”¨é€šç”¨çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·æ—¶ã€‚ä»¥ä¸‹æ˜¯è°ƒè¯•è¿‡ç¨‹ä¸­çš„ä¸€äº›åŸºæœ¬è§„åˆ™ã€‚

**åä¹‹ï¼š** ä½ å°†ä¼šèŠ±è´¹å¤§é‡æ—¶é—´ï¼Œè€Œæ— æ³•åº”å¯¹ UI æµ‹è¯•çš„æŒ‡æ•°å¤æ‚æ€§ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šUI æµ‹è¯•è°ƒè¯•æœ€ä½³å®è·µ**](/sections/generic-best-practices/ui-tests-debugging-best-practices.zh.md)

<br/>

## 2.4 åœ¨æµ‹è¯•ä¸­è¾¾åˆ° UI çŠ¶æ€è€Œæ— éœ€ä½¿ç”¨ UI

**ç®€è€Œè¨€ä¹‹ï¼š** ä½œä¸ºä¸€ä¸ªè¿½æ±‚è´¨é‡çš„å¼€å‘è€…ï¼Œæ€è€ƒæµ‹è¯•çš„æˆæœ¬ä¸å®ƒä»¬æä¾›çš„ä»·å€¼æ˜¯è‡³å…³é‡è¦çš„ã€‚åœ¨åˆç†çš„æƒ…å†µä¸‹ï¼ŒåŠªåŠ›é¿å…é‡å¤åŠªåŠ›ï¼Œå¹¶é€šè¿‡è€ƒè™‘ä¸ºæµ‹è¯•è®¾ç½®çŠ¶æ€çš„æ›¿ä»£æ–¹æ¡ˆï¼Œä¾ç„¶èƒ½å¤Ÿè·å¾—é«˜ä»·å€¼ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šè¾¾åˆ° UI çŠ¶æ€**](./sections/generic-best-practices/reaching-ui-state.zh.md)

<br/>

## 2.5 å°†ä½ çš„æµ‹è¯•å·¥å…·ç”¨ä½œä¸»è¦çš„å¼€å‘å·¥å…·

**ç®€è€Œè¨€ä¹‹ï¼š** åˆ©ç”¨æµ‹è¯•å·¥å…·æ¥é¿å…æ‰‹åŠ¨æµ‹è¯•æ˜¯æé«˜å·¥ä½œæ•ˆç‡çš„æœ€å¤§æ”¹è¿›ä¹‹ä¸€ã€‚æµ‹è¯•å·¥å…·æ¯”ä½ æ›´å¿«ï¼Œè€Œä¸”å¤§å¤šæ•°ç°ä»£å·¥å…·éƒ½åŒ…å«ä¸€äº› UI å·¥å…·ï¼Œä½¿å¾—å°†å…¶ç”¨ä½œå¼€å‘å·¥å…·å˜å¾—æ›´åŠ å®¹æ˜“ã€‚

**åä¹‹ï¼š** ä»¥ä¼ ç»Ÿæ–¹å¼ç¼–å†™åº”ç”¨ç¨‹åºï¼ŒèŠ±è´¹å¤§é‡æ—¶é—´æ‰‹åŠ¨ä¸ UI è¿›è¡Œäº¤äº’ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šå°†ä½ çš„æµ‹è¯•å·¥å…·ç”¨ä½œä¸»è¦çš„å¼€å‘å·¥å…·**](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.zh.md)

<br/>

## 2.6 ä¿æŒä½æŠ½è±¡åº¦ä»¥ä¾¿äºè°ƒè¯•æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** ç¼–å†™æµ‹è¯•æ—¶åº”è€ƒè™‘å¯è¯»æ€§å’Œå¯è°ƒè¯•æ€§ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒæŠ½è±¡å¯èƒ½æ˜¯æœ‰ç›Šçš„ï¼Œä½†å®ƒæ€»æ˜¯ä¼šå¢åŠ è°ƒè¯•çš„æˆæœ¬ï¼Œå› æ­¤æœ‰æ—¶å¯èƒ½ä¸å€¼å¾—ã€‚è¿™å¯¹äº UI æµ‹è¯•å°¤ä¸ºé‡è¦ï¼›ç”±äºå¤æ‚çš„æŠ€æœ¯æ ˆï¼Œç†è§£æ•…éšœçš„çœŸå®æºå¤´å¯èƒ½å˜å¾—æ›´åŠ å›°éš¾ã€‚ä¸ºäº†æ›´å®¹æ˜“è°ƒè¯•ï¼Œé™ä½æŠ½è±¡åº¦æ˜¯æœªæ¥æµ‹è¯•ä»£ç çš„å…³é”®ã€‚

**åä¹‹ï¼š** æŠ½è±¡åº¦å’Œå¯è°ƒè¯•æ€§ä¹‹é—´å­˜åœ¨å¹³è¡¡ï¼›æŠ½è±¡åº¦è¶Šé«˜ï¼Œå°†æ¥è°ƒè¯•æµ‹è¯•å°±è¶Šå›°éš¾ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä¿æŒä½æŠ½è±¡åº¦ä»¥ä¾¿äºè°ƒè¯•æµ‹è¯•**](/sections/generic-best-practices/test-code-with-debugging-in-mind.zh.md)

<br/><br/>

# `3-æœåŠ¡é€šä¿¡æµ‹è¯•`

## 3.1 æ£€éªŒè¯·æ±‚å’Œå“åº”è´Ÿè½½

**ç®€è€Œè¨€ä¹‹ï¼š** UI ä¸åç«¯æŒç»­é€šä¿¡ï¼Œé€šå¸¸æ¯æ¬¡é€šä¿¡éƒ½è‡³å…³é‡è¦ã€‚ä¸è‰¯çš„è¯·æ±‚æˆ–å“åº”å¯èƒ½å¯¼è‡´ä¸ä¸€è‡´çš„æ•°æ®å’Œä¸ä¸€è‡´çš„ UI çŠ¶æ€ã€‚è¯·è®°ä½ï¼Œæ‰€æœ‰ä¸šåŠ¡éƒ½å›´ç»•æ•°æ®æ„å»ºï¼Œè€Œæ¯æ¬¡ UI å¤±è´¥éƒ½ä¼šå½±å“ç”¨æˆ·ä½“éªŒã€‚å› æ­¤ï¼Œå¿…é¡»ä»”ç»†æ£€æŸ¥æ¯ä¸ª XHR è¯·æ±‚ã€‚XHR è¯·æ±‚çš„æ£€æŸ¥è¿˜èƒ½ä½¿æµ‹è¯•æ›´ä¸ºå¥å£®ï¼Œæ­£ç¡®çš„ XHR ç®¡ç†å’Œæµ‹è¯•æ˜¯ UI æµ‹è¯•ä¸­æœ€é‡è¦çš„æ–¹é¢ä¹‹ä¸€ã€‚

**åä¹‹ï¼š** ä½ å¯èƒ½ä¼šé”™è¿‡ä¸€äº›ç›¸å…³çš„é€šä¿¡ä¸ä¸€è‡´æ€§ï¼Œå½“ä½ éœ€è¦è°ƒè¯•æ—¶ï¼Œç”±äºæµ‹è¯•ä¸ä¼šç›´æ¥æŒ‡å¼•ä½ æ‰¾åˆ°é—®é¢˜ï¼Œä½ å°†æµªè´¹å¤§é‡æ—¶é—´ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šæ£€éªŒè¯·æ±‚å’Œå“åº”è´Ÿè½½**](/sections/server-communication-testing/test-request-and-response-payload.zh.md)

<br/>

## 3.2 å®¡æŸ¥æœåŠ¡å™¨æ¶æ„

**ç®€è€Œè¨€ä¹‹ï¼š** å‰ç«¯åº”ç”¨å¾ˆå¤šæ—¶å€™ä¼šå› åç«¯çš„å˜åŒ–è€Œå‡ºç°æ•…éšœã€‚è¯·å‘åç«¯åŒäº‹è¯·æ±‚å…è®¸ä½ å¯¼å‡ºæè¿°åç«¯å®ä½“å’Œä¸å‰ç«¯é€šä¿¡çš„æ¯ä¸ªæ¶æ„çš„æ‰€æœ‰æ¨¡å¼ã€‚ä¸€äº›ç¤ºä¾‹å¯èƒ½åŒ…æ‹¬ GraphQL æ¶æ„ã€TypeScript ç±»å‹ã€ElasticSearch æ˜ å°„ã€Pact åˆåŒã€Postman é…ç½®ç­‰ï¼Œæ›´ä¸€èˆ¬åœ°è¯´ï¼Œä¸€åˆ‡éƒ½å¯ä»¥æé†’ä½ åç«¯å‘ç”Ÿäº†å˜åŒ–ã€‚æ¯æ¬¡åç«¯æ›´æ”¹éƒ½å¯èƒ½å½±å“å‰ç«¯ï¼Œä½ å¿…é¡»å°½æ—©å‘ç°ã€‚

**åä¹‹ï¼š** ä½ å¯èƒ½ä¼šé”™è¿‡ä¸€äº›åç«¯æ›´æ”¹ï¼Œå¯¼è‡´å‰ç«¯åº”ç”¨ä¸ç»æ„é—´å´©æºƒã€‚

<br/>

## 3.3 æµ‹è¯•ç›‘æ§

**ç®€è€Œè¨€ä¹‹ï¼š** æµ‹è¯•å¥—ä»¶å®šæœŸå¯åŠ¨çš„æ¬¡æ•°è¶Šå¤šï¼Œä½ å¯¹ä¸€åˆ‡éƒ½æŒ‰é¢„æœŸå·¥ä½œçš„ä¿¡å¿ƒå°±è¶Šè¶³ã€‚UI æµ‹è¯•åº”è¯¥åŸºäºç”¨æˆ·çš„è§†è§’ï¼Œä½†æœ‰è®¸å¤šå°æµ‹è¯•å¯ä»¥ä¸ºä½ æä¾›å¤§é‡å³æ—¶åé¦ˆï¼Œè€Œæ— éœ€è°ƒè¯•ç”¨æˆ·æµç¨‹ã€‚ç›‘æ§é‚£äº›çœ‹ä¼¼å¾®ä¸è¶³é“çš„æŠ€æœ¯ç»†èŠ‚æœ‰åŠ©äºé¢„é˜²æ›´å¤§çš„æµ‹è¯•å¤±è´¥ã€‚

**åä¹‹ï¼š** ä½ ä¼šå°†æŠ€æœ¯ç»†èŠ‚æµ‹è¯•ä¸ç”¨æˆ·å¯¼å‘çš„æµ‹è¯•æ··ä¸ºä¸€è°ˆã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šæµ‹è¯•ç›‘æ§**](/sections/server-communication-testing/monitoring-tests.zh.md)

<br/><br/>

# `4-åˆå­¦è€…`

## 4.1 ä»é‡‘å­—å¡”é¡¶å±‚å…¥æ‰‹æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** ä»¥é‡‘å­—å¡”é¡¶å±‚ä½œä¸ºæµ‹è¯•å…¥æ‰‹å¯èƒ½æ•ˆç‡ä½ä¸‹ä¸”ä¸ä»¤äººæ»¡æ„ã€‚ä½ å¼€å§‹ç¼–å†™ä¸€äº›å•å…ƒæµ‹è¯•ï¼Œä½†ä»ç„¶å­˜åœ¨è®¸å¤šç–‘è™‘ã€‚é€šè¿‡ UI æµ‹è¯•ï¼Œä½ å¯ä»¥ä»ç¬¬ä¸€å¤©å°±ä»¥è¾ƒé«˜çš„ä¿¡å¿ƒå¼€å§‹æµ‹è¯•ã€‚

**åä¹‹ï¼š** é”™è¯¯çš„æ–¹æ³•å¯èƒ½ä¼šå½±å“ä½ å¯¹æµ‹è¯•çš„æ€è€ƒæ–¹å¼ï¼Œä½¿ä½ äº§ç”Ÿé”™è¯¯çš„æµ‹è¯•æ–¹å¼çš„é”™è¯¯è§‚å¿µï¼Œè€Œå®é™…ä¸Šä½ å¹¶æ²¡æœ‰è¿›è¡Œæœ‰æ•ˆçš„æµ‹è¯•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä»é‡‘å­—å¡”é¡¶å±‚å…¥æ‰‹æµ‹è¯•ï¼**](/sections/beginners/top-to-bottom-approach.zh.md)

<br/><br/>

# `5-é€šç”¨æµ‹è¯•çš„å¥½å¤„`

## 5.1 å°†æµ‹è¯•è§†ä¸ºæ–‡æ¡£å·¥å…·

**ç®€è€Œè¨€ä¹‹ï¼š** æµ‹è¯•æ˜¯ä¸€ç§ç®€æ´ã€ä¸ä»£ç ç´§å¯†å…³è”ä¸”ä¸æ–­æ›´æ–°çš„æ–‡æ¡£æ–¹å¼ã€‚é€šè¿‡å…·æœ‰è‰¯å¥½å™è¿°çš„æµ‹è¯•æè¿°ï¼Œå¯ä»¥ä½¿å¯¹ä»£ç åº“æˆ–æ–°é¡¹ç›®çš„ç†è§£å˜å¾—éå¸¸ç®€å•ã€‚

**åä¹‹ï¼š** å¦‚æœä¸ä¾èµ–äºä»£ç æ–‡æ¡£ï¼Œç”šè‡³æ›´ç³Ÿç³•çš„æ˜¯ä¾èµ–äºä»£ç çš„å¯è¯»æ€§æ¥ç†è§£ä»£ç çš„ä½œç”¨ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šå°†æµ‹è¯•è§†ä¸ºæ–‡æ¡£å·¥å…·**](/sections/testing-perks/tests-as-documentation.zh.md)

<br/><br/>

# `6-å·¥å…·`

## 6.1 ä¸€äº› UI æµ‹è¯•é—®é¢˜åŠ Cypress çš„è§£å†³æ–¹æ¡ˆ

**ç®€è€Œè¨€ä¹‹ï¼š** ä¸ºä»€ä¹ˆæµ‹è¯• Web åº”ç”¨è¿™ä¹ˆéš¾ï¼Ÿé€šç”¨çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·ä¸ºä»€ä¹ˆä¸å¤ªé€‚ç”¨äº UI/E2E æµ‹è¯•çš„éœ€æ±‚ï¼ŸCypress ä¸ºä»€ä¹ˆå¦‚æ­¤å‡ºè‰²ï¼Ÿ

**å¦åˆ™ï¼š** ä»…ä»…é€šè¿‡é€šç”¨åŠŸèƒ½æ¯”è¾ƒæ— æ³•ç†è§£ UI æµ‹è¯•çš„ä¸»è¦é—®é¢˜ï¼Œä»¥åŠ Cypress æ˜¯å¦‚ä½•è§£å†³å®ƒä»¬çš„ã€‚

> [!NOTE]
> æ‰€æœ‰ç°ä»£å‰ç«¯æµ‹è¯•å·¥å…·ï¼ˆPlaywrightã€Storybookã€Cypressã€TestCafÃ©ï¼‰éƒ½å…·æœ‰ç±»ä¼¼çš„åŠŸèƒ½å’Œ UI å·¥å…·ï¼Œå› æ­¤ç›¸åŒçš„å†…å®¹é€‚ç”¨äºæ‰€æœ‰å·¥å…·ï¼Œè€Œä¸ä»…ä»…æ˜¯ Cypressã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä¸€äº› UI æµ‹è¯•é—®é¢˜åŠ Cypress çš„è§£å†³æ–¹æ¡ˆ**](/sections/tools/ui-testing-problems-cypress.zh.md)

<br/><br/>

## 6.2 è§†è§‰å›å½’æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** è§†è§‰å›å½’æµ‹è¯•ä¸ºä»€ä¹ˆå¦‚æ­¤å›°éš¾ï¼Œä»¥åŠä¸ºä»€ä¹ˆæˆ‘ä»¬åº”è¯¥ä¾èµ–é«˜çº§æœåŠ¡ã€‚

**åä¹‹ï¼š** åˆæ˜¯ä¸€ä¸ªæˆ‘ä»¬ä¸åœ¨æ„çš„å›å½’æµ‹è¯•å·¥ä½œã€‚æœ‰å¯èƒ½ä¼šæ¼æ‰è§†è§‰å·®å¼‚ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šè§†è§‰å›å½’æµ‹è¯•**](/sections/tools/visual-regression-testing.zh.md)

<br/><br/>

# `7-è¿›é˜¶`

## 7.1 æµ‹è¯•çŠ¶æ€

**ç®€è€Œè¨€ä¹‹ï¼š** æµ‹è¯•åº”è¯¥æ˜¯å¯é‡å¤çš„ã€æ¨¡å—åŒ–çš„ï¼Œå¹¶ä¸”åº”è¯¥å¤„ç†è‡ªèº«çš„çŠ¶æ€è®¾ç½®ã€‚ä¸ºäº†å®ç°å…¶ä»–æµ‹è¯•çš„çŠ¶æ€ï¼Œä¸åº”é‡å¤æ‰§è¡Œ UI æµ‹è¯•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šæµ‹è¯•çŠ¶æ€**](./sections/advanced/test-states.zh.md)

<br/>

## 7.2 ä¸ç¨³å®šçš„æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** æ¯æ¬¡æµ‹è¯•åº”äº§ç”Ÿä¸€è‡´çš„ç»“æœã€‚å¯é‡å¤çš„æµæ°´çº¿æ‰§è¡Œç»“æœæ˜¯é€‰ä¸¾çš„åŸºå‡†ã€‚
å¦‚æœæµ‹è¯•æ— æ³•äº§ç”Ÿå¯é çš„ç»“æœï¼Œå®ƒä¼šé™ä½å¯¹æµ‹è¯•çš„ä¿¡å¿ƒå¹¶éœ€è¦ç»´æŠ¤ï¼Œä»è€Œé™ä½æ‰€æœ‰ä»·å€¼ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæœ€å¥½æ‰‹åŠ¨æµ‹è¯•åŠŸèƒ½ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä¸ç¨³å®šçš„æµ‹è¯•**](./sections/advanced/test-flake.zh.md)

<br/>

## 7.3 ç»„åˆæµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** å¤§å¤šæ•°è½¯ä»¶é”™è¯¯å’Œæ•…éšœæ˜¯ç”±ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‚æ•°å¼•èµ·çš„ã€‚æµ‹è¯•å‚æ•°ç»„åˆå¯ä»¥æ¯”ä¼ ç»Ÿæ–¹æ³•æ›´æœ‰æ•ˆåœ°æ£€æµ‹æ•…éšœã€‚ç»„åˆæµ‹è¯•æ˜¯ä¸€ç§ç»è¿‡éªŒè¯çš„ã€æˆæœ¬æ›´ä½çš„æ›´æœ‰æ•ˆçš„è½¯ä»¶æµ‹è¯•æ–¹æ³•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šç»„åˆæµ‹è¯•**](./sections/advanced/combinatorial-testing.zh.md)

<br/>

## 7.4 æ€§èƒ½æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** å°½ç®¡è¿™æ˜¯ä¸€ä¸ªåºå¤§çš„ä¸»é¢˜ï¼Œä½†ä» Web å¼€å‘çš„è§’åº¦æ¥çœ‹ï¼Œæ€§èƒ½æµ‹è¯•å¯ä»¥é€šè¿‡ç°ä»£å·¥å…·å’Œç†è§£æ¥ç®€åŒ–ã€‚å®ƒåœ¨ç¡®ä¿ç”¨æˆ·ä½“éªŒã€æ»¡è¶³éåŠŸèƒ½æ€§éœ€æ±‚ï¼ˆNFRSï¼‰ä»¥åŠåŠæ—©æ£€æµ‹å¯èƒ½çš„ç³»ç»Ÿæ•…éšœæ–¹é¢éå¸¸æœ‰æ•ˆã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šæ€§èƒ½æµ‹è¯•**](./sections/advanced/performance-testing.zh.md)

<br/>

## 7.5 ç”µå­é‚®ä»¶æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** ç”µå­é‚®ä»¶æµ‹è¯•å¯¹äºä¸šåŠ¡æˆåŠŸè‡³å…³é‡è¦ã€‚ç°ä»£æœåŠ¡ä¸ä»…å…è®¸è‡ªåŠ¨åŒ–çš„ç”µå­é‚®ä»¶æµ‹è¯•ï¼Œè€Œä¸”åœ¨æµ‹è¯• SaaS åº”ç”¨ç¨‹åºæ—¶è¿˜æä¾›äº†ä¸€ç§æ— çŠ¶æ€ã€å¯æ‰©å±•çš„è§£å†³æ–¹æ¡ˆã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šç”µå­é‚®ä»¶æµ‹è¯•**](./sections/advanced/email-testing.zh.md)

---

<br/><br/>

# `8-çœŸå®æ¡ˆä¾‹`

## 8.1 Siemens - ç”¨é›†æˆæµ‹è¯•æµ‹è¯•å‰ç«¯ï¼Œç”¨ E2E æµ‹è¯•æµ‹è¯•åç«¯ - å‚è€ƒ [ç»„ä»¶æµ‹è¯• vsï¼ˆUIï¼‰é›†æˆæµ‹è¯• vs E2E æµ‹è¯•](./sections/testing-strategy/component-vs-integration-vs-e2e-testing.zh.md)

**ç®€è€Œè¨€ä¹‹ï¼š** ä½¿ç”¨å¸¦æœ‰å­˜æ ¹æœåŠ¡å™¨çš„ UI æµ‹è¯•ç›¸æ¯”å®Œæ•´çš„ E2E æµ‹è¯•æ›´ä¸ºå¯é ä¸”æ›´å¿«ã€‚å¹¶éæ€»æ˜¯éœ€è¦å®Œæ•´çš„ E2E æµ‹è¯•æ¥ç¡®ä¿å‰ç«¯è´¨é‡ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨æˆæœ¬è¾ƒä½çš„ UI é›†æˆæµ‹è¯•å¯¹å‰ç«¯è´¨é‡å…·æœ‰é«˜åº¦ä¿¡å¿ƒï¼Œå¹¶å°†æˆæœ¬è¾ƒé«˜çš„ E2E æµ‹è¯•ä¿ç•™ç»™åç«¯ã€‚

**åä¹‹ï¼š** åœ¨è¿›è¡Œç¼“æ…¢ä¸”è„†å¼±çš„ E2E æµ‹è¯•æ—¶æµªè´¹æ—¶é—´å’Œèµ„æºï¼Œè€Œé€šè¿‡è¿›è¡Œå¤§é‡çš„ UI é›†æˆæµ‹è¯•å¯ä»¥è·å¾—é«˜åº¦çš„ä¿¡å¿ƒã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šç”¨é›†æˆæµ‹è¯•æµ‹è¯•å‰ç«¯ï¼Œç”¨ E2E æµ‹è¯•æµ‹è¯•åç«¯**](./sections/real-life-examples/test-front-end-with-integration-back-end-with-e2e.zh.md)

<br/>

## 8.2 WorkWave - ä»éš¾ä»¥ç†è§£çš„ React ç»„ä»¶æµ‹è¯•åˆ°ç®€å•æ„šè ¢çš„æµ‹è¯•

**ç®€è€Œè¨€ä¹‹ï¼š** æµ‹è¯•ä»£ç å¿…é¡»å°½å¯èƒ½ç®€å•æ˜äº†ã€‚è¿™æ ·å¯ä»¥åœ¨éœ€è¦æ—¶èŠ‚çœå¤§é‡çš„ç†è§£ã€æ›´æ–°ã€é‡æ„å’Œä¿®å¤æ—¶é—´ã€‚ç›¸åï¼Œå¦‚æœç”šè‡³ä½œè€…è‡ªå·±ä¹Ÿæ— æ³•é˜…è¯»æŸäº›æµ‹è¯•ï¼Œé‚£å°±ä¼šå‘ç”Ÿå¯æ€•çš„æƒ…å†µï¼è¿™é‡Œæä¾›äº†ä¸€äº›è§£é‡Šæµ‹è¯•ä»£ç éš¾ä»¥ç†è§£çš„ä¾‹å­ï¼Œå¹¶å±•ç¤ºäº†å®ƒä»¬çš„é‡æ„è¿‡ç¨‹ã€‚

**åä¹‹ï¼š** å½“æ‚¨å¿…é¡»æ›´æ–°æˆ–ä¿®å¤æµ‹è¯•æ—¶ï¼ŒèŠ±è´¹å¤§é‡æ—¶é—´é˜…è¯»å’Œç†è§£æµ‹è¯•ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä»éš¾ä»¥ç†è§£çš„ React ç»„ä»¶æµ‹è¯•åˆ°ç®€å•æ„šè ¢çš„æµ‹è¯•**](./sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.zh.md)

<br/> <br/>

# `9-è¿‡æ—¶ç« èŠ‚`

## ä½¿ç”¨ Cypress è¿›è¡Œ React ç»„ä»¶çš„å•å…ƒæµ‹è¯•

*æ­¤éƒ¨åˆ†ç°å·²æ ‡è®°ä¸ºè¿‡æ—¶ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°ä¸€ä¸ªéå¸¸æ—§çš„ Cypress ç‰ˆæœ¬ï¼ˆç°åœ¨å·²å®Œå…¨æ”¯æŒç»„ä»¶æµ‹è¯•ï¼‰ã€‚

**ç®€è€Œè¨€ä¹‹ï¼š** Cypress v4.5.0 å‘å¸ƒå…è®¸å¯¹ React ç»„ä»¶è¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œä¸å†éœ€è¦ç±»ä¼¼ Storybook çš„å¤–éƒ¨å·¥å…·æ¥æµ‹è¯•å­¤ç«‹çš„ç»„ä»¶ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä½¿ç”¨ Cypress è¿›è¡Œ React ç»„ä»¶çš„å•å…ƒæµ‹è¯•**](/sections/tools/cypress-react-component-test.zh.md)

<br/>

## [@daedalius](https://github.com/daedalius) çš„æ–¹æ³•ï¼šä» Storybook ä¸­å…¬å¼€ç»„ä»¶ï¼Œå°†æ•…äº‹ä¸æµ‹è¯•åˆ†ç¦»

*æ­¤éƒ¨åˆ†ç°å·²æ ‡è®°ä¸ºè¿‡æ—¶ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°ä¸€ä¸ªéå¸¸æ—§çš„ Cypress å’Œ Storybook ç‰ˆæœ¬ï¼ˆç°åœ¨å®ƒä»¬éƒ½å®Œå…¨æ”¯æŒç»„ä»¶æµ‹è¯•ï¼‰ã€‚

**ç®€è€Œè¨€ä¹‹ï¼š** ä½ å¯ä»¥ä» Storybook æ•…äº‹ä¸­å…¬å¼€ç»„ä»¶å¼•ç”¨ï¼Œä»¥åœ¨ Cypress ä¸­æµ‹è¯•ä»»ä½•ä½ å¸Œæœ›æµ‹è¯•çš„å†…å®¹ï¼Œè€Œä¸ä¼šå°†æµ‹è¯•é€»è¾‘åˆ†è§£æˆå¤šä¸ªéƒ¨åˆ†ã€‚

**åä¹‹ï¼š** å°†æµ‹è¯•é€»è¾‘å’Œæµ‹è¯•æ•°æ®æ‹†åˆ†å¼€ä¼šä½¿å…¶éš¾ä»¥é˜…è¯»å’Œç»´æŠ¤ã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šCypress + Storybookã€‚ä¿æŒæµ‹è¯•åœºæ™¯ã€æ•°æ®å’Œç»„ä»¶æ¸²æŸ“åœ¨ä¸€ä¸ªåœ°æ–¹ã€‚**](/sections/tools/cypress-and-storybook-exposing-component-from-story.zh.md)

## [@NoriSte](https://github.com/NoriSte) çš„æ–¹æ³•ï¼šä½¿ç”¨ Cypress å’Œ Storybook è¿›è¡Œç»„ä»¶æµ‹è¯•

*æ­¤éƒ¨åˆ†ç°å·²æ ‡è®°ä¸ºè¿‡æ—¶ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ°ä¸€ä¸ªéå¸¸æ—§çš„ Cypress å’Œ Storybook ç‰ˆæœ¬ï¼ˆç°åœ¨å®ƒä»¬éƒ½å®Œå…¨æ”¯æŒç»„ä»¶æµ‹è¯•ï¼‰ã€‚

**ç®€è€Œè¨€ä¹‹ï¼š** ç»„ä»¶æ˜¯ä½ çš„åº”ç”¨ç¨‹åºçš„æ„å»ºå—ï¼Œåœ¨å­¤ç«‹çŠ¶æ€ä¸‹æµ‹è¯•å®ƒä»¬å¯¹äºå°½æ—©å‘ç°é—®é¢˜éå¸¸é‡è¦ã€‚

**åä¹‹ï¼š** æ²¡æœ‰åº•å±‚æµ‹è¯•çš„ UI æµ‹è¯•æ— æ³•è®©ä½ äº†è§£é—®é¢˜çš„æ ¹æºã€‚

ğŸ”— [**é˜…è¯»æ›´å¤šï¼šä½¿ç”¨ Cypress å’Œ Storybook è¿›è¡Œç»„ä»¶æµ‹è¯•**](/sections/tools/cypress-and-storybook.zh.md)

<br/> <br/>

## æŒ‡å¯¼å§”å‘˜ä¼š

äº†è§£æŒ‡å¯¼å§”å‘˜ä¼šæˆå‘˜ - ä¸€èµ·ä¸ºé¡¹ç›®æä¾›æŒ‡å¯¼å’Œæœªæ¥æ–¹å‘çš„äººä»¬ã€‚

<div>
<img align="left" width="100" height="100" src="assets/images/members/noriste.png">

[Stefano Magni](https://github.com/NoriSte)
<a href="https://twitter.com/NoriSte"><img src="assets/images/twitter-s.png" width="16" height="16"></img></a>
<a href="https://github.com/NoriSte"><picture><source media="(prefers-color-scheme: dark)" srcset="assets/images/github-dark.png"><img alt="GitHub" src="assets/images/github-light.png" width="16" height="16"></picture>
<a href="https://www.linkedin.com/in/noriste/"><img src="assets/images/linkedin.png" width="16" height="16"></img></a>

</img></a>

å……æ»¡æ¿€æƒ…ï¼Œç§¯æä¹è§‚ / å‰ç«¯æŠ€æœ¯é¢†å¯¼è€…ï¼ˆå¹³å°ï¼‰[Hasura](https://hasura.io/) / æ¼”è®²è€… / è®²å¸ˆ / è¿œç¨‹å·¥ä½œè€…ã€‚

<br/>
<br/>
</div>

<div>

<img align="left" width="100" height="100" src="assets/images/members/muratkeremozcan.png">

[Murat Ozcan](https://github.com/NoriSte)
<a href="https://twitter.com/MuratKeremOzcan"><img src="assets/images/twitter-s.png" width="16" height="16"></img></a>
<a href="https://github.com/muratkeremozcan"><picture><source media="(prefers-color-scheme: dark)" srcset="assets/images/github-dark.png"><img alt="GitHub" src="assets/images/github-light.png" width="16" height="16"></picture>
<a href="https://www.linkedin.com/in/murat-ozcan-3489898/"><img src="assets/images/linkedin.png" width="16" height="16"></img></a>

</img></a>

çƒ­è¡·äºæŠ€æœ¯ï¼Œçƒ­çˆ±æµ‹è¯•ã€å¼€å‘ã€DevOpsã€Web å’Œäº‘ã€‚[Extend](https://www.extend.com/) çš„æŠ€æœ¯ä¸“å®¶ / æµ‹è¯•æ¶æ„å¸ˆã€‚

<br/>
<br/>

</div>

## æ„Ÿè°¢ä¿¡

æˆ‘ä»¬æ„Ÿæ¿€ä»»ä½•è´¡çŒ®ï¼Œæ— è®ºæ˜¯å•ä¸ªè¯æ±‡çš„ä¿®å¤è¿˜æ˜¯æ–°çš„æœ€ä½³å®è·µã€‚ä¸‹é¢æ˜¯ä¸ºè¿™ä¸ªé¡¹ç›®åšå‡ºè´¡çŒ®çš„æ‰€æœ‰äººçš„åˆ—è¡¨ã€‚ğŸŒ»æ ‡è®°ç€æˆåŠŸçš„æ‹‰å–è¯·æ±‚ï¼Œâ­æ ‡è®°ç€è¢«æ‰¹å‡†çš„æ–°æœ€ä½³å®è·µã€‚

### Stars

ä¸€ä¸ªè¢«æ‰¹å‡†çš„æ–°æœ€ä½³å®è·µï¼Œæˆä¸ºç¬¬ä¸€ä¸ªæ”¶åˆ°â­çš„äººï¼Œä¸ºè¿™ä¸ªä»“åº“åšå‡ºè´¡çŒ® ğŸ˜

â­ [Murat Ozcan](https://github.com/muratkeremozcan)
â­ [Dmitriy Tishin](https://github.com/daedalius)

### é²œèŠ±

ä¸€ä¸ªæˆåŠŸçš„ PR ä¼šç»™ä½ ä¸€æœµ ğŸŒ»ï¼Œæˆä¸ºç¬¬ä¸€ä¸ªæ”¶åˆ°å®ƒçš„äººã€‚

ğŸŒ» [Anoop Kumar Gupta](https://github.com/anoop-gupt)
ğŸŒ» [Ferdinando Santacroce](https://github.com/jesuswasrasta)
ğŸŒ» [Luca Piazzoni](https://github.com/bioz87)
ğŸŒ» [Luca Previtali](https://www.linkedin.com/in/previtaliluca/)
ğŸŒ» [Luca Previtali](https://www.linkedin.com/in/previtaliluca/)
ğŸŒ» [Filip Hric](https://github.com/filiphric)

<br/><br/><br/>

è¿™ä¸ªä»“åº“å—åˆ°äº† [nodebestpractices](https://github.com/i0natan/nodebestpractices) ä»“åº“çš„å¯å‘ï¼Œæ„Ÿè°¢ [Yoni](https://github.com/i0natan) å’Œæ•´ä¸ª [æŒ‡å¯¼å§”å‘˜ä¼š](https://github.com/i0natan/nodebestpractices#steering-committee) çš„åŠªåŠ›ï¼Œä¿æŒå…¶æ›´æ–°å¹¶å…è®¸åˆ›å»ºè¿™ä¸ªä»“åº“ã€‚

<br/><br/><br/>



================================================
FILE: LICENSE
================================================
## creative commons

# Attribution-ShareAlike 4.0 International

Creative Commons Corporation (â€œCreative Commonsâ€) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an â€œas-isâ€ basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.

### Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.

* __Considerations for licensors:__ Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. [More considerations for licensors](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensors).

* __Considerations for the public:__ By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensorâ€™s permission is not necessary for any reasonâ€“for example, because of any applicable exception or limitation to copyrightâ€“then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. [More considerations for the public](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensees).

## Creative Commons Attribution-ShareAlike 4.0 International Public License

By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License ("Public License"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.

### Section 1 â€“ Definitions.

a. __Adapted Material__ means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.

b. __Adapter's License__ means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.

c. __BY-SA Compatible License__ means a license listed at [creativecommons.org/compatiblelicenses](http://creativecommons.org/compatiblelicenses), approved by Creative Commons as essentially the equivalent of this Public License.

d. __Copyright and Similar Rights__ means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.

e. __Effective Technological Measures__ means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.

f. __Exceptions and Limitations__ means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.

g. __License Elements__ means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.

h. __Licensed Material__ means the artistic or literary work, database, or other material to which the Licensor applied this Public License.

i. __Licensed Rights__ means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.

j. __Licensor__ means the individual(s) or entity(ies) granting rights under this Public License.

k. __Share__ means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.

l. __Sui Generis Database Rights__ means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.

m. __You__ means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.

### Section 2 â€“ Scope.

a. ___License grant.___

   1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:

       A. reproduce and Share the Licensed Material, in whole or in part; and

       B. produce, reproduce, and Share Adapted Material.

   2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.

   3. __Term.__ The term of this Public License is specified in Section 6(a).

   4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.

   5. __Downstream recipients.__

       A. __Offer from the Licensor â€“ Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.

       B. __Additional offer from the Licensor â€“ Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapterâ€™s License You apply.

       C. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.

   6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).

b. ___Other rights.___

   1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.

   2. Patent and trademark rights are not licensed under this Public License.

   3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.

### Section 3 â€“ License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the following conditions.

a. ___Attribution.___

   1. If You Share the Licensed Material (including in modified form), You must:

       A. retain the following if it is supplied by the Licensor with the Licensed Material:

         i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);

         ii. a copyright notice;

         iii. a notice that refers to this Public License;

         iv. a notice that refers to the disclaimer of warranties;

         v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;

       B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and

       C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.

   2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.

   3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.

b. ___ShareAlike.___

In addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply.

1. The Adapterâ€™s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.

2. You must include the text of, or the URI or hyperlink to, the Adapter's License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.

3. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter's License You apply.

### Section 4 â€“ Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:

a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;

b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and

c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.

### Section 5 â€“ Disclaimer of Warranties and Limitation of Liability.

a. __Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.__

b. __To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.__

c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.

### Section 6 â€“ Term and Termination.

a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.

b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:

   1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or

   2. upon express reinstatement by the Licensor.

   For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.

c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.

d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.

### Section 7 â€“ Other Terms and Conditions.

a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.

b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.t stated herein are separate from and independent of the terms and conditions of this Public License.

### Section 8 â€“ Interpretation.

a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.

b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.

c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.

d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.

> Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the â€œLicensor.â€ Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark â€œCreative Commonsâ€ or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.
>
> Creative Commons may be contacted at creativecommons.org



================================================
FILE: assets/images/viconblue.PNG
================================================
[Binary file]


================================================
FILE: assets/images/perf-testing/insights.PNG
================================================
[Binary file]


================================================
FILE: assets/images/ui-state/devtools-network.PNG
================================================
[Binary file]


================================================
FILE: sections/draft.md
================================================
The _Topics list_ could be summarized in the next chapters

- typescrtipt in tests: pros and cons
- importance of assertions speakingness and having a lot of assertions in UI tests
- exporting constants from the code and import in the tests
- base tests on contents
- visual regression test
- add more component testing articles (@makbeth has TestCafÃ©+Storybook tests, re-try cypress-react-unit-test running `npm run component` on [this repo](https://github.com/cypress-io/cypress-example-todomvc-redux)) and improve the whole section. Update "Component tests vs (UI) Integration tests vs E2E tests" speaking about E2E tools + Storybook



================================================
FILE: sections/template.md
================================================
# Title here

<br/><br/>

### One Paragraph Explainer

Text

<br/><br/>

### Code Example â€“ explanation

```javascript
code here
```

<br/><br/>

### Code Example â€“ another

```javascript
code here
```

<br/><br/>

### Blog Quote: "Title"

 From the blog, pouchdb.com ranked 11 for the keywords â€œNode Promisesâ€

 > â€¦text here

<br/><br/>

 ### Example: Complex methods analysis with CodeClimate (commercial)

![alt text](https://github.com/i0natan/nodebestpractices/blob/master/assets/images/codeanalysis-climate-complex-methods.PNG "Complex methods analysis")

### Example: Code analysis trends and history with CodeClimate (commercial)

![alt text](https://github.com/i0natan/nodebestpractices/blob/master/assets/images/codeanalysis-climate-history.PNG "Code analysis history")

### Example: Code analysis summary and trends with SonarQube (commercial)

![alt text](https://github.com/i0natan/nodebestpractices/blob/master/assets/images/codeanalysis-sonarqube-dashboard.PNG "Code analysis history")


<br/><br/>



================================================
FILE: sections/advanced/combinatorial-testing.md
================================================
# Combinatorial Testing

<br/><br/>

### One Paragraph Explainer

* [Combinatorial Testing](http://csrc.nist.gov/Projects/automated-combinatorial-testing-for-software) is a proven method for more effective software testing at a lower cost.
* The key insight underlying this form of testing is that not every parameter contributes to every failure and most failures are caused by interactions between relatively few parameters.
* Testing parameter combinations can provide more efficient fault detection than conventional methods.


A series of studies by [NIST](https://www.nist.gov/) from 1999 to 2004 showed that most software bugs and failures are caused by one or two parameters, with
progressively fewer by three or more. This finding, referred to as the Interaction Rule, has important implications for software testing because it means that testing parameter combinations can provide more efficient fault detection than conventional methods. The data gathered by NIST and others suggest that software failures are triggered by only a few variables interacting (six or fewer). Pairwise (2-way combinations) testing is sometimes used to obtain reasonably good results at low cost, generally not less than 60% fault coverage, but this may not be sufficient for mission-critical software.

<br/><br/>

### (1) Code Example â€“ product owner question

A product owner once asked:
> "From a best practice standpoint or maybe a practical standpoint, are you supposed to test a system in every possible configuration?
For example, say you have features A, B, C, D, E and customer 1 has features A/B, customer 2 has A/B/C, and customer 3 has A/D, customer 4 has B/D, and customer 5 has A/B/C/D/E....
Are you supposed to test every possible combination of features or do you test each of the individual features and if they work independently you trust them to work as a whole?"


5 customers and 5 features. This would be 25 tests exhaustively.
With the constraints described, it would be 14 tests.
For the purpose of having a code sample, we will use a [CTWedge](https://foselab.unibg.it/ctwedge/) scripted combinatorial model of the described spec. There are many other CT tools listed at [pairwise.org](http://pairwise.org/). Some of the other tools we (at Siemens) have used are [ACTs](https://csrc.nist.gov/projects/automated-combinatorial-testing-for-software) and [CAgen](https://matris.sba-research.org/tools/cagen/#/workspaces).

```
Model POquestion
 Parameters:
   features : {A, B, C, D, E}
   customer:  {1, 2, 3, 4, 5}

 Constraints:
   # customer = 1 => features = A || features = B #
   # customer = 2 => features = A || features = B || features = C #
   # customer = 3 => features = A || features = D #
   # customer = 4 => features = B || features = D #
   # customer = 5 => features = A || features = B || features = C || features = D || features = E #
```

Paste the script in here to generate results [here](http://foselab.unibg.it/ctwedge/).

The goal is to test 2-way (or more) interactions between parameters. When you have only 2 parameters, there is not much profit, because it is exhaustive.

If you have more than 2 parameters, 2-way interaction coverage between them will guarantee to find 60-99% of all possible defects that can arise from that area. 3-way 90%, 4-way 95% , 5-way 97%, 6-way guarantees 100%.

![Combinatorial testing graph](../../assets/images/combinatorial-testing/ct-graph.PNG)

In this example you would profit from adding another *parameter*. Let us name it `configuration` and assume 5 possible configurations / *parameter values*. This would make the exhaustive suite of 125 tests.

```
Model POquestion
 Parameters:
   features : {A, B, C, D, E}
   customer:  {1, 2, 3, 4, 5}
   configuration: {config1, config2, config3, config4, config5}

 Constraints:
   # customer = 1 => features = A || features = B #
   # customer = 2 => features = A || features = B || features = C #
   # customer = 3 => features = A || features = D #
   # customer = 4 => features = B || features = D #
   # customer = 5 => features = A || features = B || features = C || features = D || features = E #
```

Pasting to [CTWedge](https://foselab.unibg.it/ctwedge/) this gives a test suite with 31 tests. If you add some constraints, saying some feature is not supposed to work with some config, you can even lean it further.

Mind that modeling Combinatorial Testing can and does incorporate equivalence partitions, boundary value analysis and other techniques. The more accurate the model is, the higher fault-detecting capabilities the test suite will have.


<br/><br/>

### (2) Code Example â€“ NASA Switchboard with 34 switches

Consider an example of 34 switches at NASA, each switch can be on or off.
There are 17 billion ways to cover the entirety of exhaustive tests.

![](../../assets/images/combinatorial-testing/nasa-switches.PNG)

You do not need to test all 2^34. Modeling with Combinatorial Testing you can make a calculated decision, depending on risk

```
Model NASAswitches

Parameters:
    switch1: Boolean
    switch2: Boolean
    switch3: Boolean
    switch4: Boolean
    switch5: Boolean
    switch6: Boolean
    switch7: Boolean
    switch8: Boolean
    switch9: Boolean
    switch10: Boolean
    switch11: Boolean
    switch12: Boolean
    switch13: Boolean
    switch14: Boolean
    switch15: Boolean
    switch16: Boolean
    switch17: Boolean
    switch18: Boolean
    switch19: Boolean
    switch20: Boolean
    switch21: Boolean
    switch22: Boolean
    switch23: Boolean
    switch24: Boolean
    switch25: Boolean
    switch26: Boolean
    switch27: Boolean
    switch28: Boolean
    switch29: Boolean
    switch30: Boolean
    switch31: Boolean
    switch32: Boolean
    switch33: Boolean
    switch34: Boolean
```
Switch the number of interactions to test using the dropdown in [CTWedge](https://foselab.unibg.it/ctwedge/).
* 14tests : failures from 2-way interactions between switches - will find 60-99% of all possible failures depending on product
* 33tests : failures from 3-way interactions between switches - will find 90-99% of all possible failures depending on product
* 85 tests : failures from 4-way interactions between switches - will find 95-99% of all possible failures depending on product
* 220 tests: failures from 5-way interactions between switches - will find above 99% of all possible failures
* 538 tests: failures from 6-way interactions between switches - will find 100% of all possible failures

<br/><br/>

### (2) Code Example - [Siemens Building Operator CI configuration](https://cypress.slides.com/cypress-io/siemens-case-study#/16)

Refer to the slides link above or the [webcast](https://www.youtube.com/watch?v=aMPkaLOpyns&t=1624s) for a detailed explanation on how to measure combinatorial coverage with [CAMetrics](https://matris.sba-research.org/tools/cametrics/#/new). Essentially, you generate a CSV file with any Combinatorial Testing tool and drag&drop it to CAMetrics. After that, CAMetrics can give you various combinatorial coverage reports.

> Mind that it is trivial to [convert csv to JSON](https://www.csvjson.com/csv2json), then use the JSON file for data-driven testing in any test framework of choice.

```
Model CI
 Parameters:
   deployment_UI : { branch, development, staging }
   deployment_API:  { development, staging }
   spec_suite: { ui_services_stubbed, ui_services, ui_services_hardware, spot_check}
   browser: { chrome, electron, firefox }

 Constraints:
   // one extra constraint for firefox spot checks
   # browser=firefox <=> spec_suite=spot_check #
   // on staging, run all tests
   # spec_suite=ui_services_hardware <=> deployment_API=staging #
   // match dev vs dev, staging vs staging, and when on staging use Chrome
   # deployment_UI=development => deployment_API=development #
   # deployment_UI=staging => deployment_API=staging #
   # deployment_UI=staging && deployment_API=staging => browser=chrome #
   // when on branch, stub the services
   # deployment_UI=branch => spec_suite=ui_services_stubbed #
   // do not stub the services when on UI development
   # deployment_UI=development => spec_suite!=ui_services_stubbed #
```

## References & Further reading

[Automated Combinatorial Testing for Software](https://csrc.nist.gov/Projects/automated-combinatorial-testing-for-software)

[Slides 16-50 : Utilization of Automation and Combinatorial Disciplines In Aid of Exploratory Testing](https://prezi.com/tpffqit1yn87/utilization-of-automation-and-combinatorial-disciplines-in-aid-of-exploratory-testing/)

[Applications of Practical Combinatorial Testing Methods at Siemens Industry Inc., Building Technologies Division](https://ieeexplore.ieee.org/document/7899057?section=abstract)

[An Industrial Study on Applications of Combinatorial Testing in Modern Web Development](https://ieeexplore.ieee.org/document/8728910)

[Introducing Combinatorial Testing In a Large Organization](https://ieeexplore.ieee.org/document/7085645/)

[Input Parameter Modeling for Combination Strategies](http://barbie.uta.edu/~mehra/1%20INPUT%20PARAMETER%20MODELING%20FOR%20COMBINATION%20STRATEGIES.pdf)

[Common Patterns in Combinatorial Models](http://barbie.uta.edu/~mehra/62_Common%20Patterns%20in%20Combinatorial%20Models.pdf)

[Efficient Verification of Equivalence Classes and Simultaneous Testing Using Two-layer Covering Arrays](https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=917899)



================================================
FILE: sections/advanced/combinatorial-testing.zh.md
================================================
# ç»„åˆæµ‹è¯•

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

* [ç»„åˆæµ‹è¯•](http://csrc.nist.gov/Projects/automated-combinatorial-testing-for-software) æ˜¯ä¸€ç§ç»è¿‡éªŒè¯çš„ã€æˆæœ¬è¾ƒä½çš„ã€æ›´ä¸ºæœ‰æ•ˆçš„è½¯ä»¶æµ‹è¯•æ–¹æ³•ã€‚
* è¿™ç§æµ‹è¯•çš„å…³é”®æ€æƒ³æ˜¯ï¼Œå¹¶éæ¯ä¸ªå‚æ•°éƒ½å¯¹æ¯æ¬¡æ•…éšœéƒ½æœ‰å½±å“ï¼Œè€Œæ˜¯å¤§å¤šæ•°æ•…éšœæ˜¯ç”±ç›¸å¯¹è¾ƒå°‘çš„å‚æ•°ä¹‹é—´çš„ç›¸äº’ä½œç”¨å¼•èµ·çš„ã€‚
* ä¸ä¼ ç»Ÿæ–¹æ³•ç›¸æ¯”ï¼Œæµ‹è¯•å‚æ•°ç»„åˆå¯ä»¥æ›´æœ‰æ•ˆåœ°æ£€æµ‹æ•…éšœã€‚

ç¾å›½å›½å®¶æ ‡å‡†ä¸æŠ€æœ¯ç ”ç©¶é™¢[NIST](https://www.nist.gov/) åœ¨ 1999 å¹´åˆ° 2004 å¹´è¿›è¡Œçš„ä¸€ç³»åˆ—ç ”ç©¶è¡¨æ˜ï¼Œå¤§å¤šæ•°è½¯ä»¶ç¼ºé™·å’Œæ•…éšœæ˜¯ç”±ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‚æ•°å¼•èµ·çš„ï¼Œé€æ¸å‡å°‘åˆ°ç”±ä¸‰ä¸ªæˆ–æ›´å¤šå‚æ•°å¼•èµ·çš„ã€‚è¿™ä¸€å‘ç°è¢«ç§°ä¸ºâ€œäº¤äº’è§„åˆ™â€ï¼Œå¯¹è½¯ä»¶æµ‹è¯•å…·æœ‰é‡è¦æ„ä¹‰ï¼Œå› ä¸ºè¿™æ„å‘³ç€æµ‹è¯•å‚æ•°ç»„åˆå¯ä»¥æ¯”ä¼ ç»Ÿæ–¹æ³•æ›´æœ‰æ•ˆåœ°æ£€æµ‹æ•…éšœã€‚NIST å’Œå…¶ä»–æœºæ„æ”¶é›†çš„æ•°æ®è¡¨æ˜ï¼Œè½¯ä»¶æ•…éšœä»…ç”±å°‘æ•°å‡ ä¸ªå˜é‡çš„ç›¸äº’ä½œç”¨å¼•å‘ï¼ˆä¸è¶…è¿‡å…­ä¸ªï¼‰ã€‚æœ‰æ—¶ä½¿ç”¨æˆå¯¹ï¼ˆ2 è·¯ç»„åˆï¼‰æµ‹è¯•å¯ä»¥ä»¥è¾ƒä½çš„æˆæœ¬è·å¾—ç›¸å½“ä¸é”™çš„ç»“æœï¼Œé€šå¸¸ä¸ä½äº 60% çš„æ•…éšœè¦†ç›–ç‡ï¼Œä½†è¿™å¯èƒ½å¯¹äºå…³é”®ä»»åŠ¡çš„è½¯ä»¶æ¥è¯´å¯èƒ½ä¸è¶³å¤Ÿã€‚

<br/><br/>

## (1) ä»£ç ç¤ºä¾‹ â€“ äº§å“è´Ÿè´£äººé—®é¢˜

ä¸€ä½äº§å“è´Ÿè´£äººæ›¾æå‡ºä¸€ä¸ªé—®é¢˜ï¼š
> "ä»æœ€ä½³å®è·µæˆ–å®é™…è§’åº¦æ¥çœ‹ï¼Œä½ æ˜¯å¦åº”è¯¥åœ¨æ¯ç§å¯èƒ½çš„é…ç½®ä¸‹æµ‹è¯•ç³»ç»Ÿï¼Ÿ
ä¾‹å¦‚ï¼Œå‡è®¾ä½ æœ‰ Aã€Bã€Cã€Dã€E äº”ä¸ªåŠŸèƒ½ï¼Œå®¢æˆ· 1 æ‹¥æœ‰ A/Bï¼Œå®¢æˆ· 2 æ‹¥æœ‰ A/B/Cï¼Œå®¢æˆ· 3 æ‹¥æœ‰ A/Dï¼Œå®¢æˆ· 4 æ‹¥æœ‰ B/Dï¼Œå®¢æˆ· 5 æ‹¥æœ‰ A/B/C/D/E....
ä½ æ˜¯å¦åº”è¯¥æµ‹è¯•æ¯ç§å¯èƒ½çš„åŠŸèƒ½ç»„åˆï¼Œè¿˜æ˜¯æµ‹è¯•æ¯ä¸ªåŠŸèƒ½å•ç‹¬ï¼Œå¦‚æœå®ƒä»¬åœ¨ç‹¬ç«‹æµ‹è¯•ä¸­èƒ½å¤Ÿæ­£å¸¸å·¥ä½œï¼Œå°±ç›¸ä¿¡å®ƒä»¬æ•´ä½“ä¸Šä¹Ÿèƒ½æ­£å¸¸å·¥ä½œï¼Ÿ"

5 ä¸ªå®¢æˆ·å’Œ 5 ä¸ªåŠŸèƒ½ï¼Œè¯¦å°½æ— é—å°†éœ€è¦ 25 ä¸ªæµ‹è¯•ã€‚
åœ¨æè¿°çš„çº¦æŸæ¡ä»¶ä¸‹ï¼Œåªéœ€è¦ 14 ä¸ªæµ‹è¯•ã€‚
ä¸ºäº†æä¾›ä¸€ä¸ªä»£ç ç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æè¿°è§„æ ¼çš„[CTWedge](https://foselab.unibg.it/ctwedge/)è„šæœ¬åŒ–ç»„åˆæ¨¡å‹ã€‚è¿˜æœ‰è®¸å¤šå…¶ä»–åˆ—åœ¨[pairwise.org](http://pairwise.org/)ä¸Šçš„ CT å·¥å…·ã€‚æˆ‘ä»¬ï¼ˆåœ¨è¥¿é—¨å­ï¼‰ä½¿ç”¨è¿‡çš„å…¶ä»–ä¸€äº›å·¥å…·åŒ…æ‹¬[ACTs](https://csrc.nist.gov/projects/automated-combinatorial-testing-for-software)å’Œ[CAgen](https://matris.sba-research.org/tools/cagen/#/workspaces)ã€‚

```
Model POquestion
 Parameters:
   features : {A, B, C, D, E}
   customer:  {1, 2, 3, 4, 5}

 Constraints:
   # customer = 1 => features = A || features = B #
   # customer = 2 => features = A || features = B || features = C #
   # customer = 3 => features = A || features = D #
   # customer = 4 => features = B || features = D #
   # customer = 5 => features = A || features = B || features = C || features = D || features = E #
```

åœ¨è¿™é‡Œç²˜è´´è„šæœ¬ä»¥ç”Ÿæˆç»“æœ [è¿™é‡Œ](http://foselab.unibg.it/ctwedge/)ã€‚

æµ‹è¯•çš„ç›®æ ‡æ˜¯æ£€éªŒå‚æ•°ä¹‹é—´çš„åŒå‘ï¼ˆæˆ–æ›´å¤šï¼‰ç›¸äº’ä½œç”¨ã€‚å½“åªæœ‰ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œæ”¶ç›Šå¹¶ä¸å¤ªæ˜æ˜¾ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ç§ç©·ä¸¾çš„æ–¹æ³•ã€‚

å¦‚æœå‚æ•°æ•°é‡è¶…è¿‡ä¸¤ä¸ªï¼Œå¯¹å®ƒä»¬ä¹‹é—´çš„åŒå‘äº¤äº’è¿›è¡Œè¦†ç›–å°†ç¡®ä¿æ‰¾åˆ°è¯¥é¢†åŸŸå¯èƒ½å­˜åœ¨çš„ 60-99% çš„æ‰€æœ‰æ½œåœ¨ç¼ºé™·ã€‚ä¸‰å‘äº¤äº’ä¸º 90%ï¼Œå››å‘ä¸º 95%ï¼Œäº”å‘ä¸º 97%ï¼Œå…­å‘ä¸º 100%ã€‚

![ç»„åˆæµ‹è¯•å›¾](../../assets/images/combinatorial-testing/ct-graph.PNG)

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé€šè¿‡æ·»åŠ å¦ä¸€ä¸ª*å‚æ•°*ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º `configuration`ï¼Œå¹¶å‡è®¾æœ‰ 5 ç§å¯èƒ½çš„é…ç½® / *å‚æ•°å€¼*ã€‚è¿™å°†ç”Ÿæˆä¸€ä¸ªåŒ…å« 125 ä¸ªæµ‹è¯•çš„è¯¦å°½å¥—ä»¶ã€‚

```Text
Model POquestion
 Parameters:
   features : {A, B, C, D, E}
   customer:  {1, 2, 3, 4, 5}
   configuration: {config1, config2, config3, config4, config5}

 Constraints:
   # customer = 1 => features = A || features = B #
   # customer = 2 => features = A || features = B || features = C #
   # customer = 3 => features = A || features = D #
   # customer = 4 => features = B || features = D #
   # customer = 5 => features = A || features = B || features = C || features = D || features = E #
```

å°†å…¶ç²˜è´´åˆ° [CTWedge](https://foselab.unibg.it/ctwedge/) ä¸Šï¼Œè¿™å°†ç”Ÿæˆä¸€ä¸ªåŒ…å« 31 ä¸ªæµ‹è¯•çš„æµ‹è¯•å¥—ä»¶ã€‚å¦‚æœæ·»åŠ ä¸€äº›çº¦æŸï¼Œè¡¨æ˜æŸäº›ç‰¹æ€§ä¸åº”è¯¥ä¸æŸäº›é…ç½®ä¸€èµ·å·¥ä½œï¼Œç”šè‡³å¯ä»¥è¿›ä¸€æ­¥ç²¾ç®€ã€‚

è¯·æ³¨æ„ï¼Œç»„åˆæµ‹è¯•çš„å»ºæ¨¡å¯ä»¥å¹¶ä¸”ç¡®å®åŒ…å«ç­‰ä»·åˆ†åŒºã€è¾¹ç•Œå€¼åˆ†æå’Œå…¶ä»–æŠ€æœ¯ã€‚æ¨¡å‹è¶Šå‡†ç¡®ï¼Œæµ‹è¯•å¥—ä»¶çš„æ•…éšœæ£€æµ‹èƒ½åŠ›å°±è¶Šå¼ºã€‚

<br/><br/>

## (2) ä»£ç ç¤ºä¾‹ â€“ NASA çš„å¼€å…³æ¿å…±æœ‰ 34 ä¸ªå¼€å…³

ä»¥ NASA çš„ä¸€ä¸ªä¾‹å­ä¸ºå‚è€ƒï¼Œæœ‰ 34 ä¸ªå¼€å…³ï¼Œæ¯ä¸ªå¼€å…³å¯ä»¥å¤„äºæ‰“å¼€æˆ–å…³é—­çš„çŠ¶æ€ã€‚è¦è¿›è¡Œè¯¦å°½çš„æµ‹è¯•ï¼Œæœ‰ 170 äº¿ç§å¯èƒ½çš„ç»„åˆæ–¹å¼ã€‚

![ ](../../assets/images/combinatorial-testing/nasa-switches.PNG)

ä¸å¿…æµ‹è¯•æ‰€æœ‰çš„ 2^34 ç§å¯èƒ½æ€§ã€‚é€šè¿‡ä½¿ç”¨ç»„åˆæµ‹è¯•è¿›è¡Œå»ºæ¨¡ï¼Œä½ å¯ä»¥æ ¹æ®é£é™©åšå‡ºç»è¿‡è®¡ç®—çš„å†³ç­–ã€‚

```text
Model NASAswitches

Parameters:
    switch1: Boolean
    switch2: Boolean
    switch3: Boolean
    switch4: Boolean
    switch5: Boolean
    switch6: Boolean
    switch7: Boolean
    switch8: Boolean
    switch9: Boolean
    switch10: Boolean
    switch11: Boolean
    switch12: Boolean
    switch13: Boolean
    switch14: Boolean
    switch15: Boolean
    switch16: Boolean
    switch17: Boolean
    switch18: Boolean
    switch19: Boolean
    switch20: Boolean
    switch21: Boolean
    switch22: Boolean
    switch23: Boolean
    switch24: Boolean
    switch25: Boolean
    switch26: Boolean
    switch27: Boolean
    switch28: Boolean
    switch29: Boolean
    switch30: Boolean
    switch31: Boolean
    switch32: Boolean
    switch33: Boolean
    switch34: Boolean
```

åœ¨ [CTWedge](https://foselab.unibg.it/ctwedge/) ä¸­é€šè¿‡ä¸‹æ‹‰èœå•å¼€å…³æµ‹è¯•çš„ç›¸äº’ä½œç”¨æ¬¡æ•°ã€‚

* 14 æ¬¡æµ‹è¯•ï¼šé€šè¿‡å¼€å…³ä¹‹é—´çš„ 2 æ¬¡ç›¸äº’ä½œç”¨å¼•èµ·çš„æ•…éšœ - å¯æ ¹æ®äº§å“æ‰¾åˆ° 60-99% çš„æ‰€æœ‰æ½œåœ¨æ•…éšœ
* 33 æ¬¡æµ‹è¯•ï¼šé€šè¿‡å¼€å…³ä¹‹é—´çš„ 3 æ¬¡ç›¸äº’ä½œç”¨å¼•èµ·çš„æ•…éšœ - å¯æ ¹æ®äº§å“æ‰¾åˆ° 90-99% çš„æ‰€æœ‰æ½œåœ¨æ•…éšœ
* 85 æ¬¡æµ‹è¯•ï¼šé€šè¿‡å¼€å…³ä¹‹é—´çš„ 4 æ¬¡ç›¸äº’ä½œç”¨å¼•èµ·çš„æ•…éšœ - å¯æ ¹æ®äº§å“æ‰¾åˆ° 95-99% çš„æ‰€æœ‰æ½œåœ¨æ•…éšœ
* 220 æ¬¡æµ‹è¯•ï¼šé€šè¿‡å¼€å…³ä¹‹é—´çš„ 5 æ¬¡ç›¸äº’ä½œç”¨å¼•èµ·çš„æ•…éšœ - å¯æ‰¾åˆ°è¶…è¿‡ 99% çš„æ‰€æœ‰æ½œåœ¨æ•…éšœ
* 538 æ¬¡æµ‹è¯•ï¼šé€šè¿‡å¼€å…³ä¹‹é—´çš„ 6 æ¬¡ç›¸äº’ä½œç”¨å¼•èµ·çš„æ•…éšœ - å¯æ‰¾åˆ°æ‰€æœ‰æ½œåœ¨æ•…éšœçš„ 100%

<br/><br/>

## (2) ä»£ç ç¤ºä¾‹ - [è¥¿é—¨å­æ¥¼å®‡æ“ä½œå‘˜ CI é…ç½®](https://cypress.slides.com/cypress-io/siemens-case-study#/16)

å‚è€ƒä¸Šé¢çš„å¹»ç¯ç‰‡é“¾æ¥æˆ–[ç›´æ’­è§†é¢‘](https://www.youtube.com/watch?v=aMPkaLOpyns&t=1624s)ä»¥è·å–æœ‰å…³å¦‚ä½•ä½¿ç”¨[CAMetrics](https://matris.sba-research.org/tools/cametrics/#/new)æµ‹é‡ç»„åˆè¦†ç›–ç‡çš„è¯¦ç»†è¯´æ˜ã€‚åŸºæœ¬ä¸Šï¼Œä½ å¯ä»¥ä½¿ç”¨ä»»ä½•ç»„åˆæµ‹è¯•å·¥å…·ç”Ÿæˆä¸€ä¸ª CSV æ–‡ä»¶ï¼Œç„¶åå°†å…¶æ‹–æ”¾åˆ° CAMetrics ä¸­ã€‚ä¹‹åï¼ŒCAMetrics å¯ä»¥ä¸ºä½ æä¾›å„ç§ç»„åˆè¦†ç›–ç‡æŠ¥å‘Šã€‚

> è¯·æ³¨æ„ï¼Œå°† [CSV è½¬æ¢ä¸º JSON](https://www.csvjson.com/csv2json) éå¸¸ç®€å•ï¼Œç„¶åå¯ä»¥ä½¿ç”¨ JSON æ–‡ä»¶åœ¨æ‰€é€‰çš„ä»»ä½•æµ‹è¯•æ¡†æ¶ä¸­è¿›è¡Œæ•°æ®é©±åŠ¨æµ‹è¯•ã€‚

```text
Model CI
 Parameters:
   deployment_UI : { branch, development, staging }
   deployment_API:  { development, staging }
   spec_suite: { ui_services_stubbed, ui_services, ui_services_hardware, spot_check}
   browser: { chrome, electron, firefox }

 Constraints:
   // one extra constraint for firefox spot checks
   # browser=firefox <=> spec_suite=spot_check #
   // on staging, run all tests
   # spec_suite=ui_services_hardware <=> deployment_API=staging #
   // match dev vs dev, staging vs staging, and when on staging use Chrome
   # deployment_UI=development => deployment_API=development #
   # deployment_UI=staging => deployment_API=staging #
   # deployment_UI=staging && deployment_API=staging => browser=chrome #
   // when on branch, stub the services
   # deployment_UI=branch => spec_suite=ui_services_stubbed #
   // do not stub the services when on UI development
   # deployment_UI=development => spec_suite!=ui_services_stubbed #
```

## å‚è€ƒèµ„æ–™å’Œå»¶ä¼¸é˜…è¯»

[è‡ªåŠ¨åŒ–ç»„åˆæµ‹è¯•è½¯ä»¶](https://csrc.nist.gov/Projects/automated-combinatorial-testing-for-software)

[å¹»ç¯ç‰‡ 16-50ï¼šæ¢è®¨è‡ªåŠ¨åŒ–å’Œç»„åˆçºªå¾‹åœ¨è¾…åŠ©æ¢ç´¢æ€§æµ‹è¯•æ–¹é¢çš„åº”ç”¨](https://prezi.com/tpffqit1yn87/utilization-of-automation-and-combinatorial-disciplines-in-aid-of-exploratory-testing/)

[è¥¿é—¨å­å·¥ä¸šå…¬å¸å»ºç­‘æŠ€æœ¯éƒ¨å®é™…ç»„åˆæµ‹è¯•æ–¹æ³•çš„åº”ç”¨](https://ieeexplore.ieee.org/document/7899057?section=abstract)

[ç°ä»£ Web å¼€å‘ä¸­ç»„åˆæµ‹è¯•çš„å·¥ä¸šç ”ç©¶](https://ieeexplore.ieee.org/document/8728910)

[åœ¨å¤§å‹ç»„ç»‡ä¸­å¼•å…¥ç»„åˆæµ‹è¯•](https://ieeexplore.ieee.org/document/7085645/)

[ç»„åˆç­–ç•¥çš„è¾“å…¥å‚æ•°å»ºæ¨¡](http://barbie.uta.edu/~mehra/1%20INPUT%20PARAMETER%20MODELING%20FOR%20COMBINATION%20STRATEGIES.pdf)

[ç»„åˆæ¨¡å‹ä¸­çš„å¸¸è§æ¨¡å¼](http://barbie.uta.edu/~mehra/62_Common%20Patterns%20in%20Combinatorial%20Models.pdf)

[ç­‰æ•ˆç±»å’Œä¸¤å±‚è¦†ç›–é˜µçš„é«˜æ•ˆéªŒè¯å’ŒåŒæ—¶æµ‹è¯•](https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=917899)



================================================
FILE: sections/advanced/email-testing.md
================================================
# Email Testing

<br/><br/>

### One Paragraph Explainer

Email testing is [critical for business success](https://www.industrialmarketer.com/why-email-testing-is-critical-for-email-marketing-success/) and [boosts email performance](https://litmus.com/blog/3-reasons-why-email-testing-boosts-email-performance).
It is not something we want to forego while testing our web applications because modern email services allow painless automated email testing.
Typically email testing involves validating email fields (from, to, cc, bcc, subject, attachments), HTML content and links in the email. Email services also allow spam checks and visual checks.
The core goal is to enable the last mile of end to end testing, to enable a typical web app to be tested from start to finish.

For example imagine a scenario where a user starts having received an email invite from an organization, through company proprietary services or third party such as LinkedIn invitations.
Then, the user verifies email content, accepts the invite, and joins the organization.
Later, the user can leave the organization - or get removed by an administrator - then receives another email notification.
Using an email service, the entirety of this requirement is possible to automate and execute within seconds.

That being stated, email testing is a fundamental enabler for SaaS test architectures by permitting stateless tests that can scale; tests that independently handle their state and can be executed by _n_ number of entities at the same time.
Check out the topic [**Test States**](./sections/advanced/test-states.md) for further discussion on the topic.

<br/><br/>

## Foreword

If you are using [Gmail tricks](https://www.idownloadblog.com/2018/12/19/gmail-email-address-tricks/) or [AWS Simple Email Service](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator.html) and these use cases are satisfactory for your test needs without any side effects, only [topic 1](#topic-1) might be of interest to you.

There are plenty of [email testing solutions](https://www.g2.com/search/products?max=10&query=email+testing) available, and combinations of test frameworks that integrate with them.
For the code snippets and working examples, we will be using [Cypress](https://www.cypress.io/) and [Mailosaur](https://mailosaur.com/), but the ideas should generally apply to any tuple of email services and test automation frameworks.

When using Cypress with Mailosaur, there are 3 test-development approaches:

- Implement [Mailosaur API](https://docs.mailosaur.com/reference) using Cypress API testing capabilities using [`cy.request()`](https://docs.cypress.io/api/commands/request.html#Syntax) or [`cy.api()`](https://github.com/bahmutov/cy-api). Utilize plugins and helper utilities to construct test suites.

- Utilize [Mailosaur's Node package](https://www.npmjs.com/package/mailosaur) and implement them using [`cy.task()`](https://docs.cypress.io/api/commands/task.html#Syntax) which allows running node within Cypress.

- Use the [Cypress Mailosaur plugin](https://www.npmjs.com/package/cypress-mailosaur) and abstract away all the complexity!

> Check out [cypress-mailosaur-recipe](https://github.com/muratkeremozcan/cypressExamples/tree/master/cypress-mailosaur) for a working example with these approaches. Note that you will have to start a new Mailosaur trial account and replace environment variables for yourself.

<br/><br/>

## (1) Explanation & Code sample - Enabling stateless, scalable tests <a id="topic-1"></a>

Stateless tests that can scale are a necessity in any modern web application testing. We want tests that independently handle their state and tests that can be executed by _n_ number of entities at the same time.

While testing SaaS applications, which generically have Subscriptions, Users, Organizations (ex: [Slack](https://slack.com/intl/en-sk/help/articles/115004071768-What-is-Slack-#your-team-in-slack), [Cypress Dashboard Service](https://dashboard.cypress.io/organizations), etc.) a lot of the end to end workflows can rely on having unique users. Elsewise only one test execution can happen at a time and they clash with other simultaneous test executions.
This constraint reduces test automation to cron jobs or manually triggered CI.

Some ways to address unique users is by utilizing [Gmail tricks](https://www.idownloadblog.com/2018/12/19/gmail-email-address-tricks/) or [AWS Simple Email Service](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator.html). It is possible that you do not have to check actual email content (from, to, cc, bcc, subject, attachments etc.) and only want to have unique users, then you are on the right path with stateless tests.
However, these approaches can still be problematic; for example, non-existing emails can prompt bouncing emails to your cloud service and that can be a headache. If you want to avoid such issues and check real email content in automation, email services provide value.

Email services can also provide cost savings in test execution time by receiving emails faster, tests running quicker in the pipeline with less CI resources being consumed and less time waiting for tests to finish. If you are running 1000 pipelines a year, and save 3-4 seconds per pipeline execution, the email service can be already paying for its annual subscription just by providing extra speed.

### Achieving Stateless tests with unique emails

If in every test execution a new, unique user was used and the emails to this unique user could be verified in isolation, it would be possible to achieve a stateless test. The only side effect would be to the email service inbox, but if the test only checked emails by reference and cleaned up after itself, the email service mailbox would not be impacted.

This is easy to achieve with Mailosaur, here are two approaches to this: [Mailosaur's Node package](https://www.npmjs.com/package/mailosaur) or our own util with `faker.js`.

```javascript
// at cypress/plugins/mailosaur-tasks.js

// generates a random email address
// sample output:   ojh788.<serverId>@mailosaur.io
const createEmail = () => mailosaurClient
  .servers
  .generateEmailAddress(envVars.MAILOSAUR_SERVERID);
);

// our custom function at a helper file or commands file. The only difference is the defined prefixed name.
// sample output:  fakerJsName.<serverId>@mailosaur.io
const createMailosaurEmail = randomName =>
  `${randomName}.${Cypress.env('MAILOSAUR_SERVERID')}@mailosaur.io`;
```

<br/><br/>

## (2) Explanation - what to test in an email and how

First, let's elaborate on the setup we need.

### Test Setup and Hybrid Approach: [Mailosaur Rest API](https://docs.mailosaur.com/reference) with `cy.request()` and [Mailosaur's Node package](https://www.npmjs.com/package/mailosaur) with `cy.task()`

Mailosaur provides an [npm package](https://www.npmjs.com/package/mailosaur) and effectively all the Node code samples in the [API documentation](https://docs.mailosaur.com/reference) can be converted to `cy.task()`. Another approach is to implement Mailosaur's Rest API 'from scratch with `cy.request()`.

> Mailosaur released  [Cypress Mailosaur plugin](https://www.npmjs.com/package/cypress-mailosaur) mid 2020, and it abstracts away all the complexity with these 2 approaches. Skip to the end to see code samples and comparison.

### Environment variables

We recommend these values as environment variables. You can grab them from Mailosaur web application by creating a free trial account using any email. The trial account lasts for two weeks.

```json
  "MAILOSAUR_SERVERID": "******",
  "MAILOSAUR_PASSWORD": "******",
  "MAILOSAUR_API_KEY": "*******",
  "MAILOSAUR_API": "https://mailosaur.com/api",
  "MAILOSAUR_SERVERNAME": "user-configurable-server-name"
```

### Modularizing `cy.task()`

You can put all utilities in `cypress/plugins/index.js` file like in [this example](https://github.com/muratkeremozcan/cypressExamples/blob/master/cypress-mailosaur/cypress/plugins/index.js). A neater approach is putting all Mailosaur related tasks in its own module and importing them to the plugins file.

```javascript
// cypress/plugins/index.js

const task = require('some-plugin/task')
const percyHealthCheck = require('@percy/cypress/task') // or any other plugin you may need
const mailosaurTasks = require('./mailosaur-tasks') // our mailosaur module

// This is a pattern to merge all Cypress tasks
const all = Object.assign({}, percyHealthCheck, task, mailosaurTasks)

module.exports = (on, config) => {
  on('task', all)
}

////////

// cypress/plugins/mailosaur-tasks.js (this could be anywhere)

// the npm package
const MailosaurClient = require('mailosaur')
// we used a static file for envVars. cypress.env.json file can cause issues in CI
// There can be other solutions, do your best here.
const envVars = require('../../cypress.json')
const mailosaurClient = new MailosaurClient(envVars.MAILOSAUR_API_KEY)

// replicate Mailosaur's npm code from api docs
// https://docs.mailosaur.com/docs/fetching-messages
/** finds the most recent email message to the given email*/
const findEmailToUser = async (userEmail) => {
  let message = await mailosaurClient.messages.get(
    envVars.MAILOSAUR_SERVERID,
    {
      sentTo: userEmail,
    },
    { timeout: 25000 }
  ) // time to wait for an email to arrive
  return message
}

// other useful utilities can include the below. You can replicate them using the api docs.

// checkServerName()
// createEmail()
// deleteAMessage(messageId)
// listAllMessages()

module.exports = { checkServerName, createEmail, findEmailToUser, listAllMessages, deleteAMessage }
```

### Other Useful helper functions that Mailosaur npm package does not provide _(as far as we know)_

We can harmonize Rest API / `cy.request()` approach with npm package / `cy.task()` to build our own utility.

```javascript
/** Given user email, returns the id of the email to that user. Good example of hybrid utility functions */
const getEmailId = (email) => cy.task('findEmailToUser', email).its('id')

/** Deletes 1 email message by message id. Can be useful if you want to delete the message after running the test. */
const deleteEmailById = (id) => {
  return cy.request({
    method: 'DELETE',
    url: `${Cypress.env('MAILOSAUR_API')}/messages/${id}`,
    headers: {
      // important detail
      authorization: Cypress.env('MAILOSAUR_PASSWORD'),
    },
    auth: {
      // important detail
      user: Cypress.env('MAILOSAUR_API_KEY'),
      password: '', // any pw or empty pw will do
    },
    retryOnStatusCodeFailure: true, // because we can
  })
}

/** Deletes the most recent email sent to the user. Useful for resetting state. */
export const deleteEmail = (email) => getEmailId(email).then((id) => deleteEmailById(id))
```

<br/><br/>

## (3) Code sample - what to test in an email and how

Validating email fields (from, to, cc, bcc, subject, attachments), HTML content and links in the email.

```javascript

// an invite goes out to the recipient from the sender...

// in the cypress spec file > it block...

cy.task('findEmailToUser', recipientEmail).then(emailContent => {
  cy.wrap(emailContent).its('from')..<chain as needed>.should('eq', senderEmail); // from
  cy.wrap(emailContent).its('to')..<chain as needed>.should(..)// to
  cy.wrap(emailContent).its('cc')..<chain as needed>.should(..); // cc
  cy.wrap(emailContent).its('subject')..<chain as needed>.should(..); // subject
  // similar approach with attachments.
  // You can always end with ... .then(console.log) to take a look at the content
  // of you can check out the mailosaur email as JSON content, which makes everything easier!
  // cy.wrap(emailContent).then(console.log);

  // sample utilities to check assertions
  const html = () => cy.wrap(emailContent).its('html');
  const htmlLinks = () => html().its('links');
  const images = html().its('images');

  htmlLinks().should(..); // or chain further
  images().should(..);

  // note that you can use different styles of api assertions with Cypress
  // check out api testing examples at
  // https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/blogs__e2e-api-testing
  // https://github.com/muratkeremozcan/cypressExamples/blob/master/cypress-api-testing/cypress/integration/firstTest.spec.js
});
```

## (4) The overhead is abstracted away with [Cypress Mailosaur plugin](https://www.npmjs.com/package/cypress-mailosaur)

Mailosaur team released a Cypress plugin in mid 2020. With it, we do not have to replicate any complex API utities or use cy.task via Mailosaur npm package; none of what you have seen in section (3) is necessary. There is no need to create cy.task utilities or even hyberdize them. With the Cypress Mailosaur plugin, you can just use the custom Cypress commands Mailosaur team created for us.

All we need is to install the package `npm install cypress-mailosaur --save-dev` and add the following line to cypress/support/index.js:
`import 'cypress-mailosaur'`.

Mailsaur plugin has a few handy functions which help you abtract complex needs.
A full list can be found at at https://github.com/mailosaur/cypress-mailosaur

Here is the plugin version of the above code. The usage is somewhat similar, but we did not have implement any cy.task() utilities, custom helper functions or hybrid helpers. We also get new, easy to use helper functions that work seamlessly.

You can find a working version of this code and the above at the [link](https://github.com/muratkeremozcan/cypressExamples/tree/master/cypress-mailosaur).
```javascript
it('uses the plugin to check the email content (no need for creating complex utilities with cy.task) ', function () {
    const userEmail = createEmail(internet.userName());
    cy.task('sendSimpleEmail', userEmail); // an npm package to send emails, usually your app would do this

    // a convenient helper functions to list mesages
    cy.mailosaurListMessages(Cypress.env('MAILOSAUR_SERVERID')).its('items').its('length').should('not.eq', 0);

    // this helper command replaces the complex cy.task('findEmailToUser') utility we had to create
    cy.mailosaurGetMessage(
      Cypress.env('MAILOSAUR_SERVERID'),
      { sentTo: userEmail },
      // note from Jon at Mailosaur:
      // The get method looks for messages received within the last hour
      // if looking for emails existing before that, you have to add this. Optional otherwise
      // { receivedAfter: new Date('2000-01-01') }
    ).then(emailContent => {
      // this part is the same
      cy.wrap(emailContent).its('from').its(0).its('email').should('contain', 'test@nodesendmail.com');
      cy.wrap(emailContent).its('to').its(0).its('email').should('eq', userEmail);
      cy.wrap(emailContent).its('subject').should('contain', 'MailComposer sendmail');
    });

    // alternate approach to getting message by sent to'
    cy.mailosaurGetMessagesBySentTo(Cypress.env('MAILOSAUR_SERVERID'), userEmail).then(emailItem => {
      // the response is slightly different, but you can modify it to serve the same purpose
      const emailContent = emailItem.items[0];
      cy.wrap(emailContent).its('from').its(0).its('email').should('contain', 'test@nodesendmail.com');
      cy.wrap(emailContent).its('to').its(0).its('email').should('eq', userEmail);
      cy.wrap(emailContent).its('subject').should('contain', 'MailComposer sendmail');
    });

    // an easy to use bonus utility for checking spam score
    cy.mailosaurGetMessagesBySentTo(Cypress.env('MAILOSAUR_SERVERID'), userEmail).its('items').its(0).its('id').then(messageId => {
      // does convenient spam analysis
      cy.mailosaurGetSpamAnalysis(messageId).its('score').should('eq', 0);
      // you can observe the console output with a plain "cy.mailosaurGetSpamAnalysis(messageId);  " and check for deeper assertions
    })
  });


```


================================================
FILE: sections/advanced/email-testing.zh.md
================================================
[Binary file]


================================================
FILE: sections/advanced/performance-testing.md
================================================
# Performance Testing

<br/><br/>

### One Paragraph Explainer

Although performance testing is a vast topic, as Web Developers we can quickly benefit from some of its core principles to improve user experience, satisfy functional and non-functional requirements (NFRs) and detect ambiguous system issues that may leak into production.

<br/><br/>

### (1) Ensuring user experience with Lighthouse

As web developers, our foremost concern is the user perception of performance. Thankfully, Google has made it easy and provided us with a 3rd-party authority evaluation of our web application with [Lighthouse](https://developers.google.com/web/tools/lighthouse).

> *"Lighthouse is an open-source, automated tool for improving the quality of web pages. You can run it against any web page, public or requiring authentication. It has audits for performance, accessibility, progressive web apps, SEO and more."*

For this topic, we will only focus on Performance, but you should consider also benefiting from **Progressive Web App**, **Accessibility**, **Search Engine Optimization** and **Best practices** evaluations of Lighthouse.

Getting started is easy: Chrome > DevTools > Audits > Lighthouse. Then, generate the report. It will look as such and give you precise pointers on what you can do to improve the user experience.

![Lighthouse report](../../assets/images/perf-testing/lighthouse.png)

Once the improvements are made and a baseline rating is agreed on, you can prevent regression by incorporating Lighthouse into your CI.
  * Add Lighthouse as a node_module; `npm i -D lighthouse` or `yarn add --dev lighthouse`.
  * Follow the workflow example at [Lighthouse Git repo](https://github.com/GoogleChrome/lighthouse/blob/master/docs/readme.md#using-programmatically).
  * Prevent the performance rating (and/or other ratings) from regressing upon developer commits!

#### Lighthouse with Cypress

If you are a Cypress user, with [cypress-audit](https://github.com/mfrachet/cypress-audit) you can execute Lighthouse audits in Cypress tests as well as [Pa11y](https://www.npmjs.com/package/pa11y) for automated accessibility testing. 

> In addition to the [usual plugin setup](https://github.com/mfrachet/cypress-audit#preparation), you may need to [workaround cross-origin](https://github.com/cypress-io/cypress/issues/944#issuecomment-788373384) needs of your application until Cypress has official support for it.

Here is a sample test with in-line explanations.

```typescript

// Pass in optional configuration parameters for the Cypress test:
// you may need to increase default timeout for the overall task, if you have a slow app. Mind that Lighthouse is only for Chromium based browsers
describe('Lighthouse audit ', { taskTimeout: 90000, browser: 'chrome' }, () => {
  before(() => {
    // if you are using programmatic login, you might not need to use the cy.forceVisit('/') workaround for cross-origin (linked above)
    cy.login(Cypress.env('USERNAME'), Cypress.env('PASSWORD'));
  });

  // thresholds is the first argument to cy.lighthouse(), most of the performance configuration is done here.
  // a complete list of Lighthouse parameters to use as thresholds can be found at https://github.com/mfrachet/cypress-audit/blob/master/docs/lighthouse.md
  // for an explanation of the parameters, refer to https://web.dev/lighthouse-performance/
  const thresholds = {
    'first-contentful-paint': 20000,
    'largest-contentful-paint': 35000,
    'first-meaningful-paint': 20000,
    'speed-index': 25000,
    interactive: 40000,
    performance: 5,
    accessibility: 50,
    'best-practices': 50,
    seo: 50,
    pwa: 20
  };

  // the 2nd, and optional argument to cy.lighthouse() replicates Lighthouse CLI commands https://github.com/GoogleChrome/lighthouse#cli-options
  const desktopConfig = {
    formFactor: 'desktop',
    screenEmulation: { disabled: true }
  };

  // your app may need this beforeEach and afterEach workaround for cross-origin (linked above)
  beforeEach(() => {
    cy.restoreLocalStorage();
    // Preserve Cookies between tests
    Cypress.Cookies.defaults({
      preserve: /[\s\S]*/
    });
  });

  afterEach(() => {
    cy.saveLocalStorage();
  });

  it('should pass audit for main page ', () => {
    cy.lighthouse(thresholds, desktopConfig);
  });

  it('should pass audit for another page', () => {
    cy.forceVisit('anotherUrl');
    cy.lighthouse(thresholds, desktopConfig);
  });
});

// Commands for working around cross origin, if needed

// -- Save localStorage between tests
let LOCAL_STORAGE_MEMORY = {};
Cypress.Commands.add('saveLocalStorage', () => {
  Object.keys(localStorage).forEach(key => {
    LOCAL_STORAGE_MEMORY[key] = localStorage[key];
  });
});

Cypress.Commands.add('restoreLocalStorage', () => {
  Object.keys(LOCAL_STORAGE_MEMORY).forEach(key => {
    localStorage.setItem(key, LOCAL_STORAGE_MEMORY[key]);
  });
});

// -- Visit multiple domains in one test
Cypress.Commands.add('forceVisit', url => {
  cy.window().then(win => win.open(url, '_self'));
});
```



<br/><br/>

### (2) Performance as a Non-functional Requirement and the Kano model

We can start building our understanding of performance requirements with the [Kano model](https://en.wikipedia.org/wiki/Kano_model).

> *"The Kano model is a theory for product development and customer satisfaction developed in the 1980s by Professor Noriaki Kano, which classifies customer preferences into five categories."*

At a high-level, the Kano model summarizes that performance features are standard requirements that are expected of any competitive product. This overlaps with our usage of Lighthouse; with it we ensure tha we satisfy customer preferences and that we do not regress from it.

![Kano model](../../assets/images/perf-testing/KANO_model.jpg)

At this point, we have fulfilled explicitly stated performance requirements. However, in complex applications, we need to be aware of non-functional requirements (NFRs) as well. But, what are NFRs? Below is a high-level view of them at a glance - from the double standard [ISO/IEC 25010 Product Quality Model](https://www.iso.org/standard/35733.html).

![ISO/IEC standard](../../assets/images/perf-testing/ISO_IEC_25010.jpg)

In the next section, let's focus on how NFRs can help us approach non-function performance testing.

<br/><br/>

### (3) Types of Performance Testing

For practical purposes, we can reduce non-functional performance testing into 3 categories

* Load
* Spike
* Endurance

This graph summarizes their context:

![ISO/IEC standard](../../assets/images/perf-testing/performanceTesting.jpg)

***Side note about Benchmarking and Stress Testing**: Essentially, benchmarking boils down to the step-wise approach as we get a feel for our system which becomes a part of the initial work-flow with automated tools; *"Does my system break yet? No? Let me increase it"*. Stress testing on the other hand is, in short, overdoing it.*

What is the distinction of **Scalability Testing**? It is related; the distinction is an evaluation of when exactly the system starts not responding in a satisfactory fashion. Usually, the approach with an automated tool is close enough and can be realized while analyzing graphs in a load test.

Here is a high-level picture of the intent with Scalability Testing:

![ISO/IEC standard](../../assets/images/perf-testing/scalabilityTesting.jpg)


<br/><br/>

### (4) Practical applications of Performance Testing with k6-loadImpact

There are two qualities that set [k6-loadImpact](https://docs.k6.io/docs) apart for web developers.

  * Uses JS (ES6)
  * Is built for CI

Side bonus: if you hooked on Postman, you can convert those tests to k6 easily.
K6 *can* do DOM testing, however, we believe Lighthouse takes care of that. The true power of k6 comes out when testing APIs.

You can find [quickstart examples with k6 here](https://github.com/muratkeremozcan/k6-loadImpact).
The examples start very simple and are meant to build up the understanding quickly. They are ready to be run out of the box and tinkered with. We will not duplicate that knowledge here.

Instead, in this section, we will cover the overview of a k6 test, and later show a code sample on how k6 can be configured to accommodate different types of performance testing.


```javascript
// k6 lifecycle overview:

// 1. init code -> runs once
// this is where we configure the type of performance testing (there are also
// additional options we do not cover here)
export let options = {
  // there will be 1 virtual user
  vus: 1,

  // default function() will execute 1 time. This simple config
  // is best when trying to get things to work
  iterations: 1,
}

// 2. (optional) setup code -> runs once
export function setup() {
  // for example getting a token so you can run API tests in the default
  // function that comes in (3) virtual user code

  // what gets returned from this function is passed as an argument to the next
  // function. For example: `token`
  return getTokenForUser();
}

// 3. virtual user code -> runs once or many times based on
// `export let options = { ... } `
export default function(token) {
  // http.get is a k6 function that hits a URL with optional test parameters
  // note that  we do not need a token for this url
  http.get("http://test.loadimpact.com");
}

// 4. (optional) teardown code -> runs once
export function teardown(data) {
  // this is in case you need to clean up, for instance if failed test may
  // leave residue an impact state
}
```

Endurance test configuration:
```javascript
export let options = {
  // endurance test for 30 seconds with 50 virtual users. Adds users immediately
  vus: 50,
  duration: "30s",

  // alternative to duration, you can  specify the exact number of iterations
  // the test will run
  // iterations: 500,
}
```

Load test configuration:
```javascript
export let options = {
  // for 15 seconds ramps up 10 users, adds users gradually
  // adds a total of 40 users in the next 15 seconds, and up to 50 in the next
  // 30 seconds..
  // lowers down the users to 10 and 5 in the next 15 second iterations
  stages: [
    { duration: "15s", target: 10 },
    { duration: "15s", target: 40 },
    { duration: "30s", target: 50 },
    { duration: "15s", target: 10 },
    { duration: "15s", target: 5 },
  ]
}
```

Spike test configuration:
```javascript
export let options = {
  // starts slow and builds up the load rapidly, and then drops the load
  stages: [
    { duration: "5s", target: 1 },
    { duration: "5s", target: 5 },
    { duration: "5s", target: 25 },
    { duration: "3s", target: 200 },
    { duration: "3s", target: 20 },
    { duration: "3s", target: 10 },
    { duration: "3s", target: 5 },
    { duration: "3s", target: 1 },
  ]
}
```
As you can see, the `stages` are the utility to configure your performance test type.

#### How do we analyze the results?

K6 provides a simple [CLI output](https://docs.k6.io/docs/results-output). We believe the most important 2 high-level values here are `http_req_duration` which details response duration and `http_req` which shows the number of requests sent. If these are looking at acceptable values, CLI fulfills its purpose.

![k6 CLI](../../assets/images/perf-testing/k6-CLI.PNG)

In case of a need for further diagnosis, the graphical [insights](https://docs.k6.io/docs/load-impact-insights) is valuable. The key in a graph like this is for *Response time* and *Request rate* to follow the trend of *Virtual Users*. Any variances in the trend may signal to underlying issues.

![k6 insights](../../assets/images/perf-testing/insights.PNG)

<br/><br/>

### (5) Using performance testing to prevent ambiguous issues leaking into production

Refer to [Test Flake > Step (3): Identifying sporadic system issues - system flake](./test-flake.md)

<br/><br/><br/><br/>

## References & Further reading

[Lighthouse documentation](https://developers.google.com/web/tools/lighthouse)

[Lighthouse repo](https://github.com/GoogleChrome/lighthouse)

[Kano model](https://en.wikipedia.org/wiki/Kano_model)

[ISO/IEC 25010 Product Quality Model](https://www.iso.org/standard/35733.html)

[k6-loadImpact documentation](https://docs.k6.io/docs)

[Quick start examples with k6](https://github.com/muratkeremozcan/k6-loadImpact)



================================================
FILE: sections/advanced/performance-testing.zh.md
================================================
# æ€§èƒ½æµ‹è¯•

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

è™½ç„¶æ€§èƒ½æµ‹è¯•æ˜¯ä¸€ä¸ªåºå¤§çš„è¯é¢˜ï¼Œä½†ä½œä¸º Web å¼€å‘è€…ï¼Œæˆ‘ä»¬å¯ä»¥è¿…é€Ÿä»å…¶æ ¸å¿ƒåŸåˆ™ä¸­è·ç›Šï¼Œä»¥æå‡ç”¨æˆ·ä½“éªŒã€æ»¡è¶³åŠŸèƒ½å’ŒéåŠŸèƒ½éœ€æ±‚ï¼ˆNFRsï¼‰ï¼Œå¹¶æ£€æµ‹å¯èƒ½æ³„æ¼åˆ°ç”Ÿäº§ç¯å¢ƒä¸­çš„ä¸æ˜ç¡®ç³»ç»Ÿé—®é¢˜ã€‚

<br/><br/>

## (1) é€šè¿‡ Lighthouse ç¡®ä¿ç”¨æˆ·ä½“éªŒ

ä½œä¸º Web å¼€å‘è€…ï¼Œæˆ‘ä»¬æœ€å…³å¿ƒçš„æ˜¯ç”¨æˆ·å¯¹æ€§èƒ½çš„æ„ŸçŸ¥ã€‚è°¢å¤©è°¢åœ°ï¼ŒGoogle å·²ç»è®©è¿™å˜å¾—ç®€å•ï¼Œå¹¶ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç¬¬ä¸‰æ–¹æƒå¨è¯„ä¼°æˆ‘ä»¬ Web åº”ç”¨ç¨‹åºçš„å·¥å…· - [Lighthouse](https://developers.google.com/web/tools/lighthouse)ã€‚

> *"Lighthouse æ˜¯ä¸€ä¸ªç”¨äºæé«˜ç½‘é¡µè´¨é‡çš„å¼€æºè‡ªåŠ¨åŒ–å·¥å…·ã€‚ä½ å¯ä»¥å¯¹ä»»ä½•ç½‘é¡µè¿è¡Œå®ƒï¼Œæ— è®ºæ˜¯å…¬å¼€çš„è¿˜æ˜¯éœ€è¦èº«ä»½éªŒè¯çš„ã€‚å®ƒå¯ä»¥è¿›è¡Œæ€§èƒ½ã€å¯è®¿é—®æ€§ã€æ¸è¿›å¼ Web åº”ç”¨ã€SEO ç­‰æ–¹é¢çš„å®¡è®¡ã€‚"*

åœ¨è¿™ä¸ªè¯é¢˜ä¸­ï¼Œæˆ‘ä»¬åªå…³æ³¨æ€§èƒ½ï¼Œä½†ä½ ä¹Ÿåº”è¯¥è€ƒè™‘ä» Lighthouse çš„å®¡è®¡ä¸­è·å¾—å…³äº**æ¸è¿›å¼ Web åº”ç”¨**ã€**å¯è®¿é—®æ€§**ã€**æœç´¢å¼•æ“ä¼˜åŒ–**å’Œ**æœ€ä½³å®è·µ**çš„è¯„ä¼°ã€‚

å…¥é—¨å¾ˆç®€å•ï¼šChrome > å¼€å‘è€…å·¥å…· > å®¡è®¡ > Lighthouseã€‚ç„¶åï¼Œç”ŸæˆæŠ¥å‘Šã€‚å®ƒä¼šæ˜¾ç¤ºå¦‚ä¸‹ï¼Œå¹¶ä¸ºä½ æä¾›æœ‰å…³å¦‚ä½•æ”¹å–„ç”¨æˆ·ä½“éªŒçš„è¯¦ç»†æŒ‡å—ã€‚

![Lighthouse æŠ¥å‘Š](../../assets/images/perf-testing/lighthouse.png)

ä¸€æ—¦è¿›è¡Œäº†æ”¹è¿›å¹¶è¾¾æˆäº†åŸºçº¿è¯„çº§ï¼Œæ‚¨å¯ä»¥é€šè¿‡å°† Lighthouse çº³å…¥æ‚¨çš„ CI æ¥é˜²æ­¢å›å½’ã€‚

* å°† Lighthouse æ·»åŠ ä¸º node_moduleï¼›`npm i -D lighthouse` æˆ– `yarn add --dev lighthouse`ã€‚
* å‚è€ƒ [Lighthouse Git å­˜å‚¨åº“](https://github.com/GoogleChrome/lighthouse/blob/master/docs/readme.md#using-programmatically) ä¸Šçš„å·¥ä½œæµç¤ºä¾‹ã€‚
* é˜²æ­¢æ€§èƒ½è¯„çº§ï¼ˆå’Œ/æˆ–å…¶ä»–è¯„çº§ï¼‰åœ¨å¼€å‘äººå‘˜æäº¤ä»£ç æ—¶å‡ºç°å›å½’ï¼

### ä½¿ç”¨ Cypress é›†æˆ Lighthouse

å¦‚æœä½ æ˜¯ Cypress ç”¨æˆ·ï¼Œé€šè¿‡ [cypress-audit](https://github.com/mfrachet/cypress-audit) æ’ä»¶ï¼Œä½ å¯ä»¥åœ¨ Cypress æµ‹è¯•ä¸­æ‰§è¡Œ Lighthouse å®¡è®¡ï¼Œä»¥åŠ [Pa11y](https://www.npmjs.com/package/pa11y) è¿›è¡Œè‡ªåŠ¨åŒ–çš„å¯è®¿é—®æ€§æµ‹è¯•ã€‚

> é™¤äº†[é€šå¸¸çš„æ’ä»¶è®¾ç½®](https://github.com/mfrachet/cypress-audit#preparation)ä¹‹å¤–ï¼Œä½ å¯èƒ½éœ€è¦è§£å†³ä½ çš„åº”ç”¨ç¨‹åºçš„[è·¨åŸŸé—®é¢˜](https://github.com/cypress-io/cypress/issues/944#issuecomment-788373384)ï¼Œç›´åˆ° Cypress å®˜æ–¹æ”¯æŒå®ƒã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¸¦æœ‰å†…è”è¯´æ˜çš„ç¤ºä¾‹æµ‹è¯•ã€‚

```typescript

// Pass in optional configuration parameters for the Cypress test:
// you may need to increase default timeout for the overall task, if you have a slow app. Mind that Lighthouse is only for Chromium based browsers
describe('Lighthouse audit ', { taskTimeout: 90000, browser: 'chrome' }, () => {
  before(() => {
    // if you are using programmatic login, you might not need to use the cy.forceVisit('/') workaround for cross-origin (linked above)
    cy.login(Cypress.env('USERNAME'), Cypress.env('PASSWORD'));
  });

  // thresholds is the first argument to cy.lighthouse(), most of the performance configuration is done here.
  // a complete list of Lighthouse parameters to use as thresholds can be found at https://github.com/mfrachet/cypress-audit/blob/master/docs/lighthouse.md
  // for an explanation of the parameters, refer to https://web.dev/lighthouse-performance/
  const thresholds = {
    'first-contentful-paint': 20000,
    'largest-contentful-paint': 35000,
    'first-meaningful-paint': 20000,
    'speed-index': 25000,
    interactive: 40000,
    performance: 5,
    accessibility: 50,
    'best-practices': 50,
    seo: 50,
    pwa: 20
  };

  // the 2nd, and optional argument to cy.lighthouse() replicates Lighthouse CLI commands https://github.com/GoogleChrome/lighthouse#cli-options
  const desktopConfig = {
    formFactor: 'desktop',
    screenEmulation: { disabled: true }
  };

  // your app may need this beforeEach and afterEach workaround for cross-origin (linked above)
  beforeEach(() => {
    cy.restoreLocalStorage();
    // Preserve Cookies between tests
    Cypress.Cookies.defaults({
      preserve: /[\s\S]*/
    });
  });

  afterEach(() => {
    cy.saveLocalStorage();
  });

  it('should pass audit for main page ', () => {
    cy.lighthouse(thresholds, desktopConfig);
  });

  it('should pass audit for another page', () => {
    cy.forceVisit('anotherUrl');
    cy.lighthouse(thresholds, desktopConfig);
  });
});

// Commands for working around cross origin, if needed

// -- Save localStorage between tests
let LOCAL_STORAGE_MEMORY = {};
Cypress.Commands.add('saveLocalStorage', () => {
  Object.keys(localStorage).forEach(key => {
    LOCAL_STORAGE_MEMORY[key] = localStorage[key];
  });
});

Cypress.Commands.add('restoreLocalStorage', () => {
  Object.keys(LOCAL_STORAGE_MEMORY).forEach(key => {
    localStorage.setItem(key, LOCAL_STORAGE_MEMORY[key]);
  });
});

// -- Visit multiple domains in one test
Cypress.Commands.add('forceVisit', url => {
  cy.window().then(win => win.open(url, '_self'));
});
```

<br/><br/>

## (2) æ€§èƒ½ä½œä¸ºä¸€ç§éåŠŸèƒ½æ€§éœ€æ±‚å’Œ Kano æ¨¡å‹

æˆ‘ä»¬å¯ä»¥é€šè¿‡[Kano æ¨¡å‹](https://en.wikipedia.org/wiki/Kano_model)å¼€å§‹å»ºç«‹å¯¹æ€§èƒ½éœ€æ±‚çš„ç†è§£ã€‚

> *"Kano æ¨¡å‹æ˜¯åœ¨ 1980 å¹´ä»£ç”±æ—¥æœ¬å­¦è€…ç‹©é‡çºªæ˜æ•™æˆå¼€å‘çš„äº§å“å¼€å‘å’Œå®¢æˆ·æ»¡æ„åº¦ç†è®ºï¼Œå°†å®¢æˆ·åå¥½åˆ†ä¸ºäº”ç±»ã€‚"*

ä»é«˜å±‚æ¬¡ä¸Šçœ‹ï¼Œå¡è¯ºæ¨¡å‹æ€»ç»“äº†æ€§èƒ½ç‰¹æ€§æ˜¯æ ‡å‡†è¦æ±‚ï¼Œæ˜¯ä»»ä½•ç«äº‰æ€§äº§å“æ‰€æœŸæœ›çš„ã€‚è¿™ä¸æˆ‘ä»¬ä½¿ç”¨ Lighthouse çš„æ–¹å¼é‡å ï¼›é€šè¿‡å®ƒï¼Œæˆ‘ä»¬ç¡®ä¿æ»¡è¶³å®¢æˆ·åå¥½ï¼Œå¹¶ç¡®ä¿æˆ‘ä»¬ä¸ä¼šå›é€€ã€‚

![Kano æ¨¡å‹](../../assets/images/perf-testing/KANO_model.jpg)

åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬å·²ç»æ»¡è¶³äº†æ˜ç¡®è¯´æ˜çš„æ€§èƒ½è¦æ±‚ã€‚ç„¶è€Œï¼Œåœ¨å¤æ‚çš„åº”ç”¨ç¨‹åºä¸­ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ³¨æ„éåŠŸèƒ½æ€§éœ€æ±‚ï¼ˆNFRsï¼‰ã€‚ä½†æ˜¯ï¼Œä»€ä¹ˆæ˜¯ NFRs å‘¢ï¼Ÿä¸‹é¢æ˜¯å®ƒä»¬åœ¨ä¸€ç¥ä¹‹ä¸‹çš„é«˜å±‚æ¬¡è§†å›¾ - æ¥è‡ªåŒé‡æ ‡å‡†çš„[ISO/IEC 25010 äº§å“è´¨é‡æ¨¡å‹](https://www.iso.org/standard/35733.html)ã€‚

![ISO/IECæ ‡å‡†](../../assets/images/perf-testing/ISO_IEC_25010.jpg)

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œè®©æˆ‘ä»¬ä¸“æ³¨äº NFRs å¦‚ä½•å¸®åŠ©æˆ‘ä»¬è¿›è¡ŒéåŠŸèƒ½æ€§èƒ½æµ‹è¯•çš„æ–¹æ³•ã€‚

<br/><br/>

## (3) æ€§èƒ½æµ‹è¯•çš„ç±»å‹

ä¸ºäº†å®é™…åº”ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†éåŠŸèƒ½æ€§èƒ½æµ‹è¯•åˆ†ä¸º 3 ä¸ªç±»åˆ«

* Load è´Ÿè½½æµ‹è¯•
* Spike å°–å³°æµ‹è¯•
* Endurance è€ä¹…æµ‹è¯•

è¿™å¼ å›¾æ€»ç»“äº†å®ƒä»¬çš„ä¸Šä¸‹æ–‡ï¼š

![ISO/IECæ ‡å‡†](../../assets/images/perf-testing/performanceTesting.jpg)

***å…³äºåŸºå‡†æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•çš„é¢å¤–è¯´æ˜**: æœ¬è´¨ä¸Šï¼ŒåŸºå‡†æµ‹è¯•å½’ç»“ä¸ºé€æ­¥çš„æ­¥éª¤ï¼Œå› ä¸ºæˆ‘ä»¬é€æ¸äº†è§£æˆ‘ä»¬çš„ç³»ç»Ÿï¼Œè¿™æˆä¸ºäº†åˆå§‹å·¥ä½œæµç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­ä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·ï¼›*"æˆ‘çš„ç³»ç»Ÿå·²ç»å´©æºƒäº†å—ï¼Ÿæ²¡æœ‰ï¼Ÿé‚£æˆ‘å†å¢åŠ ä¸€ç‚¹"ã€‚*è€Œå‹åŠ›æµ‹è¯•ï¼Œç®€è€Œè¨€ä¹‹ï¼Œå°±æ˜¯åšå¾—è¿‡ç«äº†ã€‚*

é‚£ä¹ˆ**å¯æ‰©å±•æ€§æµ‹è¯•**çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯ç›¸å…³çš„ï¼›åŒºåˆ«åœ¨äºç³»ç»Ÿä½•æ—¶å¼€å§‹ä»¥ä¸ä»¤äººæ»¡æ„çš„æ–¹å¼ä¸å“åº”çš„è¯„ä¼°ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·çš„æ–¹æ³•è¶³å¤Ÿæ¥è¿‘ï¼Œå¹¶ä¸”å¯ä»¥åœ¨è´Ÿè½½æµ‹è¯•ä¸­åˆ†æå›¾è¡¨æ—¶å®ç°ã€‚

è¿™æ˜¯å¯æ‰©å±•æ€§æµ‹è¯•æ„å›¾çš„é«˜å±‚æ¬¡å›¾ï¼š

![ISO/IECæ ‡å‡†](../../assets/images/perf-testing/scalabilityTesting.jpg)

<br/><br/>

### (4) ä½¿ç”¨ k6-loadImpact è¿›è¡Œæ€§èƒ½æµ‹è¯•çš„å®é™…åº”ç”¨

[k6-loadImpact](https://docs.k6.io/docs)åœ¨ Web å¼€å‘é¢†åŸŸæœ‰ä¸¤ä¸ªæ˜¾è‘—çš„ç‰¹ç‚¹ã€‚

* ä½¿ç”¨ JSï¼ˆES6ï¼‰
* ä¸“ä¸º CI æ„å»º

é¢å¤–çš„å¥½å¤„ï¼šå¦‚æœä½ ä¹ æƒ¯ä½¿ç”¨ Postmanï¼Œä½ å¯ä»¥è½»æ¾åœ°å°†è¿™äº›æµ‹è¯•è½¬æ¢ä¸º k6ã€‚
K6 *å¯ä»¥* è¿›è¡Œ DOM æµ‹è¯•ï¼Œä½†æˆ‘ä»¬è®¤ä¸º Lighthouse å·²ç»å¤„ç†äº†è¿™æ–¹é¢çš„é—®é¢˜ã€‚K6 çœŸæ­£å¼ºå¤§çš„åœ°æ–¹åœ¨äºæµ‹è¯• API æ—¶ã€‚

ä½ å¯ä»¥åœ¨[è¿™é‡Œæ‰¾åˆ°ä½¿ç”¨ k6 çš„å¿«é€Ÿå…¥é—¨ç¤ºä¾‹](https://github.com/muratkeremozcan/k6-loadImpact)ã€‚
è¿™äº›ç¤ºä¾‹ä»éå¸¸ç®€å•çš„å¼€å§‹ï¼Œæ—¨åœ¨å¿«é€Ÿå»ºç«‹ç†è§£ã€‚å®ƒä»¬å·²ç»å‡†å¤‡å¥½ç›´æ¥è¿è¡Œå’Œè°ƒæ•´ã€‚æˆ‘ä»¬å°†ä¸ä¼šåœ¨è¿™é‡Œé‡å¤è¿™äº›çŸ¥è¯†ã€‚

ç›¸åï¼Œåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¦‚è¿° k6 æµ‹è¯•çš„æ¦‚è§ˆï¼Œå¹¶ç¨åå±•ç¤ºä¸€ä¸ªä»£ç ç¤ºä¾‹ï¼Œæ¼”ç¤ºå¦‚ä½•é…ç½® k6 ä»¥é€‚åº”ä¸åŒç±»å‹çš„æ€§èƒ½æµ‹è¯•ã€‚

```javascript
// k6 lifecycle overview:

// 1. init code -> runs once
// this is where we configure the type of performance testing (there are also
// additional options we do not cover here)
export let options = {
  // there will be 1 virtual user
  vus: 1,

  // default function() will execute 1 time. This simple config
  // is best when trying to get things to work
  iterations: 1,
}

// 2. (optional) setup code -> runs once
export function setup() {
  // for example getting a token so you can run API tests in the default
  // function that comes in (3) virtual user code

  // what gets returned from this function is passed as an argument to the next
  // function. For example: `token`
  return getTokenForUser();
}

// 3. virtual user code -> runs once or many times based on
// `export let options = { ... } `
export default function(token) {
  // http.get is a k6 function that hits a URL with optional test parameters
  // note that  we do not need a token for this url
  http.get("http://test.loadimpact.com");
}

// 4. (optional) teardown code -> runs once
export function teardown(data) {
  // this is in case you need to clean up, for instance if failed test may
  // leave residue an impact state
}
```

è€ä¹…æµ‹è¯•é…ç½®ï¼š

```javascript
export let options = {
  // endurance test for 30 seconds with 50 virtual users. Adds users immediately
  vus: 50,
  duration: "30s",

  // alternative to duration, you can  specify the exact number of iterations
  // the test will run
  // iterations: 500,
}
```

è´Ÿè½½æµ‹è¯•é…ç½®ï¼š

```javascript
export let options = {
  // for 15 seconds ramps up 10 users, adds users gradually
  // adds a total of 40 users in the next 15 seconds, and up to 50 in the next
  // 30 seconds..
  // lowers down the users to 10 and 5 in the next 15 second iterations
  stages: [
    { duration: "15s", target: 10 },
    { duration: "15s", target: 40 },
    { duration: "30s", target: 50 },
    { duration: "15s", target: 10 },
    { duration: "15s", target: 5 },
  ]
}
```

å°–é”‹æµ‹è¯•é…ç½®ï¼š

```javascript
export let options = {
  // starts slow and builds up the load rapidly, and then drops the load
  stages: [
    { duration: "5s", target: 1 },
    { duration: "5s", target: 5 },
    { duration: "5s", target: 25 },
    { duration: "3s", target: 200 },
    { duration: "3s", target: 20 },
    { duration: "3s", target: 10 },
    { duration: "3s", target: 5 },
    { duration: "3s", target: 1 },
  ]
}
```

æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œ`stages` æ˜¯é…ç½®æ€§èƒ½æµ‹è¯•ç±»å‹çš„å®ç”¨å·¥å…·ã€‚

### æˆ‘ä»¬å¦‚ä½•åˆ†ææµ‹è¯•ç»“æœï¼Ÿ

K6 æä¾›äº†ä¸€ä¸ªç®€å•çš„[CLI è¾“å‡º](https://docs.k6.io/docs/results-output)ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™é‡Œæœ€é‡è¦çš„ä¸¤ä¸ªé«˜çº§æ•°å€¼æ˜¯ `http_req_duration`ï¼Œå®ƒè¯¦ç»†è¯´æ˜äº†å“åº”æŒç»­æ—¶é—´ï¼Œä»¥åŠ `http_req`ï¼Œå®ƒæ˜¾ç¤ºå‘é€çš„è¯·æ±‚æ•°é‡ã€‚å¦‚æœè¿™äº›æ•°å€¼åœ¨å¯æ¥å—çš„èŒƒå›´å†…ï¼ŒCLI å°±è¾¾åˆ°äº†å…¶ç›®çš„ã€‚

![k6 CLI](../../assets/images/perf-testing/k6-CLI.PNG)

å¦‚æœéœ€è¦è¿›è¡Œæ›´æ·±å…¥çš„è¯Šæ–­ï¼Œå›¾å½¢åŒ–çš„[insights](https://docs.k6.io/docs/load-impact-insights)éå¸¸æœ‰ä»·å€¼ã€‚åœ¨è¿™æ ·çš„å›¾è¡¨ä¸­ï¼Œå…³é”®æ˜¯ *å“åº”æ—¶é—´* å’Œ *è¯·æ±‚é€Ÿç‡* è·Ÿéš *è™šæ‹Ÿç”¨æˆ·* çš„è¶‹åŠ¿ã€‚ä»»ä½•è¶‹åŠ¿ä¸Šçš„å˜åŒ–éƒ½å¯èƒ½æç¤ºæ½œåœ¨é—®é¢˜ã€‚

<br/><br/>

## (5) é€šè¿‡æ€§èƒ½æµ‹è¯•æ¥é˜²æ­¢ä¸ç¨³å®šçš„é—®é¢˜è¿›å…¥ç”Ÿäº§ç¯å¢ƒ

å¯å‚è€ƒç« èŠ‚ [ä¸ç¨³å®šçš„æµ‹è¯• > ç¬¬ä¸‰æ­¥ï¼šè¯†åˆ«é›¶æ˜Ÿçš„ç³»ç»Ÿé—®é¢˜ - *ä¸ç¨³å®šçš„ç³»ç»Ÿ*](./test-flake.zh.md)

<br/><br/><br/><br/>

## å‚è€ƒèµ„æ–™å’Œå»¶ä¼¸é˜…è¯»

[Lighthouse æ–‡æ¡£](https://developers.google.com/web/tools/lighthouse)

[Lighthouse ä»£ç åº“](https://github.com/GoogleChrome/lighthouse)

[Kano æ¨¡å‹](https://en.wikipedia.org/wiki/Kano_model)

[ISO/IEC 25010 äº§å“è´¨é‡æ¨¡å‹](https://www.iso.org/standard/35733.html)

[k6-loadImpact æ–‡æ¡£](https://docs.k6.io/docs)

[ä½¿ç”¨ K6 çš„å¿«é€Ÿå¯åŠ¨ç¤ºä¾‹](https://github.com/muratkeremozcan/k6-loadImpact)



================================================
FILE: sections/advanced/test-flake.md
================================================
# Test flake

<br/><br/>

### One Paragraph Explainer

Tests must produce consistent results every time. Repeatable pipeline execution results are the quorum.
If a test cannot produce reliable results, it reduces confidence in the tests and requires maintenance which reduces all value. In these cases, it may be best to manually test the functionality.

And ask yourself these questions:

* How do you address Test Flake and ensure test-confidence through growing pains?
* How do you address false-negatives with the pipeline, infrastructure, shared resources and not having control?
* How do you reveal **Sporadic Defects**?

<br/><br/>


### Step 1: Locally identifying test flake

Headless execution in an OS that replicates pipeline CI machine is preferred; Linux and MacOS will behave more similarly to the pipeline than Windows -with the exception of Windows Docker containers if you are using one. Headless execution will reveal more of the test flake. There are various ways to repeatedly execute a test spec, one example from Cypress is using the Lodash library (already built-in with Cypress) `Cypress._.times( <times to repeat>, () => { <your test spec code> })`. This must be utilized before pushing any code for a merge request.

#### Code Example

```JavaScript
// will repeat the full suite 10 times
Cypress._.times( 10, function {

  describe('..', function () {

    before(function () {
    });

    beforeEach(function () {
    });

      // you can place it anywhere to repeat 1 test, or another describe / context block
      Cypress._.times( 3, function {
        it('..', function () {..});
      }
      it('..', function () {..});
      it('..', function () {..});
      it('..', function () {..});

  });
});

// this will result in 6 tests per run x 10 runs = 60 executions

```
<br/>

### Step 2: Identifying test flake in the pipeline & retries

After initial pipelines pass, things are looking good and the code gets merged, it just so may happen that tests ***sometimes*** fail in the pipeline.

Why do tests still fail if ***there are no reproducible defects*** and ***the test code has been fully optimized***?

Rather than the tests failing at a sporadic rate, getting ignored, or worse ***reducing the team's confidence in them***, retry mechanisms can be utilized:
* To work around an unreliable pipeline infrastructure that the team has no control over
* Growing pains during development and / or dependencies on external services under development
* Most importantly ***to lock-in on sporadic system issues***


#### Code Example

Many frameworks implement retry utilities. Here is an example from [Cypress docs](https://docs.cypress.io/guides/references/migration-guide.html#Tests-retries):

In a test:
```javascript
it('allows user to login', { // can also be in a context or describe block
  retries: {
    runMode: 2, // for CI usage
    openMode: 1  // for local usage
  }
}, () => {
  // ...
})
```

In a configuration file such as `cypress.json`:
```json
{
  "retries": {
    "runMode": 1,
    "openMode": 3
  }
}



```
### Step 3: Identifying sporadic system issues - *system flake*

Given that:

* There are no reproducible defects
* The test code is fully optimized
* Pipeline issues are known and validly worked-around with test retries
* External dependencies, growing pains are known, recognized and worked around with test retries

... How do we detect deeper issues with the system that *may* indicate *system-flake*? Here is a snapshot from a team's [Cypress dashboard](https://www.cypress.io/dashboard/) of such an example:

 >*"It fails at 10% rate over 40 executions on the weekend... We ran the test suite 40 times, and in one of them saw the spec retrying 2 times until it passed..."*
![](../../assets/images/test-retry-pipeline.PNG)

*Pleas note: the camera icon means that there are some test failures because Cypress takes videos and screenshot on failures.*


In these cases, consistency testing with [cron jobs](https://crontab.guru/#0_1-23_*_*_6-7) overnights or the weekends can be utilized as the initial indicator of deeper system issues. These are usually the ambiguous defects that are likely to leak into production, be found on the field and have costly repercussions at a larger scale.


#### Code Example - [cron jobs](https://crontab.guru/#0_1-23_*_*_6-7)

```cron syntax
at minute 0 at midnight and 2 am, every day-of-week from Monday through Friday:

0 0,2 * * 1-5


At minute 0 past hour 2, 6, 8, 10, 12, 14, 16, 18, and 20 on every day-of-week from Saturday through Sunday:

0 2,6,8,10,12,14,16,18,20 * * 6-7
```

Once all other factors are ruled out and the initial indication of *system-flake* realized in automated tests in the pipeline with cron jobs, these issues are perfect candidates for **Performance Testing** because such test methodology can directly indicate shortcomings in the system that may be causing the *system-flake*.

Here is performance testing in a nutshell:

![](../../assets/images/performanceTesting.jpg)


There are many performance testing tools. One that we find approachable due to it being in ES6 and pipeline friendly is [k6-loadImpact](https://docs.k6.io/docs). A simple tutorial with code samples can be found [here](https://github.com/muratkeremozcan/k6-loadImpact).

### References
[Google Testing Blog: Where do our flaky tests come from](https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html)



================================================
FILE: sections/advanced/test-flake.zh.md
================================================
# ä¸ç¨³å®šçš„æµ‹è¯•

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

æ¯æ¬¡æµ‹è¯•éƒ½å¿…é¡»äº§ç”Ÿä¸€è‡´çš„ç»“æœï¼Œè€Œå¯é‡å¤çš„æµæ°´çº¿æ‰§è¡Œç»“æœåˆ™æ˜¯è‡³å…³é‡è¦çš„ã€‚å¦‚æœæµ‹è¯•æ— æ³•äº§ç”Ÿå¯é çš„ç»“æœï¼Œå°†é™ä½å¯¹æµ‹è¯•çš„ä¿¡å¿ƒï¼Œè¿˜éœ€è¦è¿›è¡Œç»´æŠ¤ï¼Œè¿™å°†é™ä½æ‰€æœ‰ä»·å€¼ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæœ€å¥½è¿›è¡Œæ‰‹åŠ¨åŠŸèƒ½æµ‹è¯•ã€‚

å¹¶è¯·è‡ªé—®ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š

- å¦‚ä½•è§£å†³æµ‹è¯•æ³¢åŠ¨ï¼Œé€šè¿‡æˆé•¿çš„è¿‡ç¨‹ç¡®ä¿æµ‹è¯•çš„å¯ä¿¡åº¦ï¼Ÿ
- å¦‚ä½•å¤„ç†æµæ°´çº¿ã€åŸºç¡€è®¾æ–½ã€å…±äº«èµ„æºç­‰æ–¹é¢çš„å‡é˜´æ€§ï¼Œå¹¶åœ¨æ²¡æœ‰æ§åˆ¶çš„æƒ…å†µä¸‹è§£å†³ï¼Ÿ
- å¦‚ä½•å‘ç°é›¶æ˜Ÿç¼ºé™·ï¼Ÿ

<br/><br/>

## ç¬¬ä¸€æ­¥ï¼šæœ¬åœ°è¯†åˆ«ä¸ç¨³å®šçš„æµ‹è¯•

æ¨èåœ¨æ¨¡æ‹Ÿæµæ°´çº¿ CI æœºå™¨çš„æ“ä½œç³»ç»Ÿä¸­è¿›è¡Œæ— å¤´æ¨¡å¼æ‰§è¡Œï¼›Linux å’Œ MacOS ä¸æµæ°´çº¿çš„è¡Œä¸ºæ›´ä¸ºç›¸ä¼¼ï¼Œè€Œ Windows åˆ™æ˜¯ä¸ªä¾‹å¤–ï¼Œé™¤éä½ æ­£åœ¨ä½¿ç”¨ Windows Docker å®¹å™¨ã€‚æ— å¤´æ‰§è¡Œå°†æ›´å®¹æ˜“æš´éœ²æµ‹è¯•æ³¢åŠ¨ã€‚æœ‰å¤šç§æ–¹æ³•å¯ä»¥é‡å¤æ‰§è¡Œæµ‹è¯•è§„èŒƒï¼ŒCypress æä¾›çš„ä¸€ä¸ªä¾‹å­æ˜¯ä½¿ç”¨ Lodash åº“ï¼ˆCypress å·²ç»å†…ç½®äº†ï¼‰`Cypress._.times( <é‡å¤æ¬¡æ•°>, () => { <ä½ çš„æµ‹è¯•è§„èŒƒä»£ç > })`ã€‚åœ¨æäº¤ä»£ç åˆå¹¶è¯·æ±‚ä¹‹å‰ï¼ŒåŠ¡å¿…ä½¿ç”¨æ­¤æ–¹æ³•ã€‚

### ç¬¬ä¸€æ­¥çš„ä»£ç ç¤ºä¾‹

```JavaScript
// will repeat the full suite 10 times
Cypress._.times( 10, function {

  describe('..', function () {

    before(function () {
    });

    beforeEach(function () {
    });

      // you can place it anywhere to repeat 1 test, or another describe / context block
      Cypress._.times( 3, function {
        it('..', function () {..});
      }
      it('..', function () {..});
      it('..', function () {..});
      it('..', function () {..});

  });
});

// this will result in 6 tests per run x 10 runs = 60 executions

```

<br/>

## ç¬¬äºŒæ­¥ï¼šåœ¨æµæ°´çº¿ä¸­è¯†åˆ«ä¸ç¨³å®šçš„æµ‹è¯•å¹¶è¿›è¡Œé‡è¯•

åœ¨åˆå§‹çš„æµæ°´çº¿é¡ºåˆ©é€šè¿‡å¹¶åˆå¹¶ä»£ç åï¼Œ**æœ‰æ—¶**æµ‹è¯•ä¼šå‡ºç°å¤±è´¥çš„æƒ…å†µã€‚

ä¸ºä»€ä¹ˆæµ‹è¯•åœ¨**æ²¡æœ‰å¯é‡ç°çš„ç¼ºé™·**ä¸”**æµ‹è¯•ä»£ç å·²ç»å®Œå…¨ä¼˜åŒ–çš„æƒ…å†µä¸‹ä»ç„¶å¤±è´¥å‘¢**ï¼Ÿ

ä¸ºäº†è§£å†³è¿™ç§é›¶æ˜Ÿçš„å¤±è´¥é—®é¢˜ï¼Œä»¥åŠé¿å…æµ‹è¯•è¢«å¿½ç•¥æˆ–**é™ä½å›¢é˜Ÿå¯¹å…¶çš„ä¿¡å¿ƒ**ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨é‡è¯•æœºåˆ¶ï¼š

- ç”¨ä»¥è§£å†³å›¢é˜Ÿæ— æ³•æŒæ§çš„ä¸å¯é æµæ°´çº¿åŸºç¡€è®¾æ–½é—®é¢˜
- åœ¨å¼€å‘ä¸­é‡åˆ°çš„é—®é¢˜ï¼Œæˆ–è€…ä¾èµ–äºæ­£åœ¨å¼€å‘ä¸­çš„å¤–éƒ¨æœåŠ¡
- æœ€ä¸ºé‡è¦çš„æ˜¯ï¼Œ**ç”¨äºé”å®šé›¶æ˜Ÿçš„ç³»ç»Ÿé—®é¢˜**

### ç¬¬äºŒæ­¥çš„ä»£ç ç¤ºä¾‹

è®¸å¤šæ¡†æ¶éƒ½æä¾›äº†é‡è¯•å®ç”¨å·¥å…·ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­æ¥è‡ªäº [Cypress æ–‡æ¡£](https://docs.cypress.io/guides/references/migration-guide.html#Tests-retries):

åœ¨ä¸€ä¸ªæµ‹è¯•ä¸­ï¼š

```javascript
it('allows user to login', { // can also be in a context or describe block
  retries: {
    runMode: 2, // for CI usage
    openMode: 1  // for local usage
  }
}, () => {
  // ...
})
```

åœ¨é…ç½®æ–‡ä»¶ä¸­ï¼Œä¾‹å¦‚ `cypress.json`:

```json
{
  "retries": {
    "runMode": 1,
    "openMode": 3
  }
}



```

## ç¬¬ä¸‰æ­¥ï¼šè¯†åˆ«é›¶æ˜Ÿçš„ç³»ç»Ÿé—®é¢˜ - *ä¸ç¨³å®šçš„ç³»ç»Ÿ*

é‰´äºä»¥ä¸‹æƒ…å†µï¼š

- ä¸å­˜åœ¨å¯é‡ç°çš„ç¼ºé™·
- æµ‹è¯•ä»£ç å·²ç»å……åˆ†ä¼˜åŒ–
- å·²çŸ¥å¹¶é€šè¿‡æµ‹è¯•é‡è¯•æœ‰æ•ˆè§£å†³äº†æµæ°´çº¿é—®é¢˜
- å·²çŸ¥ã€è®¤å¯å¹¶é€šè¿‡æµ‹è¯•é‡è¯•è§£å†³äº†å¤–éƒ¨ä¾èµ–å’Œæˆé•¿ç—›è‹¦

... æˆ‘ä»¬å¦‚ä½•æ£€æµ‹ç³»ç»Ÿå­˜åœ¨çš„æ›´æ·±å±‚æ¬¡é—®é¢˜ï¼Œè¿™å¯èƒ½è¡¨æ˜å­˜åœ¨*ä¸ç¨³å®šçš„ç³»ç»Ÿ*ï¼Ÿä»¥ä¸‹æ˜¯å›¢é˜Ÿ[Cypress ä»ªè¡¨æ¿](https://www.cypress.io/dashboard/)ä¸Šçš„ä¸€ä¸ªç¤ºä¾‹å¿«ç…§ï¼š

>*â€œåœ¨å‘¨æœ«çš„ 40 æ¬¡æ‰§è¡Œä¸­ï¼Œå®ƒä»¥ 10% çš„é”™è¯¯ç‡å¤±è´¥... æˆ‘ä»¬è¿è¡Œäº†æµ‹è¯•å¥—ä»¶ 40 æ¬¡ï¼Œåœ¨å…¶ä¸­çš„ä¸€æ¬¡æ‰§è¡Œä¸­çœ‹åˆ°è¯¥è§„èŒƒé‡è¯•äº† 2 æ¬¡ï¼Œç›´åˆ°é€šè¿‡...â€*

![ ](/assets/images/test-retry-pipeline.png)

*è¯·æ³¨æ„ï¼šç›¸æœºå›¾æ ‡è¡¨ç¤ºä¸€äº›æµ‹è¯•å¤±è´¥ï¼Œå› ä¸º Cypress åœ¨å¤±è´¥æ—¶ä¼šæ‹æ‘„è§†é¢‘å’Œæˆªå›¾ã€‚*

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå¯ä»¥é€šè¿‡æ¯æ™šæˆ–å‘¨æœ«çš„ [cron ä»»åŠ¡](https://crontab.guru/#0_1-23_*_*_6-7) è¿›è¡Œä¸€è‡´æ€§æµ‹è¯•ï¼Œä½œä¸ºæ›´æ·±å±‚æ¬¡ç³»ç»Ÿé—®é¢˜çš„åˆå§‹æŒ‡æ ‡ã€‚è¿™äº›é€šå¸¸æ˜¯é‚£äº›å®¹æ˜“æ³„æ¼åˆ°ç”Ÿäº§ç¯å¢ƒä¸­ã€åœ¨å®é™…ä½¿ç”¨ä¸­è¢«å‘ç°å¹¶å…·æœ‰æ˜‚è´µåæœçš„æ¨¡ç³Šç¼ºé™·ã€‚

### ä»£ç ç¤ºä¾‹ - [cron ä»»åŠ¡](https://crontab.guru/#0_1-23_*_*_6-7)

```cron syntax
at minute 0 at midnight and 2 am, every day-of-week from Monday through Friday:

0 0,2 * * 1-5


At minute 0 past hour 2, 6, 8, 10, 12, 14, 16, 18, and 20 on every day-of-week from Saturday through Sunday:

0 2,6,8,10,12,14,16,18,20 * * 6-7
```

ä¸€æ—¦æ’é™¤äº†æ‰€æœ‰å…¶ä»–å› ç´ ï¼Œå¹¶ä¸”åœ¨ç®¡é“ä¸­ä½¿ç”¨ cron ä»»åŠ¡è‡ªåŠ¨åŒ–æµ‹è¯•åˆæ­¥æŒ‡ç¤ºäº†â€œç³»ç»Ÿæ³¢åŠ¨â€ï¼Œè¿™äº›é—®é¢˜å°±æ˜¯**æ€§èƒ½æµ‹è¯•**çš„ç†æƒ³å€™é€‰é¡¹ï¼Œå› ä¸ºè¿™ç§æµ‹è¯•æ–¹æ³•å¯ä»¥ç›´æ¥æŒ‡å‡ºå¯èƒ½å¯¼è‡´â€œä¸ç¨³å®šçš„ç³»ç»Ÿâ€çš„ç³»ç»Ÿç¼ºé™·ã€‚

æ€§èƒ½æµ‹è¯•çš„è¦ç‚¹å¦‚ä¸‹ï¼š
![ ](../../assets/images/performanceTesting.jpg)

æœ‰è®¸å¤šæ€§èƒ½æµ‹è¯•å·¥å…·ï¼Œå…¶ä¸­ä¸€ä¸ªæˆ‘ä»¬è®¤ä¸ºæ¯”è¾ƒæ˜“äºä½¿ç”¨çš„æ˜¯ [k6-loadImpact](https://docs.k6.io/docs)ï¼Œå› ä¸ºå®ƒé‡‡ç”¨äº† ES6 è¯­æ³•ï¼Œå¹¶ä¸”ä¸æµæ°´çº¿å…¼å®¹ã€‚
ä½ å¯ä»¥åœ¨ [è¿™é‡Œ](https://github.com/muratkeremozcan/k6-loadImpact) æ‰¾åˆ°ä¸€ä¸ªåŒ…å«ä»£ç ç¤ºä¾‹çš„ç®€å•æ•™ç¨‹ã€‚

## å‚è€ƒèµ„æ–™

[Google æµ‹è¯•åšå®¢ï¼šæˆ‘ä»¬çš„æµ‹è¯•ä¸­å“ªäº›æ˜¯ä¸ç¨³å®šçš„ï¼Œæ˜¯ä»å“ªäº›æ–¹é¢äº§ç”Ÿçš„](https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html)



================================================
FILE: sections/advanced/test-states.md
================================================
# Test States

<br/><br/>

### One Paragraph Explainer

Tests should be repeatable, modular and should handle their own state setup. UI Tests should not be repeated in order to achieve state for another test.

We want to have stateless that can scale:

* Tests that independently handle their state.
* Have no side effects outside themselves, or manageable side effects which the test handles itself
* Tests that can be executed by *n* number of entities simultaneously.

<br/><br/>

### Code Example â€“ explanation

**Repeatability**: tests must setup state, perform the test, and leave the environment in a clean state which does not affect the execution of the next test. If a test clutters the system in every execution, leaves it in a state that cannot be reset, this is a manual test candidate. Tests must also not clash with each other: multiple testers and pipelines must be able to execute the same test at the same time. If this is not possible, these groups of tests should be executed once a day in a pipeline [cron job](https://crontab.guru/#0_1-23_*_*_6-7), preferably outside of business hours.

Each test that must change the state of the environment has to be used as a setup-state-test and must ensure that the test environment is  able to be cleaned up before the next test.

It is preferred that UI tests do not repeat themselves as setup tests; API tests, Application Actions or DB seeding should be utilized wherever a UI test has to be used as a setup for another test.

**Setup vs Cleanup**: Setup (before all) is preferred over Cleanup (after all). Wherever possible, the test itself should take responsibility that it starts in a clean environment. However, as emphasized above, tests must not make it so that after their execution the next test cannot clean up the environment.

**Login**: Varieties of UI-login should only be used in their singular test cases. Any other tests that require login should use intrinsic API login and/or have a pre-configured test user.

**Test state setup**: It is encouraged that tests are isolated so that they do not rely on an entire setup before they can be executed. Example: if a group of tests may need a user to be created, a test user can be utilized to use these tests in isolation. On the other hand, the tests that setup the user should be independent and isolated.

**Modularity**: each test should be able to be run by itself, not relying on other tests to set up state for it. If this setup is required, it should be handled in beforeAll or beforeEach sections. A good way to test this is to run the test in isolation: `it.only()` , `fit()`, etc.).

```JavaScript
describe('..', function () {

  // setup (before/beforeEach) is preferred over cleanup (after/afterEach)

  before(function () {
    // login with UI once in an isolated test
    // for login here and all other tests, use a faster login method: use API, App Actions or DB seeding
  });

  beforeEach(function () {
    // setup additional state...
    // have one UI test to ensure this state can be achieved
    // however for the state set up here, utilize API, Application Actions or DB seeding; do not repeat UI tests
  });

    // test each test once with .only to ensure modularity
    it('..', function () {..});
    it('..', function () {..});
    it.only('..', function () {..});
    it('..', function () {..});

});

```

<br/><br/>

### References
[Stop using Page Objects and Start using App Actions](https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/)

[Cypress Docs: Organizing Tests, Logging In, Controlling State](https://docs.cypress.io/guides/references/best-practices.html#Organizing-Tests-Logging-In-Controlling-State)



================================================
FILE: sections/advanced/test-states.zh.md
================================================
# æµ‹è¯•çŠ¶æ€

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

æµ‹è¯•åº”è¯¥æ˜¯å¯é‡å¤çš„ã€æ¨¡å—åŒ–çš„ï¼Œå¹¶ä¸”åº”è¯¥è‡ªå·±å¤„ç†çŠ¶æ€è®¾ç½®ã€‚ä¸ºäº†ä¸ºå…¶ä»–æµ‹è¯•å®ç°çŠ¶æ€ï¼Œä¸åº”è¯¥é‡å¤æ‰§è¡Œ UI æµ‹è¯•ã€‚

æˆ‘ä»¬å¸Œæœ›æµ‹è¯•æ˜¯æ— çŠ¶æ€çš„ï¼Œå…·æœ‰å¯æ‰©å±•æ€§ï¼š

- æµ‹è¯•åº”è¯¥ç‹¬ç«‹å¤„ç†å…¶çŠ¶æ€ã€‚
- æ²¡æœ‰å¯¹å¤–éƒ¨äº§ç”Ÿä¸å—æ§åˆ¶çš„å‰¯ä½œç”¨ï¼Œæˆ–è€…å…·æœ‰æµ‹è¯•è‡ªèº«èƒ½å¤Ÿå¤„ç†çš„å¯ç®¡ç†å‰¯ä½œç”¨ã€‚
- æµ‹è¯•åº”è¯¥èƒ½å¤Ÿè¢« *n* ä¸ªå®ä½“åŒæ—¶æ‰§è¡Œã€‚

<br/><br/>

## ä»£ç ç¤ºä¾‹ â€“ è§£é‡Šè¯´æ˜

**å¯é‡å¤æ€§**: æµ‹è¯•å¿…é¡»èƒ½å¤Ÿè®¾ç½®çŠ¶æ€ã€æ‰§è¡Œæµ‹è¯•ï¼Œå¹¶åœ¨ä¸å½±å“ä¸‹ä¸€ä¸ªæµ‹è¯•æ‰§è¡Œçš„å‰æä¸‹ä½¿ç¯å¢ƒä¿æŒå¹²å‡€ã€‚å¦‚æœä¸€ä¸ªæµ‹è¯•åœ¨æ¯æ¬¡æ‰§è¡Œæ—¶éƒ½ä½¿ç³»ç»Ÿæ··ä¹±ï¼Œå°†å…¶ç•™åœ¨æ— æ³•é‡ç½®çš„çŠ¶æ€ï¼Œé‚£ä¹ˆè¿™ä¸ªæµ‹è¯•å°±é€‚åˆä½œä¸ºæ‰‹åŠ¨æµ‹è¯•ã€‚æµ‹è¯•è¿˜ä¸èƒ½äº’ç›¸å†²çªï¼šå¤šä¸ªæµ‹è¯•è€…å’Œæµæ°´çº¿å¿…é¡»èƒ½å¤ŸåŒæ—¶æ‰§è¡Œç›¸åŒçš„æµ‹è¯•ã€‚å¦‚æœè¿™ä¸å¯è¡Œï¼Œè¿™äº›æµ‹è¯•ç»„åº”è¯¥æ¯å¤©åœ¨æµæ°´çº¿ä¸­æ‰§è¡Œä¸€æ¬¡ï¼Œæœ€å¥½åœ¨éå·¥ä½œæ—¶é—´æ‰§è¡Œ [cron ä½œä¸š](https://crontab.guru/#0_1-23_*_*_6-7)ã€‚

æ¯ä¸ªéœ€è¦æ›´æ”¹ç¯å¢ƒçŠ¶æ€çš„æµ‹è¯•éƒ½å¿…é¡»è¢«ç”¨ä½œè®¾ç½® - çŠ¶æ€ - æµ‹è¯•ï¼Œå¹¶ç¡®ä¿åœ¨ä¸‹ä¸€ä¸ªæµ‹è¯•ä¹‹å‰èƒ½å¤Ÿæ¸…ç†æµ‹è¯•ç¯å¢ƒã€‚

æœ€å¥½æ˜¯ UI æµ‹è¯•ä¸è¦é‡å¤ä½œä¸ºè®¾ç½®æµ‹è¯•ï¼›åœ¨å¿…é¡»å°† UI æµ‹è¯•ç”¨ä½œå¦ä¸€ä¸ªæµ‹è¯•çš„è®¾ç½®çš„æƒ…å†µä¸‹ï¼Œåº”è¯¥ä½¿ç”¨ API æµ‹è¯•ã€åº”ç”¨ç¨‹åºæ“ä½œæˆ–æ•°æ®åº“åˆå§‹åŒ–ã€‚

**è®¾ç½® vs æ¸…ç†**: è®¾ç½®ï¼ˆä¹‹å‰å…¨éƒ¨ï¼‰ä¼˜äºæ¸…ç†ï¼ˆä¹‹åå…¨éƒ¨ï¼‰ã€‚åœ¨å¯èƒ½çš„æƒ…å†µä¸‹ï¼Œæµ‹è¯•æœ¬èº«åº”è¯¥è´Ÿè´£åœ¨ä¸€ä¸ªå¹²å‡€çš„ç¯å¢ƒä¸­å¼€å§‹ã€‚ç„¶è€Œï¼Œæ­£å¦‚ä¸Šé¢å¼ºè°ƒçš„ï¼Œæµ‹è¯•ä¸èƒ½ä½¿å¾—åœ¨å®ƒä»¬æ‰§è¡Œåä¸‹ä¸€ä¸ªæµ‹è¯•æ— æ³•æ¸…ç†ç¯å¢ƒã€‚

**ç™»å½•**: UI ç™»å½•çš„å„ç§å½¢å¼åº”ä»…åœ¨å…¶å„è‡ªçš„æµ‹è¯•ç”¨ä¾‹ä¸­ä½¿ç”¨ã€‚ä»»ä½•å…¶ä»–éœ€è¦ç™»å½•çš„æµ‹è¯•åº”è¯¥ä½¿ç”¨å†…éƒ¨çš„ API ç™»å½•å’Œ/æˆ–å…·æœ‰é¢„é…ç½®çš„æµ‹è¯•ç”¨æˆ·ã€‚

**æµ‹è¯•çŠ¶æ€è®¾ç½®**: é¼“åŠ±æµ‹è¯•æ˜¯éš”ç¦»çš„ï¼Œä»¥ä¾¿å®ƒä»¬åœ¨æ‰§è¡Œä¹‹å‰ä¸ä¾èµ–äºæ•´ä¸ªè®¾ç½®ã€‚ä¾‹å¦‚ï¼šå¦‚æœä¸€ç»„æµ‹è¯•å¯èƒ½éœ€è¦åˆ›å»ºç”¨æˆ·ï¼Œå¯ä»¥åˆ©ç”¨ä¸€ä¸ªæµ‹è¯•ç”¨æˆ·åœ¨éš”ç¦»ä¸­ä½¿ç”¨è¿™äº›æµ‹è¯•ã€‚å¦ä¸€æ–¹é¢ï¼Œè®¾ç½®ç”¨æˆ·çš„æµ‹è¯•åº”è¯¥æ˜¯ç‹¬ç«‹çš„å’Œéš”ç¦»çš„ã€‚

**æ¨¡å—åŒ–**: æ¯ä¸ªæµ‹è¯•åº”è¯¥èƒ½å¤Ÿç‹¬ç«‹è¿è¡Œï¼Œä¸ä¾èµ–äºå…¶ä»–æµ‹è¯•æ¥ä¸ºå…¶è®¾ç½®çŠ¶æ€ã€‚å¦‚æœéœ€è¦è¿›è¡Œè¿™æ ·çš„è®¾ç½®ï¼Œåº”è¯¥åœ¨ `beforeAll` æˆ– `beforeEach` éƒ¨åˆ†è¿›è¡Œã€‚æµ‹è¯•è¿™ä¸€ç‚¹çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯åœ¨éš”ç¦»ä¸­è¿è¡Œæµ‹è¯•ï¼š`it.only()`ï¼Œ`fit()`ï¼Œç­‰ç­‰ã€‚

```JavaScript
describe('..', function () {

  // setup (before/beforeEach) is preferred over cleanup (after/afterEach)

  before(function () {
    // login with UI once in an isolated test
    // for login here and all other tests, use a faster login method: use API, App Actions or DB seeding
  });

  beforeEach(function () {
    // setup additional state...
    // have one UI test to ensure this state can be achieved
    // however for the state set up here, utilize API, Application Actions or DB seeding; do not repeat UI tests
  });

    // test each test once with .only to ensure modularity
    it('..', function () {..});
    it('..', function () {..});
    it.only('..', function () {..});
    it('..', function () {..});

});

```

<br/><br/>

## å‚è€ƒèµ„æ–™

[æ”¾å¼ƒä½¿ç”¨é¡µé¢å¯¹è±¡ï¼Œè½¬è€Œä½¿ç”¨åº”ç”¨åŠ¨ä½œ](https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/)

[Cypress æ–‡æ¡£ï¼šæµ‹è¯•ç»„ç»‡ã€ç™»å½•ã€çŠ¶æ€æ§åˆ¶](https://docs.cypress.io/guides/references/best-practices.html#Organizing-Tests-Logging-In-Controlling-State)



================================================
FILE: sections/beginners/top-to-bottom-approach.md
================================================
# Approach the testing pyramid from the top!

<br/>

### One Paragraph Explainer

When you are an experienced tester, approaching a test suite is an easy road.
But learning how to test properly, what to test and what to avoid, which kind of
tests choosing etc. is not so easy.

**Testing is expensive at the beginning**. Everything is new, the examples you
try to implement do not work, you do not understand clearly why the tests fail,
how itâ€™s related to your code, etc.

We all know the Testing Pyramid and commonly, we approach it from the bottom

![Bottom to top approach means starting with the Unit Tests.](../../assets/images/top-to-bottom-approach/bottom-to-top-approach.jpg)
_The standard Testing Pyramid approach: bottom to top._

Approaching the pyramid from the bottom makes sense. Starting with the Unit
Tests is easier because they're fast, they do not require complex contexts or
tools, a "unit" (whatever you mean with "unit": a function, a component, etc.)
contains just a few lines of code and usually it has a few dependencies (or not
at all), etc.

What's the biggest **downside of this approach**? Essentially, its
**confidence**.

Testing is all about confidence and the tradeoff between high-confidence, yet
slow, tests and low-confidence, yet fast, tests.

If you're new to the testing field the term "confidence" could not be clear in
your mind, so: how can you be sure that the **application** you're working on
**works if the tests pass**? This is the **testing confidence**.

Why the Unit Tests give so little confidence? Some examples:

- if the `isValidEmail` function passes the tests, are you sure that the
  registration form of your front-end application works?
- if the `Input` React component passes the tests, are you sure that the
  registration form works too?
- if the whole `RegisterForm` component passes the tests, are you sure that the
  user can register?

The answer is No. A whole application is made of a lot of units integrated each
other, without counting some presentational (CSS) problems that could prevent
the user from registering because of an image with a higherz-index that covers
the submit button.

Speaking again about the missing experience of testing newbies (like I was, two
years ago): **everything new requires a big cognitive load** and you cannot face
too much new stuff at the same time. It's hard to face the usual development of
your app, the new Testing topic, the Unit Tests world and the UI tests one (the
latter two require different tools and efforts).

Take a look at this exhaustive image from the
[JavaScript & Node.js testing best practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
project:

![Mental and time capacity is mainly dedicated to the development phase, a few of them can be dedicated to writing tests.](../../assets/images/top-to-bottom-approach/headspace.jpg)
_Courtesy of [Yoni Goldberg](https://goldbergyoni.com/), visit
[testjavascript.com](https://testjavascript.com/) and add a star to the
[JavaScript & Node.js testing best practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
repository._

This is true for experienced developers, and when you first approach the testing
world things are worse.

## Bottom to top approachÂ results

You inevitably put the most of your attention to the base of the pyramid, the
Unit Tests. The bunch of tests you are going to write allow you becoming
familiar with the testing world, but without confidence. You could find yourself
asking

- "What is the advantage of the tests I wrote?"
- "I spent some time fighting with Unit Tests, but the application breaks like
  before, do the tests end with themselves?"
- "Honestly, I've more doubts now than before starting with testsâ€¦"

![The Testing Pyramid with every kind of tests highlighted with the attention you dedicate them with a bottom to top approach.](../../assets/images/top-to-bottom-approach/unit-testing-first.jpg)
_The bottom to top approach inevitably makes you concentrate on the Unit Tests._

The problem is not with you but with the wrong kind of tests for a beginner!

What's my suggested solution? **Starting from the top and concentrating on UI
tests firstly!**

First of all, what's a UI Test (also called Functional Test, E2E Test, etc.)?
It's essentially a script that opens a real browser and interacts with the DOM
elements, the same way the real end-user does. Some videos could tell more than
hundreds of words: take a look at [an E2E test running against
Conduitâ€Š-â€Šthe RealWorld project](https://www.youtube.com/watch?v=gdly-oU72X0&feature=youtu.be) and [some UI tests of the Conio Backoffice](https://www.youtube.com/watch?v=lNEMKeTYEPI&feature=youtu.be).

In the above videos, you can see a real browser that loads the whole front-end
application and interacts with it. The pros are:

- your application is tested in the same context of the end-user (the browser),
  which means **higher confidence**. Even if you write just one UI Test, it
  gives you more confidence that a hundred Unit Tests
- the path under test (the steps the user does, like "registering", "creating a
  new post", etc.) is the same that the end-user must perform, that means
  **lower cognitive load** (for you) to understand what you are really testing
- honestly, you have more fun automating a browser than automating the terminal
  ğŸ˜
- **UI Testing best fits** the little-to-medium size of most of **the projects
  you work on a daily basis**. From a landing page to a little CMS: all of them
  require at least some UI tests, yet you could overfly on the Unit Tests based
  on the testing confidence and the deliveries you have to respect. Just a few
  of you work at Facebook, Spotify, Netflix, etc., products that require strict
  testing strategies, code coverage requisites, etc. More in general: if you
  work for medium-to-large product companies, you probably do not need this post
  because Testing is at the core of your company's culture ğŸ‰

There are cons too, but I'm going to list them later. That's the approach I
suggest:

![Starting from the top of the testing pyramid allows you to concentrate on UI tests firstly.](../../assets/images/top-to-bottom-approach/ui-testing-first.jpg)
_A top to bottom approach._

### Does the top to bottom approach enforce testing bad practices?

This post is not about best or bad practices (take a look at the end of the post
for a long list of resources), this post is about engaging new front-end
developers profitably in the testing world. My goal is to provide a more
practical approach, an approach that allows the developer to **enjoy the testing
advantages** and do not leave him with more doubts than before.

### If UI Testing is so magical, why other kinds of testsÂ exist?

That's the point! And please, note that I'm not against Unit Testing! Every kind
of test is important and **different tests provide different feedback**! A
developer that approaches the pyramid from the top is enough happy to love the
whole testing world.

Then, you are going to discover the limitations of the high-level **UI tests**:

- they **are slow**: I know that the above videos give you the idea that they're
  super fast but they are not. They are fast when you have five, ten, twenty of
  them, but when you have hundreds of UI tests and they need minutes, you start
  asking yourself how you can improve the situation
- they give you mostly **high-level feedback**: if the submit button of the form
  does not work, what's the bug? There are a ton of possible causes but the UI
  Test does not allow to exclude some of them
- they render the whole app and it could be cumbersome if you just want to test
  something smaller. Some corner cases that you need to test are not replicable
  at all through the whole app

The solution to all the above problems is: **going down with the Testing
Pyramid**! And if you reach the need for lower tests, well done! It's the goal
of this post!

Consider the result of both approaches:

- bottom to top: **you have doubts** about the usefulness of the unit tests you
  write and you do not understand how these tests could help you improve the
  testing confidence
- top to bottom: you have a **few, confident, tests** and you end up with the
  need to get down the Testing Pyramid. And if you do not need to get it down,
  it means that your project is small and it does not need any more tests

Then, start from the [root of this project](../../README.md) and explore the various best practices to follow to start with UI Testing successfully since the very beginning.



================================================
FILE: sections/beginners/top-to-bottom-approach.zh.md
================================================
[Binary file]


================================================
FILE: sections/generic-best-practices/await-dont-sleep.md
================================================
# Await, don't sleep

<br/><br/>

### One Paragraph Explainer

When testing your UI, you define a sort of key points the app must pass through. Reaching these key
points is an asynchronous process because, almost 100% of the times, your UI does not update
synchronously.

Those key points are called **deterministic events**, as known as something that you know that must happen.

It depends on the events you define and how your UI reaches them but, usually, there are some
"long" waitings, like XHR requests, and some faster ones, like re-render updates.

The solution to the asynchronous updates seems handy: **sleeping/pausing the test** for a bunch of
milliseconds, tenths of a second, or even seconds. It can make your test working because it gives
the app the time to update itself and moving to the next deterministic event to be tested.

Consider that, except for specific and known waitings (like when you use `setInterval` or
`setTimeout`), **it's totally unpredictable** how much the sleeping time should be because it could depend on:

- the network state (for XHR requests)
- the total amount of available machine resources (CPU, RAM, etc.)
  - a CI pipeline can limit them for example
  - other apps can consume them on your local machine too
- the concurrence of other resource-consuming updates (canvas, etc.)
- a bunch of unpredictable game players like Service Workers, cache management etc. that can make
  the UI update process faster or slower

Every fixed delay leads your test to be more brittle and **increasing its duration**. You are going to
find a balance between false negativesâ€”when the test fails because of a too low sleeping
timeâ€”and exaggerate test duration.

What about waiting just the right amount of time? The amount of time that makes the test as fast as
possible!

Waitings fall in four main categories

- **[page load waitings](#page-load-waitings)**: the first waiting to manage while testing your app, waiting for an event that
  allows you to understand that the page is interactive
- **[content waitings](#content-waitings)**: waiting for DOM element that matches a selector
- **[XHR request waitings](#xhr-request-waitings)**: waiting for an XHR request start or the corresponding response received

All the following examples are based on Cypress.

<br/><br/>

## Page load waitings

```javascript
// Cypress code
cy.visit('http://localhost:3000')
```

## Content waitings

Take a look at the following examples to see how waiting for a DOM element could be implemented in
the available tools.

### Code Examples

- waiting for an element:

```javascript
// Cypress code

// it waits up to 4 seconds by default
cy.get('#form-feedback')
// the timeout can be customized
cy.get('#form-feedback', { timeout: 5000 })
```

- waiting for an element with specific content

```javascript
// Cypress code

cy.get('#form-feedback').contains('Success')
```

## XHR request waitings

### Code Examples

- waiting for an XHR request/response

```javascript
// Cypress code

cy.intercept('http://dummy.restapiexample.com/api/v1/employees').as('employees')
cy.wait('@employees')
  .its('response.body')
  .then((body) => {
    /* ... */
  })
```

<br /><br />

_Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/await-do-not-make-your-e2e-tests-sleep-4g1o) and [Medium](https://medium.com/@NoriSte/react-hooks-memorandum-bf1c2758a672)._



================================================
FILE: sections/generic-best-practices/await-dont-sleep.zh.md
================================================
[Binary file]


================================================
FILE: sections/generic-best-practices/name-test-files-wisely.md
================================================
# Name the test files wisely

<br/><br/>

### One Paragraph Explainer

You can write a lot of different UI tests and it's a good habit to have a common way of naming the
test files.

It's useful because often you need to run just a type of tests, the situations could be:
- during the development process, you need to run just some of them
  - you're changing some related components and you need to check that the generated markup does not change
  - you're changing a global CSS rule and you need to run only the visual tests
  - you're changing an app flow and you need to run the whole app integration tests
- your DevOps colleague needs to be sure that everything is up and running and the easiest way to do
  that is launching just the E2E tests
- your building pipeline needs to run just the integration and E2E tests
- your monitoring pipeline needs a script to launch the E2E and monitoring tests

If you name your tests wisely, it will be really easy to launch just some kind of them.

Cypress:
```bash
cypress run --spec \"cypress/integration/**/*.e2e.*\"
```

Jest:
```bash
jest --testPathPattern=e2e\\.*$
```

<br>

A global way to name the test files does not exist, a suggestion could be to name them with:
- the subject you are testing
- the kind of test (`integration`, `e2e`, `monitoring`, `component`, etc.)
- the test suffix of choice (`test`, `spec`, etc.)
- the file extension (`.js`, `.ts`, `.jsx`, `.tsx`, etc.)

all of them separated by a period.

Some examples could be
- `authentication.e2e.test.ts`
- `authentication.integration.test.ts`
- `site.monitoring.test.js`
- `login.component.test.tsx`
etc.



================================================
FILE: sections/generic-best-practices/name-test-files-wisely.zh.md
================================================
# æ˜æ™ºåœ°ä¸ºæµ‹è¯•æ–‡ä»¶å‘½å

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

ç¼–å†™å„ç§ä¸åŒçš„ UI æµ‹è¯•æ˜¯ä¸€ç§å¥½ä¹ æƒ¯ï¼Œè€Œé‡‡ç”¨ä¸€ç§å¸¸è§çš„æµ‹è¯•æ–‡ä»¶å‘½åæ–¹å¼æ›´æ˜¯æœ‰ç›Šçš„ã€‚

è¿™å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºé€šå¸¸æƒ…å†µä¸‹ï¼Œä½ éœ€è¦ä»…è¿è¡ŒæŸä¸€ç±»æµ‹è¯•ï¼Œå¯èƒ½çš„æƒ…å†µåŒ…æ‹¬ï¼š

- åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä½ åªéœ€è¦è¿è¡Œå…¶ä¸­ä¸€äº›æµ‹è¯•
  - ä½ æ­£åœ¨æ›´æ”¹ä¸€äº›ç›¸å…³ç»„ä»¶ï¼Œå¹¶éœ€è¦æ£€æŸ¥ç”Ÿæˆçš„æ ‡è®°æ˜¯å¦å‘ç”Ÿäº†å˜åŒ–
  - ä½ æ­£åœ¨æ›´æ”¹å…¨å±€ CSS è§„åˆ™ï¼Œåªéœ€è¿è¡Œè§†è§‰æµ‹è¯•
  - ä½ æ­£åœ¨æ›´æ”¹åº”ç”¨ç¨‹åºæµç¨‹ï¼Œéœ€è¦è¿è¡Œæ•´ä¸ªåº”ç”¨ç¨‹åºé›†æˆæµ‹è¯•
- ä½ çš„ DevOps åŒäº‹éœ€è¦ç¡®ä¿ä¸€åˆ‡æ­£å¸¸è¿è¡Œï¼Œæœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯åªè¿è¡Œç«¯å¯¹ç«¯æµ‹è¯•
- ä½ çš„æ„å»ºæµæ°´çº¿éœ€è¦è¿è¡Œé›†æˆæµ‹è¯•å’Œç«¯å¯¹ç«¯æµ‹è¯•
- ä½ çš„ç›‘æ§æµæ°´çº¿éœ€è¦ä¸€ä¸ªè„šæœ¬æ¥è¿è¡Œç«¯å¯¹ç«¯æµ‹è¯•å’Œç›‘æ§æµ‹è¯•

å¦‚æœä½ ä¸ºæµ‹è¯•å–ä¸€ä¸ªæ˜æ™ºçš„å‘½åï¼Œå°†ä¼šéå¸¸å®¹æ˜“åªè¿è¡Œå…¶ä¸­çš„æŸäº›ç±»å‹ã€‚

Cypress:

```bash
cypress run --spec \"cypress/integration/**/*.e2e.*\"
```

Jest:

```bash
jest --testPathPattern=e2e\\.*$
```

<br>

æ²¡æœ‰ä¸€ç§å…¨å±€çš„å‘½åæµ‹è¯•æ–‡ä»¶çš„æ–¹å¼ï¼Œä¸€ä¸ªå»ºè®®æ˜¯ä½¿ç”¨ä»¥ä¸‹æ–¹å¼å‘½åï¼š

- æ­£åœ¨æµ‹è¯•çš„ä¸»é¢˜
- æµ‹è¯•çš„ç±»å‹ï¼ˆ`integration`ã€`e2e`ã€`monitoring`ã€`component`ç­‰ï¼‰
- é€‰æ‹©çš„æµ‹è¯•åç¼€ï¼ˆ`test`ã€`spec`ç­‰ï¼‰
- æ–‡ä»¶æ‰©å±•åï¼ˆ`.js`ã€`.ts`ã€`.jsx`ã€`.tsx`ç­‰ï¼‰

å®ƒä»¬ä¹‹é—´ç”¨å¥ç‚¹åˆ†éš”ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›ä¾‹å­ï¼š

- `authentication.e2e.test.ts`
- `authentication.integration.test.ts`
- `site.monitoring.test.js`
- `login.component.test.tsx`
ç­‰ç­‰ã€‚



================================================
FILE: sections/generic-best-practices/reaching-ui-state.md
================================================
# Reaching UI state for tests without using the UI

<br/><br/>

### One Paragraph Explainer

It adds value to cover a UI scenario *once*, and it provides little value to duplicate any parts of it in other tests; tests which may require a relevant state of the system. Suppose in a new test you require a state, and that state -partially or in full- duplicates testing from a UI test. Scenarios like this are excellent for utilizing certain techniques:

* Direct navigation
* Network stub record & play
* Application actions
* Seeding the database

> Disclaimer: applications of the whole package of these techniques are only possible in Cypress (as far as we know), consequently the code samples below are are in Cypress context.

<br/><br/>

### Direct navigation

This is the easiest technique and is applicable in any framework. Suppose the intent of the test is concerned with a certain page in your application. Instead of click navigating, directly visit the URL. Upon landing you can either wait for a UI element (any test framework) or network calls (some test frameworks), or both.

```javascript
// Test A covers click-navigation to a certain page.
// This is Test B, and navigating to that page is the prerequisite step.

// assuming baseUrl is set in cypress.json or config file
// directly navigate to the page.
cy.visit('/endpoint');

// to ensure stability, wait for network (preferred), ui elements, or both

// note: checking the endpoint you are at is entirely optional, only for sanity that you are at the right page
cy.url().should('contain', 'endpoint');
// cy.url().should('match', /endpoint/); // there are many, some more complex, ways of doing it


// network wait: this is in addition to the sanity url check, and it is more important
// because you want the page to "settle" before you start running assertions on it

// usually a GET request. Is aliased so we can wait for it.
cy.intercept('some-xhr-call-that-happens-upon-landing').as('crutcXHR');
// The default Cypress timeout is 4 seconds. 15 seconds here is arbitrary.
// Most pages load faster, but if you need more time then increase the timeout.
// The only caveat to increasing timeout is that the tests will take longer to fail, but still run as fast as possible when things work.
cy.wait('@crutchXHR', {timeout: 15000});

// ui-element wait is straightforward, and may be optional, as well as less stable)
cy.get('element-on-page').should('exist').and('be.visible');

```

#### Pro vs Con

Pro: not having to click-navigate saves time in tests and saves effort in test maintenance.

Con: this technique ignores the user E2E way of clicking through the application. Make sure you have at least one workflow in any other test that covers the same workflow of click-navigation to ensure that click-navigation functionality is regression-proof. Usually click-navigation could be a test of its own; and when setting up state in other tests, you do not repeat the UI-test that is already covered elsewhere. The thought pattern is analogous to login; if you do UI-login in one test, in the others you can implement programmatic login which is both fast and cost effective.

<br/><br/>

### Application actions

Cypress gives you complete control of your application. You can bypass the page object abstraction layer (which is detached from your application), access the UI directly via `cy.get()`, have access to the API, database, and even access the source code.

Application actions are shortcuts that allow you to access internal utilities in order to save time. A simple example could be a `cy.signup()` custom command that goes to the registration form and invokes the callback of the registration form instead of filling the form and clicking the registration button.

Here is a quick example of how you would allow source code access to Cypress in an Angular application.
```javascript
// Angular Component file example
/* setup:
 1. Identify the component in the DOM;
  inspect and find the corresponding <app.. tag,

 2. Right in the constructor of your component, insert conditional */
constructor(
  /* ... */
) {
  /* if running inside Cypress tests, set the component
  may need // @ts-ignore initially */
  if (window.Cypress) {
    window.yourComponent = this;
  }
}

// at ../../support/app-actions.ts helper file:

/** yields  window.yourComponent */
export const yourComponent = () =>
  cy.window().should('have.property', 'yourComponent');

/** yields the data property on your component */
export const getSomeListData = () =>
 yourComponent().should('have.property', 'data');
```
After this at DevTools see what that component allows for properties, or in the component code see what functions you can .invoke()

Check out [the presentation slide](https://cypress.slides.com/cypress-io/siemens-case-study#/12/3/4) for a code sample utilizing app actions with visual testing.

#### Another example on app actions utilizing states, using [Building Operator](https://new.siemens.com/us/en/products/buildingtechnologies/automation/talon/software/building-operator.html?stc=ussi100451&sp_source=ussi100451&&s_kwcid=AL!464!3!435315652461!b!!g!!%2Bbuilding%20%2Boperator&ef_id=CjwKCAjw8df2BRA3EiwAvfZWaAsQmgot5Ph-nGBB8rW1QLLr870q2HW-qzMKhqtQb1QvlPBVJxho5BoCmtMQAvD_BwE:G:s) building control product of Siemens.

In the below state diagram there are 3 states. We begin where both left and right panes exist. If the right pane is deleted (delete point / red flow), only the left pane exists. If the left pane is deleted (delete device - blue flow), both panes go away and the UI is redirected.

![deleting building points and controllers](../../assets/images/ui-state/delete-states.PNG)

Testing the UI, you might chose to delete the right pane (red flow) and then in another test you might choose to delete the left pane (blue flow). This leaves out 1 final path through the state diagram where right pane and then left pane are deleted one at a time.

We already covered deleting the right pane in a UI test (red path). Why not avoid repeating this test and utilize app actions, getting access to the delete function in the source code and using `cy.invoke()` to call it?

```javascript
it('Component test: delete right pane and then left', () => {
  /* tests a SEQUENCE not covered with UI tests
   * tests a COMBINATION of components */
  appAction.deleteRightPane();
  cy.window().should('not.have.property', 'rightPaneComponent');
  cy.window().should('have.property', 'leftPaneComponent');

  appAction.deleteLeftPane();
  cy.window().should('not.have.property', 'leftPaneComponent');
  cy.window().should('not.have.property', 'rightPaneComponent');
  cy.url().should('match', redirectRoute);
});
```

#### Pro vs Con

Using applications actions / having component access is fast! The tests are less prone to changes. Generally this is the benefit of testing at lower level. Alas, it can get addictive to engineers and testing the user interface starts getting neglected; the pro can become a con.

There are a few counter arguments against application it. Developers may be opinionated that Cypress' access to the source code isn't ideal. There is a not a counter argument to this until Cypress has official component testing support.

The real power of application actions comes out when combining application actions with other techniques; not duplicating the UI workflow to setup a state, combining component testing with visual testing, combining component testing with network manipulation are where this approach shines.


<br/><br/>


### Network stub record & play
This is an advanced technique that strongly relates to UI-integration tests. Recall UI-integration references [1](../testing-strategy/component-vs-integration-vs-e2e-testing.md), [2](../real-life-examples/test-front-end-with-integration-back-end-with-e2e.md).

Cypress allows you to stub all network traffic. We can record the network data from an endpoint, and stub that response every time the UI makes a call to an arbitrary server.

Start by copying the network data from devTools to a json file. Place it in `cypress/fixtures` folder. This folder is made for this purpose, and any reference to it will default to the root of the folder.

![devtools > network tab](../../assets/images/ui-state/devtools-network.PNG)

```javascript
// prerequisite: the data has been copied to a file `cypress/fixtures/agents.json`

// this is a shorthand for cy.fixture(). More at https://docs.cypress.io/api/commands/fixture.html#Accessing-Fixture-Data
cy.intercept('some-xhr-call-that-happens-upon-landing', { fixture: 'agents.json'} ).as('crutcXHR');
// all calls to the network route will be stubbed by the data in agents.json file
```

#### What if there are so many network requests happening?
Where do we get all our mocks for fixtures? We do not want to manually copy and save them. We want to record them as the test runs against a real API

There are at least 2 Cypress plugins you can utilize for this [1](https://github.com/Nanciee/cypress-autorecord) & [2](https://github.com/scottschafer/cypressautomocker).

If these do not work for you, you can easily create record and playback utilities yourself with these 3 functions.

```javascript
function stubRecorder(pathToJson) {
  const xhrData = []; // an empty array to hold the data
  cy.server({ // if recording, save the response data in the array
    onResponse: (response) => {
      const url = response.url;
      const method = response.method;
      const data = response.response.body;
      // We push a new entry into the xhrData array
      xhrData.push({ url, method, data });
    }
  });

  // cy.intercept() specification below is used as a selector for the data you want to record.
  // In this example, all GET requests from any url will be selected
  // You can specify the methods and routes that are recorded
  cy.log('recording!');
  cy.intercept({
    method: 'GET',
    url: '*',
  });

  // if recording, after the test runs, create a fixture file with the recorded data
  after(function () {
    cy.writeFile(`./cypress/fixtures/${pathToJson}.json`, xhrData);
    cy.log(`Wrote ${xhrData.length} XHR responses to local file ${pathToJson}.json`);
  });
}

/** Plays recorded fixture with all required network data as json*/
function playStubbedFixture(stateFixture) {
  cy.log(`playing fixture from ${stateFixture}`);
  cy.fixture(stateFixture, { timeout: 15000 }) // the fixture file may be large and take time in CI
    .each(({method, url, data}) => {
      cy.intercept(method, url, data);
    }).as(`stateFixture_stub`);
}

/** Visits the stubbed state */
function visitStubbedState(stubFile, url, wait: boolean = true) {
  playStubbedFixture(stubFile);
  cy.visit(url);
  if (wait) { // sometimes you do not want to wait for network, this gives you the option
    cy.wait('@stateFixture_stub', { timeout: 15000 });
  }
}

//////////
// usage

// recording network
it('should run your test', function () {
  stubrecorder('jsonfileNameForNetworkData');

  // your original test

  cy.wait(5000); // one-time wait so that the after() step records all the network without missing anything

  // the rest of your original test
});

// playing the stubbed network
it('should run your test', function () {
  // every time we visit this endpoint, all network will be stubbed
  // double check this by observing (XHR stubbed) network responses in the test runner
  visitStubbedState('jsonfileNameForNetworkData', '/endpoint');

  // the rest of your original test
});
```

#### Pro vs Con

UI integration tests are the bread and butter of UI testing. They run the whole app in a real browser without hitting a real server. They are blazing fast and less exposed to random failures in the network or false negatives.

The engineers have to realize that the strength can be a curse if misused. The UI application is isolated, but network failures, if there are any, are ignored. It is great for feature branch testing, but in further deployments one should ensure that the back-end is also operational. Refer to [test-front-end-with-integration-back-end-with-e2e](../real-life-examples/test-front-end-with-integration-back-end-with-e2e.md) for when to use which technique.

<br/><br/>


### Seeding the database

Cypress [`cy.task()`](https://docs.cypress.io/api/commands/task.html#Requirements) is very powerful. Effectively, it allows you to use NodeJs within the context of Cypress. This can be anything from NodeJs code, to using an npm package to manipulating the database. If you use Node.js for your app, you can re-use your app code to help set up and manipulate data for your tests.

There is a [Cypress recipe](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/server-communication__seeding-database-in-node) on this topic and we will end with that reference.


## Related chapters

- ğŸ”— [From unreadable React Component Tests to simple, stupid ones](/sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md)



================================================
FILE: sections/generic-best-practices/reaching-ui-state.zh.md
================================================
# åœ¨æµ‹è¯•ä¸­è¾¾åˆ° UI çŠ¶æ€è€Œæ— éœ€ä½¿ç”¨ UI

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

åœ¨ UI åœºæ™¯ä¸­è¦†ç›–ä¸€æ¬¡æ˜¯æœ‰ä»·å€¼çš„ï¼Œè€Œåœ¨å…¶ä»–æµ‹è¯•ä¸­å¤åˆ¶å…¶ä¸­ä»»ä½•éƒ¨åˆ†æä¾›çš„ä»·å€¼å¾ˆå°ï¼›è¿™äº›æµ‹è¯•å¯èƒ½éœ€è¦ç³»ç»Ÿçš„ç›¸å…³çŠ¶æ€ã€‚å‡è®¾åœ¨ä¸€ä¸ªæ–°æµ‹è¯•ä¸­ï¼Œä½ éœ€è¦ä¸€ç§çŠ¶æ€ï¼Œè€Œé‚£ç§çŠ¶æ€ - éƒ¨åˆ†æˆ–å…¨éƒ¨ - ä¸ UI æµ‹è¯•ä¸­çš„æŸäº›éƒ¨åˆ†é‡å¤ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹å‡ ç§æŠ€æœ¯ï¼š

* ç›´æ¥å¯¼èˆª
* ç½‘ç»œå­˜æ ¹è®°å½•å’Œæ’­æ”¾
* åº”ç”¨ç¨‹åºåŠ¨ä½œ
* æ•°æ®åº“ç§å­

> å…è´£å£°æ˜ï¼šæ•´ä¸ªæŠ€æœ¯åŒ…çš„åº”ç”¨ä»…åœ¨ Cypress ä¸­å¯èƒ½ï¼ˆæ®æˆ‘ä»¬æ‰€çŸ¥ï¼‰ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ç¤ºä¾‹æ˜¯åœ¨ Cypress ä¸Šä¸‹æ–‡ä¸­ã€‚

<br/><br/>

## ç›´æ¥å¯¼èˆª

è¿™æ˜¯æœ€ç®€å•çš„æŠ€æœ¯ï¼Œé€‚ç”¨äºä»»ä½•æ¡†æ¶ã€‚å‡è®¾æµ‹è¯•çš„æ„å›¾ä¸ä½ çš„åº”ç”¨ç¨‹åºä¸­çš„æŸä¸ªé¡µé¢æœ‰å…³ã€‚ä¸å…¶è¿›è¡Œç‚¹å‡»å¯¼èˆªï¼Œç›´æ¥è®¿é—® URLã€‚ä¸€æ—¦åˆ°è¾¾ï¼Œä½ å¯ä»¥ç­‰å¾… UI å…ƒç´ ï¼ˆä»»ä½•æµ‹è¯•æ¡†æ¶ï¼‰æˆ–ç½‘ç»œè°ƒç”¨ï¼ˆä¸€äº›æµ‹è¯•æ¡†æ¶ï¼‰ï¼Œæˆ–ä¸¤è€…å…¼è€Œæœ‰ä¹‹ã€‚

```javascript
// Test A covers click-navigation to a certain page.
// This is Test B, and navigating to that page is the prerequisite step.

// assuming baseUrl is set in cypress.json or config file
// directly navigate to the page.
cy.visit('/endpoint');

// to ensure stability, wait for network (preferred), ui elements, or both

// note: checking the endpoint you are at is entirely optional, only for sanity that you are at the right page
cy.url().should('contain', 'endpoint');
// cy.url().should('match', /endpoint/); // there are many, some more complex, ways of doing it


// network wait: this is in addition to the sanity url check, and it is more important
// because you want the page to "settle" before you start running assertions on it

// usually a GET request. Is aliased so we can wait for it.
cy.intercept('some-xhr-call-that-happens-upon-landing').as('crutcXHR');
// The default Cypress timeout is 4 seconds. 15 seconds here is arbitrary.
// Most pages load faster, but if you need more time then increase the timeout.
// The only caveat to increasing timeout is that the tests will take longer to fail, but still run as fast as possible when things work.
cy.wait('@crutchXHR', {timeout: 15000});

// ui-element wait is straightforward, and may be optional, as well as less stable)
cy.get('element-on-page').should('exist').and('be.visible');

```

### ç›´æ¥å¯¼èˆªçš„ä¼˜ç¼ºç‚¹

ä¼˜ç‚¹ï¼šä¸è¿›è¡Œç‚¹å‡»å¯¼èˆªå¯ä»¥èŠ‚çœæµ‹è¯•æ—¶é—´ï¼Œå¹¶å‡å°‘æµ‹è¯•ç»´æŠ¤çš„å·¥ä½œé‡ã€‚

ç¼ºç‚¹ï¼šè¿™ç§æŠ€æœ¯å¿½ç•¥äº†ç”¨æˆ·é€šè¿‡åº”ç”¨ç¨‹åºçš„ç«¯åˆ°ç«¯ç‚¹å‡»æ–¹å¼ã€‚ç¡®ä¿åœ¨å…¶ä»–æµ‹è¯•ä¸­è‡³å°‘æœ‰ä¸€ä¸ªå·¥ä½œæµç¨‹è¦†ç›–ä¸ç‚¹å‡»å¯¼èˆªç›¸åŒçš„å·¥ä½œæµç¨‹ï¼Œä»¥ç¡®ä¿ç‚¹å‡»å¯¼èˆªåŠŸèƒ½ä¸ä¼šå‡ºç°å›å½’é—®é¢˜ã€‚é€šå¸¸ï¼Œç‚¹å‡»å¯¼èˆªå¯ä»¥æˆä¸ºä¸€ä¸ªç‹¬ç«‹çš„æµ‹è¯•ï¼›åœ¨è®¾ç½®å…¶ä»–æµ‹è¯•çš„çŠ¶æ€æ—¶ï¼Œä¸è¦é‡å¤å·²ç»åœ¨å…¶ä»–åœ°æ–¹è¦†ç›–çš„ UI æµ‹è¯•ã€‚æ€è€ƒæ¨¡å¼ç±»ä¼¼äºç™»å½•ï¼›å¦‚æœåœ¨ä¸€ä¸ªæµ‹è¯•ä¸­è¿›è¡Œ UI ç™»å½•ï¼Œåœ¨å…¶ä»–æµ‹è¯•ä¸­å¯ä»¥å®ç°ç¨‹åºåŒ–ç™»å½•ï¼Œè¿™æ—¢å¿«é€Ÿåˆç»æµã€‚

<br/><br/>

## åº”ç”¨ç¨‹åºæ“ä½œ

Cypress ä¸ºä½ æä¾›äº†å¯¹åº”ç”¨ç¨‹åºçš„å®Œå…¨æ§åˆ¶æƒã€‚ä½ å¯ä»¥ç»•è¿‡é¡µé¢å¯¹è±¡çš„æŠ½è±¡å±‚ï¼ˆä¸ä½ çš„åº”ç”¨ç¨‹åºåˆ†ç¦»ï¼‰ï¼Œé€šè¿‡ `cy.get()` ç›´æ¥è®¿é—® UIï¼Œè¿˜å¯ä»¥è®¿é—® APIã€æ•°æ®åº“ï¼Œç”šè‡³å¯ä»¥è®¿é—®æºä»£ç ã€‚

åº”ç”¨ç¨‹åºæ“ä½œæ˜¯ä¸€ç§å¿«æ·æ–¹å¼ï¼Œå…è®¸ä½ è®¿é—®å†…éƒ¨å·¥å…·ä»¥èŠ‚çœæ—¶é—´ã€‚ä¸€ä¸ªç®€å•çš„ä¾‹å­å¯ä»¥æ˜¯ä¸€ä¸ª `cy.signup()` è‡ªå®šä¹‰å‘½ä»¤ï¼Œè¯¥å‘½ä»¤è¿›å…¥æ³¨å†Œè¡¨å•å¹¶è°ƒç”¨æ³¨å†Œè¡¨å•çš„å›è°ƒï¼Œè€Œä¸æ˜¯å¡«å†™è¡¨å•å¹¶ç‚¹å‡»æ³¨å†ŒæŒ‰é’®ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¿«é€Ÿç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†åœ¨ Angular åº”ç”¨ç¨‹åºä¸­å¦‚ä½•å…è®¸ Cypress è®¿é—®æºä»£ç ã€‚

```javascript
// Angular Component file example
/* setup:
 1. Identify the component in the DOM;
  inspect and find the corresponding <app.. tag,

 2. Right in the constructor of your component, insert conditional */
constructor(
  /* ... */
) {
  /* if running inside Cypress tests, set the component
  may need // @ts-ignore initially */
  if (window.Cypress) {
    window.yourComponent = this;
  }
}

// at ../../support/app-actions.ts helper file:

/** yields  window.yourComponent */
export const yourComponent = () =>
  cy.window().should('have.property', 'yourComponent');

/** yields the data property on your component */
export const getSomeListData = () =>
 yourComponent().should('have.property', 'data');
```

åœ¨è¿™ä¹‹åï¼Œåœ¨ DevTools ä¸­æŸ¥çœ‹è¯¥ç»„ä»¶å…è®¸çš„å±æ€§ï¼Œæˆ–è€…åœ¨ç»„ä»¶ä»£ç ä¸­æŸ¥çœ‹ä½ å¯ä»¥ä½¿ç”¨ `.invoke()` è¿›è¡Œçš„å‡½æ•°ã€‚

å¯ä»¥æŸ¥çœ‹ [æ¼”ç¤ºå¹»ç¯ç‰‡](https://cypress.slides.com/cypress-io/siemens-case-study#/12/3/4) è·å–ä¸€ä¸ªä½¿ç”¨åº”ç”¨ç¨‹åºæ“ä½œè¿›è¡Œè§†è§‰æµ‹è¯•çš„ä»£ç ç¤ºä¾‹ã€‚

### å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºæ“ä½œçš„ç¤ºä¾‹ï¼Œåˆ©ç”¨çŠ¶æ€ï¼Œä½¿ç”¨ Siemens çš„ [Building Operator](https://new.siemens.com/us/en/products/buildingtechnologies/automation/talon/software/building-operator.html?stc=ussi100451&sp_source=ussi100451&&s_kwcid=AL!464!3!435315652461!b!!g!!%2Bbuilding%20%2Boperator&ef_id=CjwKCAjw8df2BRA3EiwAvfZWaAsQmgot5Ph-nGBB8rW1QLLr870q2HW-qzMKhqtQb1QvlPBVJxho5BoCmtMQAvD_BwE:G:s) Siemens çš„å»ºç­‘æ§åˆ¶äº§å“

åœ¨ä¸‹é¢çš„çŠ¶æ€å›¾ä¸­æœ‰ 3 ä¸ªçŠ¶æ€ã€‚æˆ‘ä»¬ä»å·¦å³ä¸¤ä¸ªçª—æ ¼éƒ½å­˜åœ¨çš„åœ°æ–¹å¼€å§‹ã€‚å¦‚æœåˆ é™¤å³çª—æ ¼ï¼ˆåˆ é™¤ç‚¹/çº¢è‰²æµï¼‰ï¼Œåˆ™åªå‰©ä¸‹å·¦çª—æ ¼ã€‚å¦‚æœåˆ é™¤å·¦çª—æ ¼ï¼ˆåˆ é™¤è®¾å¤‡ - è“è‰²æµï¼‰ï¼Œä¸¤ä¸ªçª—æ ¼éƒ½æ¶ˆå¤±ï¼Œå¹¶ä¸” UI è¢«é‡å®šå‘ã€‚

![åˆ é™¤å»ºç­‘ç‚¹å’Œæ§åˆ¶å™¨](../../assets/images/ui-state/delete-states.PNG)

åœ¨æµ‹è¯• UI æ—¶ï¼Œä½ å¯èƒ½é€‰æ‹©åˆ é™¤å³çª—æ ¼ï¼ˆçº¢è‰²æµï¼‰ï¼Œç„¶ååœ¨å¦ä¸€ä¸ªæµ‹è¯•ä¸­ï¼Œä½ å¯èƒ½é€‰æ‹©åˆ é™¤å·¦çª—æ ¼ï¼ˆè“è‰²æµï¼‰ã€‚è¿™é—æ¼äº†é€šè¿‡çŠ¶æ€å›¾çš„æœ€åä¸€æ¡è·¯å¾„ï¼Œå…¶ä¸­å³çª—æ ¼å’Œå·¦çª—æ ¼è¢«é€ä¸€åˆ é™¤ã€‚

æˆ‘ä»¬å·²ç»åœ¨ä¸€ä¸ª UI æµ‹è¯•ä¸­æ¶µç›–äº†åˆ é™¤å³çª—æ ¼ï¼ˆçº¢è‰²è·¯å¾„ï¼‰ã€‚ä¸ºä»€ä¹ˆä¸é¿å…é‡å¤è¿›è¡Œæ­¤æµ‹è¯•ï¼Œåˆ©ç”¨åº”ç”¨ç¨‹åºæ“ä½œï¼Œè·å–æºä»£ç ä¸­çš„åˆ é™¤å‡½æ•°ï¼Œå¹¶ä½¿ç”¨ `cy.invoke()` è°ƒç”¨å®ƒå‘¢ï¼Ÿ

```javascript
it('Component test: delete right pane and then left', () => {
  /* tests a SEQUENCE not covered with UI tests
   * tests a COMBINATION of components */
  appAction.deleteRightPane();
  cy.window().should('not.have.property', 'rightPaneComponent');
  cy.window().should('have.property', 'leftPaneComponent');

  appAction.deleteLeftPane();
  cy.window().should('not.have.property', 'leftPaneComponent');
  cy.window().should('not.have.property', 'rightPaneComponent');
  cy.url().should('match', redirectRoute);
});
```

### åº”ç”¨ç¨‹åºæ“ä½œçš„ä¼˜ç¼ºç‚¹

ä½¿ç”¨åº”ç”¨ç¨‹åºæ“ä½œ/æ‹¥æœ‰ç»„ä»¶è®¿é—®é€Ÿåº¦å¾ˆå¿«ï¼æµ‹è¯•ä¸å¤ªå®¹æ˜“å—åˆ°å˜åŒ–çš„å½±å“ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™æ˜¯åœ¨è¾ƒä½çº§åˆ«è¿›è¡Œæµ‹è¯•çš„å¥½å¤„ã€‚ç„¶è€Œï¼Œå¯¹äºå·¥ç¨‹å¸ˆè€Œè¨€ï¼Œè¿™å¯èƒ½ä¼šå˜å¾—è®©äººä¸Šç˜¾ï¼Œå¼€å§‹å¿½è§†å¯¹ç”¨æˆ·ç•Œé¢çš„æµ‹è¯•ï¼›ä¼˜åŠ¿å¯èƒ½å˜æˆåŠ£åŠ¿ã€‚

æœ‰ä¸€äº›åå¯¹åº”ç”¨ç¨‹åºçš„è®ºç‚¹ã€‚å¼€å‘äººå‘˜å¯èƒ½è®¤ä¸º Cypress å¯¹æºä»£ç çš„è®¿é—®ä¸ç†æƒ³ã€‚åœ¨ Cypress å…·æœ‰å®˜æ–¹ç»„ä»¶æµ‹è¯•æ”¯æŒä¹‹å‰ï¼Œè¿™æ²¡æœ‰åé©³çš„ç†ç”±ã€‚

åº”ç”¨ç¨‹åºæ“ä½œçš„çœŸæ­£å¨åŠ›åœ¨äºå°†åº”ç”¨ç¨‹åºæ“ä½œä¸å…¶ä»–æŠ€æœ¯ç»“åˆä½¿ç”¨æ—¶æ˜¾ç°å‡ºæ¥ï¼›ä¸é‡å¤ UI å·¥ä½œæµç¨‹æ¥è®¾ç½®çŠ¶æ€ï¼Œå°†ç»„ä»¶æµ‹è¯•ä¸è§†è§‰æµ‹è¯•ç»“åˆä½¿ç”¨ï¼Œå°†ç»„ä»¶æµ‹è¯•ä¸ç½‘ç»œæ“ä½œç»“åˆä½¿ç”¨ï¼Œè¿™äº›éƒ½æ˜¯è¿™ç§æ–¹æ³•çš„äº®ç‚¹æ‰€åœ¨ã€‚

<br/><br/>

## ç½‘ç»œå­˜æ ¹è®°å½•å’Œå›æ”¾

è¿™æ˜¯ä¸€ç§ä¸ UI é›†æˆæµ‹è¯•å¯†åˆ‡ç›¸å…³çš„é«˜çº§æŠ€æœ¯ã€‚å›é¡¾ UI é›†æˆå‚è€ƒ [1](../testing-strategy/component-vs-integration-vs-e2e-testing.zh.md), [2](../real-life-examples/test-front-end-with-integration-back-end-with-e2e.zh.md)ã€‚

Cypress å…è®¸ä½ å¯¹æ‰€æœ‰ç½‘ç»œæµé‡è¿›è¡Œå­˜æ ¹ã€‚æˆ‘ä»¬å¯ä»¥è®°å½•æ¥è‡ªä¸€ä¸ªç«¯ç‚¹çš„ç½‘ç»œæ•°æ®ï¼Œå¹¶åœ¨ UI æ¯æ¬¡è°ƒç”¨ä»»æ„æœåŠ¡å™¨æ—¶å­˜æ ¹è¯¥å“åº”ã€‚

é¦–å…ˆï¼Œä»å¼€å‘è€…å·¥å…·å¤åˆ¶ç½‘ç»œæ•°æ®åˆ°ä¸€ä¸ª json æ–‡ä»¶ä¸­ã€‚å°†å…¶æ”¾ç½®åœ¨ `cypress/fixtures` æ–‡ä»¶å¤¹ä¸­ã€‚è¿™ä¸ªæ–‡ä»¶å¤¹ä¸“ä¸ºæ­¤ç›®çš„è€Œåˆ›å»ºï¼Œå¯¹å®ƒçš„ä»»ä½•å¼•ç”¨éƒ½å°†é»˜è®¤æŒ‡å‘æ–‡ä»¶å¤¹çš„æ ¹ç›®å½•ã€‚

![å¼€å‘è€…å·¥å…· > ç½‘ç»œé€‰é¡¹å¡](../../assets/images/ui-state/devtools-network.PNG)

```javascript
// prerequisite: the data has been copied to a file `cypress/fixtures/agents.json`

// this is a shorthand for cy.fixture(). More at https://docs.cypress.io/api/commands/fixture.html#Accessing-Fixture-Data
cy.intercept('some-xhr-call-that-happens-upon-landing', { fixture: 'agents.json'} ).as('crutcXHR');
// all calls to the network route will be stubbed by the data in agents.json file
```

### å¦‚æœæœ‰å¾ˆå¤šç½‘ç»œè¯·æ±‚å‘ç”Ÿæ€ä¹ˆåŠï¼Ÿ

æˆ‘ä»¬ä»å“ªé‡Œè·å–æ‰€æœ‰çš„æ¨¡æ‹Ÿæ•°æ®ï¼Ÿæˆ‘ä»¬ä¸æƒ³æ‰‹åŠ¨å¤åˆ¶å’Œä¿å­˜å®ƒä»¬ã€‚æˆ‘ä»¬å¸Œæœ›åœ¨æµ‹è¯•è¿è¡Œæ—¶è®°å½•å®ƒä»¬ï¼Œä»¥ä¾¿ä¸çœŸå®çš„ API è¿›è¡Œæ¯”å¯¹ã€‚

è‡³å°‘æœ‰ä¸¤ä¸ª Cypress æ’ä»¶å¯ä»¥ç”¨äºè¿™ä¸ªç›®çš„ [1](https://github.com/Nanciee/cypress-autorecord) å’Œ [2](https://github.com/scottschafer/cypressautomocker)ã€‚

å¦‚æœè¿™äº›æ’ä»¶ä¸é€‚ç”¨äºä½ ï¼Œä½ å¯ä»¥è½»æ¾ä½¿ç”¨ä»¥ä¸‹ä¸‰ä¸ªå‡½æ•°åˆ›å»ºè‡ªå·±çš„è®°å½•å’Œå›æ”¾å·¥å…·ã€‚

```javascript
function stubRecorder(pathToJson) {
  const xhrData = []; // an empty array to hold the data
  cy.server({ // if recording, save the response data in the array
    onResponse: (response) => {
      const url = response.url;
      const method = response.method;
      const data = response.response.body;
      // We push a new entry into the xhrData array
      xhrData.push({ url, method, data });
    }
  });

  // cy.intercept() specification below is used as a selector for the data you want to record.
  // In this example, all GET requests from any url will be selected
  // You can specify the methods and routes that are recorded
  cy.log('recording!');
  cy.intercept({
    method: 'GET',
    url: '*',
  });

  // if recording, after the test runs, create a fixture file with the recorded data
  after(function () {
    cy.writeFile(`./cypress/fixtures/${pathToJson}.json`, xhrData);
    cy.log(`Wrote ${xhrData.length} XHR responses to local file ${pathToJson}.json`);
  });
}

/** Plays recorded fixture with all required network data as json*/
function playStubbedFixture(stateFixture) {
  cy.log(`playing fixture from ${stateFixture}`);
  cy.fixture(stateFixture, { timeout: 15000 }) // the fixture file may be large and take time in CI
    .each(({method, url, data}) => {
      cy.intercept(method, url, data);
    }).as(`stateFixture_stub`);
}

/** Visits the stubbed state */
function visitStubbedState(stubFile, url, wait: boolean = true) {
  playStubbedFixture(stubFile);
  cy.visit(url);
  if (wait) { // sometimes you do not want to wait for network, this gives you the option
    cy.wait('@stateFixture_stub', { timeout: 15000 });
  }
}

//////////
// usage

// recording network
it('should run your test', function () {
  stubrecorder('jsonfileNameForNetworkData');

  // your original test

  cy.wait(5000); // one-time wait so that the after() step records all the network without missing anything

  // the rest of your original test
});

// playing the stubbed network
it('should run your test', function () {
  // every time we visit this endpoint, all network will be stubbed
  // double check this by observing (XHR stubbed) network responses in the test runner
  visitStubbedState('jsonfileNameForNetworkData', '/endpoint');

  // the rest of your original test
});
```

### ç½‘ç»œå­˜æ ¹è®°å½•å’Œå›æ”¾çš„ä¼˜ç¼ºç‚¹

UI é›†æˆæµ‹è¯•æ˜¯ UI æµ‹è¯•çš„æ ¸å¿ƒã€‚å®ƒä»¬åœ¨çœŸå®æµè§ˆå™¨ä¸­è¿è¡Œæ•´ä¸ªåº”ç”¨ç¨‹åºï¼Œè€Œä¸è¿æ¥çœŸå®æœåŠ¡å™¨ã€‚å®ƒä»¬è¿è¡Œé€Ÿåº¦æå¿«ï¼Œå¯¹ç½‘ç»œä¸­çš„éšæœºæ•…éšœæˆ–é”™è¯¯è´Ÿé¢å½±å“è¾ƒå°ã€‚

å·¥ç¨‹å¸ˆä»¬å¿…é¡»è®¤è¯†åˆ°ï¼Œè¿™ç§ä¼˜åŠ¿å¦‚æœè¢«æ»¥ç”¨å¯èƒ½æˆä¸ºä¸€ç§è¯…å’’ã€‚UI åº”ç”¨ç¨‹åºæ˜¯éš”ç¦»çš„ï¼Œä½†å¦‚æœæœ‰ç½‘ç»œæ•…éšœï¼Œå®ƒä»¬ä¼šè¢«å¿½ç•¥ã€‚è¿™å¯¹äºåŠŸèƒ½åˆ†æ”¯æµ‹è¯•éå¸¸æœ‰ç”¨ï¼Œä½†åœ¨è¿›ä¸€æ­¥çš„éƒ¨ç½²ä¸­ï¼Œåº”ç¡®ä¿åç«¯ä¹Ÿæ­£å¸¸è¿è¡Œã€‚è¯·å‚é˜… [ä½¿ç”¨é›†æˆæµ‹è¯•å‰ç«¯ï¼ŒåŒæ—¶ä½¿ç”¨ E2E æµ‹è¯•åç«¯](../real-life-examples/test-front-end-with-integration-back-end-with-e2e.zh.md) äº†è§£ä½•æ—¶ä½¿ç”¨å“ªç§æŠ€æœ¯ã€‚

<br/><br/>

## å¡«å……æ•°æ®åº“

Cypress [`cy.task()`](https://docs.cypress.io/api/commands/task.html#Requirements) åŠŸèƒ½éå¸¸å¼ºå¤§ã€‚å®é™…ä¸Šï¼Œå®ƒå…è®¸ä½ åœ¨ Cypress ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ Node.jsã€‚è¿™å¯ä»¥æ˜¯ä»»ä½•å†…å®¹ï¼Œä» Node.js ä»£ç åˆ°ä½¿ç”¨ npm åŒ…æ¥æ“çºµæ•°æ®åº“ã€‚å¦‚æœä½ çš„åº”ç”¨ç¨‹åºä½¿ç”¨ Node.jsï¼Œä½ å¯ä»¥é‡ç”¨åº”ç”¨ç¨‹åºä»£ç æ¥å¸®åŠ©è®¾ç½®å’Œæ“çºµæµ‹è¯•æ•°æ®ã€‚

å…³äºè¿™ä¸ªä¸»é¢˜æœ‰ä¸€ä¸ª [Cypress ç¤ºä¾‹](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/server-communication__seeding-database-in-node)ï¼Œæˆ‘ä»¬å°†ä»¥æ­¤ä½œä¸ºå‚è€ƒç»“æŸã€‚

## ç›¸å…³ç« èŠ‚

- ğŸ”— [ä»éš¾ä»¥ç†è§£çš„ React ç»„ä»¶æµ‹è¯•åˆ°ç®€å•æ„šè ¢çš„æµ‹è¯•](/sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.zh.md)



================================================
FILE: sections/generic-best-practices/test-code-with-debugging-in-mind.md
================================================
# Keep abstraction low to ease debugging the tests

<br/><br/>

### One Paragraph Explainer

UI tests are made up of a lot of steps and should accomplish three main things, but two of them are somewhat underestimated:

1.  To test a feature _(the obvious one)_
2.  To help the reader to understand what the code does _(usually underestimate)_
3.  To ease debuggability _(underestimate, and also requires experience)_

Let's go through some simple yet effective tips to keep in mind when writing UI tests.

<br/><br/>

## Readability

One arguable topic (Page-Object Model's fans will get hurt) is my view about abstraction in tests.

Let's look at a real-life example of a test I had to fix.

```ts
// spec.ts file
it('Create Query Action', createQueryAction);

// test.ts file (simplified version)
export const createMutationAction = () => {
  // ...
  clearActionDef();
  typeIntoActionDef(statements.createMutationActionText);
  clearActionTypes();
  // ...
};

// test.ts file contains the clearActionDef, typeIntoActionDef, etc.
const clearActionDef = () => {
  cy.get('textarea').first().type('{selectall}', { force: true });
  cy.get('textarea').first().trigger('keydown', {
    keyCode: 46,
    which: 46,
    force: true,
  });
};

// test.ts file contains also the statements
const statements = {
  createMutationActionText: `type Mutation {
    login (username: String!, password: String!): LoginResponse
  }`,
  createMutationCustomType: `type LoginResponse {
    accessToken: String!
  }
  `,
  createMutationHandler: 'https://hasura-actions-demo.glitch.me/login',
  // ...
}
```

The rationale behind the short functions is creating small, reusable pieces of code to help other tests that must do similar things on the page.

I think it is not good: because **it is hard to build a mental model of what the test does**! All the test parts are split into small functions and utilities, while the test's code must be as straightforward as possible.

Can you recall the two underrated points at the top of the chapter? The idea is that the test should accomplish three main things:

- To help the reader to understand what code does
- To allow debugging itself with ease

The former requires the test's code to be as dumb as possible, and there is no advantage in having abstraction in the test's code because it leads to spending more time debugging and maintaining the tests instead of the application.

The latter relates to the wrong part of tests: debugging/fixing them. Debugging a UI test is hard because you work with

- You front-end application
- The browser
- A tool that controls the browser
- The instructions you provide to the tool that controls the browser

Each of the above elements can fail, and even the more experienced developers can struggle with understanding the source of a failing test.

Hence, E2E testing is complicated. Cypress improves the developers' life (find more in [Some UI testing problems and the Cypress way](../tools/ui-testing-problems-cypress.md)Â chapter), but a straightforward code dramatically helps.

### No abstraction at all

I recommend having no abstraction at all (later, I will talk about the exceptions and which abstraction it's good)! I rewrote the above example to something like

```ts
it('Test the feature', () => {
  cy.get('textarea').eq(0).as('actionDefinitionTextarea');
  cy.get('textarea').eq(1).as('typeConfigurationTextarea');

  cy.get('@actionDefinitionTextarea').clearConsoleTextarea().type(
    `type Mutation {
        login (username: String!, password: String!): LoginResponse
      }`,
    { force: true, delay: 0 }
  );

  cy.get('@typeConfigurationTextarea').clearConsoleTextarea().type(
    `type LoginResponse {
      accessToken: String!
    }
    `,
    { force: true, delay: 0 }
  );

  // ...
})
```

The rewritten test does the same as the original one, but when you jump on the test's code, the overhead of jumping back and forth to connect the dots mentally is not needed.

- Do you want to know that is typed in the textarea? No hassle, it's there!
- Do you want to know what is the textareas used by the text? No hassle, it's there!

### When is abstraction good in tests?

In my opinion:

- When I want to hide some test oddities that could distract the readers for no value
- When they are soft, almost parameters-free, only one-level deep
- When there is a considerable amount of duplication (the precise amount is subjective, though)

An example of a test oddity is the following

```ts
/**
 * Clear a Console's textarea.
 * Work around cy.clear sometimes not working in the Console's textareas.
 */
Cypress.Commands.add('clearConsoleTextarea', { prevSubject: 'element' }, el => {
  cy.wrap(el).type('{selectall}', { force: true }).trigger('keydown', {
    keyCode: 46,
    which: 46,
    force: true,
  });
});
```

I created the central `cy.clearConsoleTextarea` because

1.  It's a workaround ğŸ˜Š
2.  For a newcomer, it is odds reading `trigger('keydown')` instead of using the more idiomatic `cy.clear`, and I do not want to leave a comment explaining it everywhere.
3.  The command is made up of 5 lines of code that would get the test's code too long for no reason.

An example of a soft abstraction is the following

```ts
function expectSuccessNotification = (title: string) {
  cy.get('.notification-success')
    .should('be.visible')
    .should('contain', title)
}
```

I like it because

1.  It does not use other abstracted code: if my tests fails at `expectSuccessNotification('Table created!')` I do not have to go crazy down the rabbit-hole to understand what happens behind `expectSuccessNotification`.
2.  It accepts only one variable, not a lot of options; neither includes conditions that would get hard in the way of understanding what the code finally does.
3.  **It's vertical for a specific use case**. It does not try to cover all the notification types, contents, etc., at once. Other vertical functions will do.
4.  If you refactor the notification system, you have a central point to refactor to adapt the tests to the new notification system.

At the opposite, this is what I do not want to have (while speaking about notification utilities)

```ts
export const expectNotification = (
  {
    type,
    title,
    message,
  }: {
    type: 'success' | 'error';
    title: string;
    message?: string;
  },

  timeout = 10000
) => {
  const el = cy.get(
    type === 'success' ? '.notification-success' : '.notification-error',
    { timeout }
  );

  el.should('be.visible');
  el.should('contain', title);

  if (message) el.should('contain', message);
};
```

I'm not too fond of the above example because

1.  It tries to cover too many use cases at a time.
2.  If it fails, you have to deal with conditions that make the whole experience a nightmare.

You can find more best practices we follow internally in the [Hasura Console UI coding patterns: Testing](https://dev.to/noriste/hasura-console-ui-coding-patterns-testing-281d) article.

### Matching the test's code and test runner's commands


![The test code side by side with the Cypress panel with some red arrows to match the code and the Cypress logs](../../assets/images/test-code-with-debugging-in-mind/no-match-between-code-and-runner.jpg)




The Cypress Test Runner helps understand what is happening in the application and which commands are executed, but when you debug a test, it is hard to have an immediate correlation between the Test Runner and the code. More, the logs do not help in understanding what the test is doing in feature terms (ex., the logs say "types in the textarea" but do not say "Type in the Type Configuration textarea"). So, detecting the root of a failure is hard. Cypress records videos for the failing tests, but it is useless if the reader/debugger does not have an immediate correlation between the logs and what the test is doing in plain English.

#### Look at something like this


![The code and the Cypress panel side by side, with a lot of custom logs that allow directly connecting what happens in Cypress to a precise point in the code](../../assets/images/test-code-with-debugging-in-mind/match-between-code-and-runner.jpg)



I add a log reporting what the test is doing, allowing a direct correlation between the test's code and the Test Runner (`cy.log('**--- Type in the Webhook Handler field**');`).

Please note that you can pass more arguments to 'cy.log', and they are logged right in the devtools' console when you click on the logged command.


![The Cypress Test Runner showing the value of a logged object](../../assets/images/test-code-with-debugging-in-mind/cy-log-console.jpg)



Storybook and Playwright already have the concept of `step` utilities that allow explaining in English what is happening in the test. Cypress does not have the same option, so the `cy.log` I propose is valuable, in my opinion.

Side note here: do not chain `cy.log` because it is not a query command; does not retry the chain.

`cy.log` doesnâ€™t retry at function level, as of Cypress V12.

Ex:
```js
cy.log('foo').get('bar').should('baz') // does not retry
cy.get('bar').should('baz') // retries the whole chain until the assertion passes (you have 10 sec timeout set)
```

It's worth mentioning that even if Cypress does not have `step`, [Filip Hric](https://github.com/filiphric)'s [cypress-plugin-steps](https://github.com/NoriSte/ui-testing-best-practices/issues/43) is a valid alternative.

### Use clear selectors

Look at this code

```ts
cy.get('textarea')
Â Â .eq(0)
Â Â .type(`{enter}{uparrow}${statements.createMutationGQLQuery}`, {
Â  Â Â force: true,
Â Â });
```

What is `cy.get('textarea').eq(0)`? In the absence of better selectors, I suggest hiding them under Cypress aliases, such as

```ts
// Assign an alias to the most unclear selectors for future references
cy.get('textarea').eq(0).as('actionDefinitionTextarea');
cy.get('textarea').eq(1).as('typeConfigurationTextarea');
```

and then referring to them this way

```ts
cy.get('@actionDefinitionTextarea').clearConsoleTextarea().type(/* ... */);
```

to improve the readers' life.

### Reducing data-testid attributes

I do not want to speak about the value for the tests themselves and for their confidence, but only about the effect of data-testid attributes over the debugging phase.

If an element with a data-tesid cannot be retrieved from the page, the possible problems are

1.  The element is not there.
2.  The element is there, but it does not have the attribute.
3.  The element is there, and it has the attribute but not the expected value.

All the above problems **cause the developer to re-launch the tests, inspect the elements**, look for the test-related attributes, etc. Instead, if the tests are based on the textual contents, a screenshot is enough to understand if the text searched by the test is not there or if it is wrong.

Also, some more cons for the engineers that have to deal with data-testid's

1.  Test-related attributes must be maintained during refactors, but it is not easy when you have hundreds of them.
2.  Test-related attributes are helpful if they are unique on the page. Another thing that is not easy to guarantee when you have hundreds of them

My suggestion is to use data-testid attributes only for:

-  Sections, not elements (ex. the Header, the Footer, , etc.) that allows reducing the scope of text-based searches. Here is an example

```ts
cy.get('[data-test="Actions list"]').within(() => { // <-- reduce the scope
Â Â cy.contains('login') // <-- the "login" text could exist more times in the page
})
```

-  Non-text-based elements: icons, images, etc.

Last but not least: I suggest valuing them with user-like values, not programmer-like ones (ex. "Actions List", not "actionsList"), especially when the section shows that exact text. This allows a direct connection between the code of the test, the Cypress' Test Runner, and the page's text content.

### Grouping related actions

Reading a flat list of interactions generally does not help comprehend the page's structure the test is running against.

For instance

- get 1 and click
- get 2 and click
- get 3 and click
- get 4 and click
- get 5 and click
- get 6 and click
- get 7 and click
- get 8 and click

Instead, un-flattening the list could help the readers to create a mental model of where the involved parts reside

- within block 1
  - get 1 and click
  - get 2 and click
  - get 3 and click
- within block 2
  - get 4 and click
  - get 5 and click
  - get 6 and click
- get 7 and click
- get 8 and click


![The Cypress UI showing cy.within](../../assets/images/test-code-with-debugging-in-mind/cy-within.png)



Again: Storybook and Playwright already have the concept of `step` utilities that allow grouping actions, the above suggestion is handy with Cypress.


## Related chapters

- ğŸ”— [From unreadable React Component Tests to simple, stupid ones](/sections//real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md)

<br/><br/>


*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/improving-ui-testss-code-to-ease-debugging-them-later-2478j).*



================================================
FILE: sections/generic-best-practices/test-code-with-debugging-in-mind.zh.md
================================================
# ä¿æŒä½æŠ½è±¡åº¦ä»¥ä¾¿äºè°ƒè¯•æµ‹è¯•

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

UI æµ‹è¯•æ¶‰åŠè®¸å¤šæ­¥éª¤ï¼Œä¸»è¦æœ‰ä¸‰ä¸ªå…³é”®ç›®æ ‡ï¼Œä½†å…¶ä¸­ä¸¤ä¸ªå¾€å¾€è¢«ä½ä¼°ï¼š

1. **æµ‹è¯•ä¸€ä¸ªåŠŸèƒ½**ï¼ˆæ˜¾è€Œæ˜“è§ï¼‰
2. **å¸®åŠ©è¯»è€…ç†è§£ä»£ç çš„ä½œç”¨**ï¼ˆé€šå¸¸è¢«ä½ä¼°ï¼‰
3. **ç®€åŒ–è°ƒè¯•**ï¼ˆè¢«ä½ä¼°ï¼ŒåŒæ—¶éœ€è¦ç»éªŒï¼‰

ä¸‹é¢è®©æˆ‘ä»¬ä¸€èµ·äº†è§£ç¼–å†™ UI æµ‹è¯•æ—¶è¦è®°ä½çš„ä¸€äº›ç®€å•ä½†æœ‰æ•ˆçš„æŠ€å·§ã€‚

<br/><br/>

## å¯è¯»æ€§

å…³äºæµ‹è¯•ä¸­æŠ½è±¡çš„é—®é¢˜æ˜¯ä¸€ä¸ªæœ‰äº‰è®®çš„è¯é¢˜ï¼ˆPage-Object Model çš„ç²‰ä¸å¯èƒ½ä¼šå¯¹æ­¤æœ‰å¼‚è®®ï¼‰ã€‚

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªæˆ‘ä¸å¾—ä¸ä¿®å¤çš„çœŸå®æµ‹è¯•çš„ä¾‹å­ã€‚

```ts
// spec.ts file
it('Create Query Action', createQueryAction);

// test.ts file (simplified version)
export const createMutationAction = () => {
  // ...
  clearActionDef();
  typeIntoActionDef(statements.createMutationActionText);
  clearActionTypes();
  // ...
};

// test.ts file contains the clearActionDef, typeIntoActionDef, etc.
const clearActionDef = () => {
  cy.get('textarea').first().type('{selectall}', { force: true });
  cy.get('textarea').first().trigger('keydown', {
    keyCode: 46,
    which: 46,
    force: true,
  });
};

// test.ts file contains also the statements
const statements = {
  createMutationActionText: `type Mutation {
    login (username: String!, password: String!): LoginResponse
  }`,
  createMutationCustomType: `type LoginResponse {
    accessToken: String!
  }
  `,
  createMutationHandler: 'https://hasura-actions-demo.glitch.me/login',
  // ...
}
```

çŸ­å‡½æ•°çš„èƒŒåæ€è·¯æ˜¯åˆ›å»ºå°è€Œå¯é‡å¤ä½¿ç”¨çš„ä»£ç ç‰‡æ®µï¼Œä»¥å¸®åŠ©å…¶ä»–éœ€è¦åœ¨é¡µé¢ä¸Šæ‰§è¡Œç±»ä¼¼æ“ä½œçš„æµ‹è¯•ã€‚

æˆ‘è®¤ä¸ºè¿™ä¸å¤ªå¥½ï¼Œå› ä¸º**å¾ˆéš¾å»ºç«‹å¯¹æµ‹è¯•çš„æ‰§è¡Œè¿‡ç¨‹çš„å¿ƒæ™ºæ¨¡å‹**ï¼æ‰€æœ‰æµ‹è¯•éƒ¨åˆ†éƒ½è¢«åˆ†å‰²æˆå°å‡½æ•°å’Œå®ç”¨ç¨‹åºï¼Œè€Œæµ‹è¯•çš„ä»£ç å¿…é¡»å°½å¯èƒ½åœ°ç›´æˆªäº†å½“ã€‚

ä½ è¿˜è®°å¾—ç« èŠ‚å¼€å¤´æåˆ°çš„ä¸¤ä¸ªè¢«ä½ä¼°çš„ç‚¹å—ï¼Ÿè¿™ä¸ªæƒ³æ³•æ˜¯æµ‹è¯•åº”è¯¥å®ç°ä¸‰ä¸ªä¸»è¦ç›®æ ‡ï¼š

- å¸®åŠ©è¯»è€…ç†è§£ä»£ç çš„ä½œç”¨
- ä»¥ä¾¿è½»æ¾è¿›è¡Œè°ƒè¯•

å‰è€…è¦æ±‚æµ‹è¯•çš„ä»£ç å°½å¯èƒ½ç®€å•ï¼Œè€Œåœ¨æµ‹è¯•çš„ä»£ç ä¸­ä½¿ç”¨æŠ½è±¡å¹¶æ²¡æœ‰å¥½å¤„ï¼Œå› ä¸ºè¿™ä¼šå¯¼è‡´èŠ±è´¹æ›´å¤šæ—¶é—´è°ƒè¯•å’Œç»´æŠ¤æµ‹è¯•ï¼Œè€Œä¸æ˜¯åº”ç”¨ç¨‹åºã€‚

åè€…ä¸æµ‹è¯•çš„é”™è¯¯éƒ¨åˆ†æœ‰å…³ï¼šè°ƒè¯•/ä¿®å¤å®ƒä»¬ã€‚è°ƒè¯• UI æµ‹è¯•å¾ˆå›°éš¾ï¼Œå› ä¸ºä½ éœ€è¦å¤„ç†ä»¥ä¸‹å…ƒç´ ï¼š

- ä½ çš„å‰ç«¯åº”ç”¨ç¨‹åº
- æµè§ˆå™¨
- æ§åˆ¶æµè§ˆå™¨çš„å·¥å…·
- ä½ æä¾›ç»™æ§åˆ¶æµè§ˆå™¨çš„å·¥å…·çš„æŒ‡ä»¤

ä¸Šè¿°æ¯ä¸ªå…ƒç´ éƒ½å¯èƒ½å‡ºç°é—®é¢˜ï¼Œå³ä½¿æ˜¯ç»éªŒä¸°å¯Œçš„å¼€å‘äººå‘˜ä¹Ÿå¯èƒ½åœ¨ç†è§£æµ‹è¯•å¤±è´¥çš„åŸå› æ—¶æ„Ÿåˆ°å›°æ‰°ã€‚

å› æ­¤ï¼Œç«¯åˆ°ç«¯æµ‹è¯•æ˜¯å¤æ‚çš„ã€‚Cypress æé«˜äº†å¼€å‘äººå‘˜çš„ç”Ÿæ´»è´¨é‡ï¼ˆåœ¨ [ä¸€äº› UI æµ‹è¯•é—®é¢˜å’Œ Cypress æ–¹æ³•](../tools/ui-testing-problems-cypress.zh.md) ç« èŠ‚ä¸­äº†è§£æ›´å¤šï¼‰ï¼Œä½†ç›´æˆªäº†å½“çš„ä»£ç ä¼šæå¤§åœ°å¸®åŠ©ã€‚

## ä¸ä½¿ç”¨ä»»ä½•æŠ½è±¡

æˆ‘å»ºè®®æ ¹æœ¬ä¸ä½¿ç”¨æŠ½è±¡ï¼ˆç¨åï¼Œæˆ‘å°†è®¨è®ºä¸€äº›ä¾‹å¤–æƒ…å†µä»¥åŠå“ªç§æŠ½è±¡æ˜¯å¥½çš„ï¼‰ï¼æˆ‘å°†ä¸Šè¿°ä¾‹å­æ”¹å†™ä¸ºå¦‚ä¸‹å½¢å¼ï¼š

```ts
it('Test the feature', () => {
  cy.get('textarea').eq(0).as('actionDefinitionTextarea');
  cy.get('textarea').eq(1).as('typeConfigurationTextarea');

  cy.get('@actionDefinitionTextarea').clearConsoleTextarea().type(
    `type Mutation {
        login (username: String!, password: String!): LoginResponse
      }`,
    { force: true, delay: 0 }
  );

  cy.get('@typeConfigurationTextarea').clearConsoleTextarea().type(
    `type LoginResponse {
      accessToken: String!
    }
    `,
    { force: true, delay: 0 }
  );

  // ...
})
```

é‡å†™åçš„æµ‹è¯•ä¸åŸå§‹æµ‹è¯•æ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä½†å½“ä½ æŸ¥çœ‹æµ‹è¯•ä»£ç æ—¶ï¼Œæ— éœ€æ¥å›è·³è½¬æ¥åœ¨è„‘ä¸­å»ºç«‹è¿æ¥ã€‚

- æƒ³çŸ¥é“åœ¨æ–‡æœ¬åŒºåŸŸä¸­è¾“å…¥äº†ä»€ä¹ˆå—ï¼Ÿæ¯«ä¸è´¹åŠ›ï¼Œå°±åœ¨é‚£é‡Œï¼
- æƒ³çŸ¥é“æ–‡æœ¬ä½¿ç”¨çš„æ˜¯å“ªä¸ªæ–‡æœ¬åŒºåŸŸå—ï¼Ÿæ¯«ä¸è´¹åŠ›ï¼Œå°±åœ¨é‚£é‡Œï¼

## åœ¨æµ‹è¯•ä¸­ä»€ä¹ˆæ—¶å€™ä½¿ç”¨æŠ½è±¡åŒ–æ˜¯å¥½çš„å‘¢ï¼Ÿ

åœ¨æˆ‘çœ‹æ¥ï¼š

- å½“æˆ‘æƒ³éšè—ä¸€äº›å¯èƒ½æ²¡æœ‰ä»·å€¼ä½†å¯èƒ½åˆ†æ•£è¯»è€…æ³¨æ„åŠ›çš„æµ‹è¯•æ€ªç™–æ—¶
- å½“å®ƒä»¬æ˜¯è½¯çš„ï¼Œå‡ ä¹ä¸å¸¦å‚æ•°ï¼Œåªæœ‰ä¸€å±‚æ·±åº¦
- å½“å­˜åœ¨ç›¸å½“æ•°é‡çš„é‡å¤ï¼ˆç¡®åˆ‡çš„æ•°é‡æ˜¯ä¸»è§‚çš„ï¼‰

ä¸€ä¸ªæµ‹è¯•æ€ªç™–çš„ä¾‹å­æ˜¯ä¸‹é¢è¿™ä¸ª

```ts
/**
 * Clear a Console's textarea.
 * Work around cy.clear sometimes not working in the Console's textareas.
 */
Cypress.Commands.add('clearConsoleTextarea', { prevSubject: 'element' }, el => {
  cy.wrap(el).type('{selectall}', { force: true }).trigger('keydown', {
    keyCode: 46,
    which: 46,
    force: true,
  });
});
```

æˆ‘åˆ›å»ºäº†ä¸­å¿ƒçš„ `cy.clearConsoleTextarea`ï¼ŒåŸå› å¦‚ä¸‹ï¼š

1. è¿™æ˜¯ä¸€ç§æƒå®œä¹‹è®¡ ğŸ˜Š
2. å¯¹äºæ–°æ‰‹æ¥è¯´ï¼Œé˜…è¯» `trigger('keydown')` è€Œä¸æ˜¯ä½¿ç”¨æ›´ç¬¦åˆä¹ æƒ¯çš„ `cy.clear` æ˜¯æœ‰ç‚¹å¥‡æ€ªçš„ï¼Œæˆ‘ä¸æƒ³åœ¨æ¯ä¸ªåœ°æ–¹éƒ½ç•™ä¸‹è§£é‡Šçš„æ³¨é‡Šã€‚
3. è¯¥å‘½ä»¤ç”± 5 è¡Œä»£ç ç»„æˆï¼Œå°†ä½¿æµ‹è¯•ä»£ç å˜å¾—è¿‡é•¿è€Œæ¯«æ— å¿…è¦ã€‚ 

ä»¥ä¸‹å†…å®¹æ˜¯è½¯æŠ½è±¡çš„ä¸€ä¸ªä¾‹å­ï¼š

```ts
function expectSuccessNotification = (title: string) {
  cy.get('.notification-success')
    .should('be.visible')
    .should('contain', title)
}
```

æˆ‘å–œæ¬¢å®ƒçš„åŸå› æ˜¯

1. å®ƒä¸ä¾èµ–å…¶ä»–æŠ½è±¡ä»£ç ï¼šå¦‚æœæˆ‘çš„æµ‹è¯•åœ¨ `expectSuccessNotification('Table created!')` å¤±è´¥ï¼Œæˆ‘ä¸å¿…é™·å…¥æ·±å¥¥çš„ä»£ç ä¸­ï¼Œç†è§£ `expectSuccessNotification` èƒŒåå‘ç”Ÿäº†ä»€ä¹ˆã€‚
2. å®ƒåªæ¥å—ä¸€ä¸ªå˜é‡ï¼Œè€Œä¸æ˜¯å¾ˆå¤šé€‰é¡¹ï¼›ä¹Ÿæ²¡æœ‰åŒ…å«é‚£äº›åœ¨ç†è§£ä»£ç æœ€ç»ˆæ‰§è¡Œå†…å®¹æ—¶å˜å¾—å¤æ‚çš„æ¡ä»¶ã€‚
3. **å®ƒä¸“æ³¨äºç‰¹å®šç”¨ä¾‹**ã€‚å®ƒä¸è¯•å›¾ä¸€æ¬¡æ€§æ¶µç›–æ‰€æœ‰é€šçŸ¥ç±»å‹ã€å†…å®¹ç­‰ã€‚å…¶ä»–ä¸“æ³¨äºç‰¹å®šç”¨ä¾‹çš„å‡½æ•°ä¼šå¤„ç†ã€‚
4. å¦‚æœä½ é‡æ„é€šçŸ¥ç³»ç»Ÿï¼Œä½ æœ‰ä¸€ä¸ªä¸­å¿ƒç‚¹è¿›è¡Œé‡æ„ï¼Œä»¥é€‚åº”æ–°çš„é€šçŸ¥ç³»ç»Ÿã€‚

ç›¸åï¼Œè¿™æ˜¯æˆ‘ä¸å¸Œæœ›æ‹¥æœ‰çš„ï¼ˆåœ¨è°ˆè®ºé€šçŸ¥å·¥å…·æ—¶ï¼‰ã€‚

```ts
export const expectNotification = (
  {
    type,
    title,
    message,
  }: {
    type: 'success' | 'error';
    title: string;
    message?: string;
  },

  timeout = 10000
) => {
  const el = cy.get(
    type === 'success' ? '.notification-success' : '.notification-error',
    { timeout }
  );

  el.should('be.visible');
  el.should('contain', title);

  if (message) el.should('contain', message);
};
```

æˆ‘å¯¹ä¸Šé¢çš„ä¾‹å­ä¸å¤ªå–œæ¬¢ï¼ŒåŸå› æœ‰ä¸¤ç‚¹ï¼š

1. å®ƒè¯•å›¾ä¸€æ¬¡æ€§æ¶µç›–å¤ªå¤šç”¨ä¾‹ã€‚
2. å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œä½ å¿…é¡»å¤„ç†è®©æ•´ä¸ªä½“éªŒå˜æˆå™©æ¢¦çš„å„ç§æ¡ä»¶ã€‚

åœ¨[Hasura æ§åˆ¶å° UI ç¼–ç æ¨¡å¼ï¼šæµ‹è¯•](https://dev.to/noriste/hasura-console-ui-coding-patterns-testing-281d)æ–‡ç« ä¸­ï¼Œä½ å¯ä»¥æ‰¾åˆ°æˆ‘ä»¬åœ¨å†…éƒ¨éµå¾ªçš„æ›´å¤šæœ€ä½³å®è·µã€‚

## åŒ¹é…æµ‹è¯•ä»£ç å’Œæµ‹è¯•è¿è¡Œå™¨å‘½ä»¤

![æµ‹è¯•ä»£ç ä¸ Cypress é¢æ¿å¹¶æ’æ˜¾ç¤ºï¼Œå¸¦æœ‰ä¸€äº›çº¢è‰²ç®­å¤´æ¥åŒ¹é…ä»£ç å’Œ Cypress æ—¥å¿—](../../assets/images/test-code-with-debugging-in-mind/no-match-between-code-and-runner.jpg)

Cypress æµ‹è¯•è¿è¡Œå™¨æœ‰åŠ©äºç†è§£åº”ç”¨ç¨‹åºä¸­å‘ç”Ÿäº†ä»€ä¹ˆä»¥åŠæ‰§è¡Œäº†å“ªäº›å‘½ä»¤ï¼Œä½†åœ¨è°ƒè¯•æµ‹è¯•æ—¶ï¼Œå¾ˆéš¾ç«‹å³åœ¨æµ‹è¯•è¿è¡Œå™¨å’Œä»£ç ä¹‹é—´å»ºç«‹å…³è”ã€‚è€Œä¸”ï¼Œæ—¥å¿—æ— æ³•å¸®åŠ©ç†è§£æµ‹è¯•ä»åŠŸèƒ½è§’åº¦æ­£åœ¨åšä»€ä¹ˆï¼ˆä¾‹å¦‚ï¼Œæ—¥å¿—è¯´â€œåœ¨æ–‡æœ¬åŒºåŸŸä¸­é”®å…¥â€ï¼Œä½†æ²¡æœ‰è¯´æ˜â€œåœ¨ç±»å‹é…ç½®æ–‡æœ¬åŒºåŸŸä¸­é”®å…¥â€ï¼‰ã€‚å› æ­¤ï¼ŒæŸ¥æ‰¾å¤±è´¥çš„æ ¹æœ¬åŸå› æ˜¯å›°éš¾çš„ã€‚Cypress ä¼šä¸ºå¤±è´¥çš„æµ‹è¯•è®°å½•è§†é¢‘ï¼Œä½†å¦‚æœé˜…è¯»è€…/è°ƒè¯•è€…ä¸èƒ½åœ¨æ—¥å¿—å’Œæµ‹è¯•åœ¨æ™®é€šè‹±è¯­ä¸­æ‰€åšçš„äº‹æƒ…ä¹‹é—´å»ºç«‹ç›´æ¥å…³è”ï¼Œåˆ™è§†é¢‘å°±æ¯«æ— ç”¨å¤„ã€‚

### è¯·çœ‹ä¸‹é¢çš„å†…å®¹

![ä»£ç å’Œ Cypress é¢æ¿å¹¶æ’æ˜¾ç¤ºï¼Œæœ‰è®¸å¤šè‡ªå®šä¹‰æ—¥å¿—ï¼Œå¯ä»¥ç›´æ¥å°† Cypress ä¸­å‘ç”Ÿçš„æƒ…å†µä¸ä»£ç ä¸­çš„ç‰¹å®šç‚¹è¿æ¥èµ·æ¥ã€‚](../../assets/images/test-code-with-debugging-in-mind/match-between-code-and-runner.jpg)

æˆ‘æ·»åŠ äº†ä¸€ä¸ªæ—¥å¿—ï¼ŒæŠ¥å‘Šæµ‹è¯•æ­£åœ¨è¿›è¡Œçš„æ“ä½œï¼Œä½¿æµ‹è¯•ä»£ç ä¸æµ‹è¯•è¿è¡Œç¨‹åºä¹‹é—´èƒ½å¤Ÿç›´æ¥å¯¹åº”ã€‚ (`cy.log('**--- Type in the Webhook Handler field**');`).

è¯·æ³¨æ„ï¼Œä½ å¯ä»¥å‘ 'cy.log' ä¼ é€’æ›´å¤šå‚æ•°ï¼Œè¿™äº›å‚æ•°å°†åœ¨å•å‡»è®°å½•çš„å‘½ä»¤æ—¶ç›´æ¥æ˜¾ç¤ºåœ¨å¼€å‘å·¥å…·çš„æ§åˆ¶å°ä¸­ã€‚

![Cypress æµ‹è¯•è¿è¡Œå™¨å±•ç¤ºäº†å·²è®°å½•å¯¹è±¡çš„å€¼ã€‚](../../assets/images/test-code-with-debugging-in-mind/cy-log-console.jpg)

Storybook å’Œ Playwright å·²ç»å¼•å…¥äº†`step`å®ç”¨å·¥å…·çš„æ¦‚å¿µï¼Œå¯ä»¥ç”¨è‹±è¯­è§£é‡Šæµ‹è¯•ä¸­çš„æ­¥éª¤ã€‚Cypress æ²¡æœ‰ç›¸åŒçš„é€‰é¡¹ï¼Œå› æ­¤æˆ‘è®¤ä¸ºæˆ‘æå‡ºçš„`cy.log`æ˜¯å¾ˆæœ‰ä»·å€¼çš„ã€‚

è¿™é‡Œéœ€è¦æ³¨æ„ï¼šä¸è¦å°†`cy.log`é“¾åœ¨ä¸€èµ·ï¼Œå› ä¸ºå®ƒä¸æ˜¯ä¸€ä¸ªæŸ¥è¯¢å‘½ä»¤ï¼Œä¸ä¼šå¯¹é“¾è¿›è¡Œé‡è¯•ã€‚

æˆªè‡³ Cypress V12 ç‰ˆæœ¬ï¼Œ`cy.log`åœ¨å‡½æ•°çº§åˆ«ä¸è¿›è¡Œé‡è¯•ã€‚

ä¾‹å¦‚ï¼š

```js
cy.log('foo').get('bar').should('baz') // does not retry
cy.get('bar').should('baz') // retries the whole chain until the assertion passes (you have 10 sec timeout set)
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ Cypress æ²¡æœ‰ `step`ï¼Œ[Filip Hric](https://github.com/filiphric) çš„ [cypress-plugin-steps](https://github.com/NoriSte/ui-testing-best-practices/issues/43) ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ›¿ä»£é€‰æ‹©ã€‚

## ä½¿ç”¨æ¸…æ™°çš„é€‰æ‹©å™¨

çœ‹ä¸€ä¸‹è¿™æ®µä»£ç 

```ts
cy.get('textarea')
Â Â .eq(0)
Â Â .type(`{enter}{uparrow}${statements.createMutationGQLQuery}`, {
Â  Â Â force: true,
Â Â });
```

`cy.get('textarea').eq(0)` æ˜¯ä»€ä¹ˆï¼Ÿåœ¨æ²¡æœ‰æ›´å¥½çš„é€‰æ‹©å™¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘å»ºè®®å°†å®ƒä»¬æ”¾åœ¨ Cypress çš„åˆ«åä¸‹ï¼Œæ¯”å¦‚

```ts
// Assign an alias to the most unclear selectors for future references
cy.get('textarea').eq(0).as('actionDefinitionTextarea');
cy.get('textarea').eq(1).as('typeConfigurationTextarea');
```

ç„¶åé€šè¿‡è¿™ç§æ–¹å¼æ¥å¼•ç”¨å®ƒä»¬

```ts
cy.get('@actionDefinitionTextarea').clearConsoleTextarea().type(/* ... */);
```

ä»¥æé«˜è¯»è€…çš„ä½“éªŒã€‚

## å‡å°‘ data-testid å±æ€§

æˆ‘ä¸æƒ³è®¨è®ºæµ‹è¯•æœ¬èº«åŠå…¶å¯¹æµ‹è¯•ç»“æœå¯ä¿¡åº¦çš„ä»·å€¼ï¼Œåªæƒ³è°ˆè°ˆ data-testid å±æ€§åœ¨è°ƒè¯•é˜¶æ®µçš„å½±å“ã€‚

å¦‚æœæ— æ³•ä»é¡µé¢ä¸­æ£€ç´¢å¸¦æœ‰ data-testid å±æ€§çš„å…ƒç´ ï¼Œå¯èƒ½çš„é—®é¢˜æœ‰ï¼š

1. å…ƒç´ ä¸å­˜åœ¨ã€‚
2. å…ƒç´ å­˜åœ¨ï¼Œä½†å®ƒæ²¡æœ‰è¯¥å±æ€§ã€‚
3. å…ƒç´ å­˜åœ¨ï¼Œå…·æœ‰è¯¥å±æ€§ï¼Œä½†å€¼ä¸ç¬¦åˆé¢„æœŸã€‚

ä¸Šè¿°æ‰€æœ‰é—®é¢˜éƒ½ä¼š**å¯¼è‡´å¼€å‘äººå‘˜é‡æ–°å¯åŠ¨æµ‹è¯•ã€æ£€æŸ¥å…ƒç´ ã€æŸ¥æ‰¾ä¸æµ‹è¯•ç›¸å…³çš„å±æ€§ç­‰**ã€‚ç›¸åï¼Œå¦‚æœæµ‹è¯•åŸºäºæ–‡æœ¬å†…å®¹ï¼Œä»…é€šè¿‡æˆªå›¾å°±è¶³ä»¥äº†è§£æµ‹è¯•æœç´¢çš„æ–‡æœ¬æ˜¯å¦ä¸å­˜åœ¨æˆ–é”™è¯¯ã€‚

æ­¤å¤–ï¼Œå¯¹äºé‚£äº›å¿…é¡»å¤„ç† data-testid çš„å·¥ç¨‹å¸ˆæ¥è¯´ï¼Œè¿˜æœ‰ä¸€äº›ä¸è¶³ä¹‹å¤„ï¼š

1. åœ¨é‡æ„æœŸé—´å¿…é¡»ç»´æŠ¤ä¸æµ‹è¯•ç›¸å…³çš„å±æ€§ï¼Œä½†åœ¨æœ‰æ•°ç™¾ä¸ªå±æ€§æ—¶å¹¶ä¸å®¹æ˜“ã€‚
2. å¦‚æœæµ‹è¯•ç›¸å…³çš„å±æ€§åœ¨é¡µé¢ä¸Šæ˜¯å”¯ä¸€çš„ï¼Œé‚£ä¹ˆå®ƒä»¬ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚ç„¶è€Œï¼Œå½“ä½ æœ‰æ•°ç™¾ä¸ªè¿™æ ·çš„å±æ€§æ—¶ï¼Œå¾ˆéš¾ä¿è¯å®ƒä»¬æ˜¯å”¯ä¸€çš„ã€‚

æˆ‘çš„å»ºè®®æ˜¯ä»…åœ¨ä»¥ä¸‹æƒ…å†µä½¿ç”¨ data-testid å±æ€§ï¼š

- ç”¨äºèŠ‚ï¼Œè€Œä¸æ˜¯å…ƒç´ ï¼ˆä¾‹å¦‚ Headerã€Footer ç­‰ï¼‰ï¼Œä»¥å‡å°åŸºäºæ–‡æœ¬æœç´¢çš„èŒƒå›´ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š

```ts
cy.get('[data-test="Actions list"]').within(() => { // <-- reduce the scope
Â Â cy.contains('login') // <-- the "login" text could exist more times in the page
})
```

- éæ–‡æœ¬å…ƒç´ ï¼Œå¦‚å›¾æ ‡ã€å›¾ç‰‡ç­‰ã€‚

æœ€åä½†åŒæ ·é‡è¦çš„æ˜¯ï¼šæˆ‘å»ºè®®ä¸ºå®ƒä»¬èµ‹äºˆç”¨æˆ·å‹å¥½çš„å€¼ï¼Œè€Œä¸æ˜¯é‡‡ç”¨ç¨‹åºå‘˜çš„å‘½åé£æ ¼ï¼ˆä¾‹å¦‚ï¼Œâ€œæ“ä½œåˆ—è¡¨â€è€Œä¸æ˜¯â€œactionsListâ€ï¼‰ï¼Œå°¤å…¶æ˜¯å½“è¯¥éƒ¨åˆ†æ˜¾ç¤ºç›¸åŒæ–‡æœ¬æ—¶ã€‚è¿™æ ·å¯ä»¥ç›´æ¥å…³è”æµ‹è¯•ä»£ç ã€Cypress çš„æµ‹è¯•è¿è¡Œå™¨å’Œé¡µé¢çš„æ–‡æœ¬å†…å®¹ã€‚

## å°†ç›¸å…³æ“ä½œåˆ†ç»„

é€šå¸¸æ¥è¯´ï¼Œé˜…è¯»ä¸€ç³»åˆ—å¹³é¢çš„äº¤äº’å¹¶ä¸èƒ½å¸®åŠ©ç†è§£æµ‹è¯•è¿è¡Œçš„é¡µé¢ç»“æ„ã€‚

ä¾‹å¦‚ï¼š

- è·å– 1 å¹¶ç‚¹å‡»
- è·å– 2 å¹¶ç‚¹å‡»
- è·å– 3 å¹¶ç‚¹å‡»
- è·å– 4 å¹¶ç‚¹å‡»
- è·å– 5 å¹¶ç‚¹å‡»
- è·å– 6 å¹¶ç‚¹å‡»
- è·å– 7 å¹¶ç‚¹å‡»
- è·å– 8 å¹¶ç‚¹å‡»

ç„¶è€Œï¼Œå°†åˆ—è¡¨å±•å¼€å¯ä»¥å¸®åŠ©è¯»è€…æ„å»ºä¸€ä¸ªæœ‰å…³æ‰€æ¶‰åŠéƒ¨åˆ†ä½ç½®çš„å¿ƒç†æ¨¡å‹

- åœ¨å— 1 å†…
  - è·å– 1 å¹¶ç‚¹å‡»
  - è·å– 2 å¹¶ç‚¹å‡»
  - è·å– 3 å¹¶ç‚¹å‡»
- åœ¨å— 2 å†…
  - è·å– 4 å¹¶ç‚¹å‡»
  - è·å– 5 å¹¶ç‚¹å‡»
  - è·å– 6 å¹¶ç‚¹å‡»
- è·å– 7 å¹¶ç‚¹å‡»
- è·å– 8 å¹¶ç‚¹å‡»

![Cypress ç•Œé¢å±•ç¤º cy.within](../../assets/images/test-code-with-debugging-in-mind/cy-within.png)

å†å¼ºè°ƒä¸€ä¸‹ï¼šStorybook å’Œ Playwright å·²ç»å¼•å…¥äº†â€œæ­¥éª¤ï¼ˆstepï¼‰â€å®ç”¨ç¨‹åºçš„æ¦‚å¿µï¼Œè¯¥å®ç”¨ç¨‹åºå¯ä»¥å°†æ“ä½œè¿›è¡Œåˆ†ç»„ï¼Œè€Œä¸Šè¿°å»ºè®®åœ¨ Cypress ä¸­éå¸¸å®ç”¨ã€‚

## ç›¸å…³ç« èŠ‚

- ğŸ”— [ä»æ™¦æ¶©éš¾æ‡‚çš„ React ç»„ä»¶æµ‹è¯•åˆ°ç®€å•ã€æ˜“è¯»çš„ç‰ˆæœ¬](/sections//real-life-examples/from-unreadable-react-component-tests-to-simple-ones.zh.md)

<br/><br/>

*ç”± [NoriSte](https://github.com/NoriSte) åœ¨ [dev.to](https://dev.to/noriste/improving-ui-testss-code-to-ease-debugging-them-later-2478j)è¿›è¡Œå‘è¡¨.*



================================================
FILE: sections/generic-best-practices/ui-tests-debugging-best-practices.md
================================================
# UI Tests Debugging Best Practices

Before moving to Cypress, I was used to writing UI tests with Puppeteer. Understanding what was happening in the browser, which test was running, and debugging the tests were not easy tasks, hence I started applying a series of solutions that helped me through the whole process.

Tools like [Cypress](https://www.cypress.io/) and [TestCafÃ©](https://devexpress.github.io/testcafe/) get the following list of best practices almost useless but you do not realize how much a made-on-purpose tool simplifies your life unless you have previous testing experience with tools like [Selenium](https://www.selenium.dev/) or [Puppeteer](https://pptr.dev/).

The zero-step is to launch the browser in non-headless mode, then...

### Console.log/show the description of the test

Since you do not have visual feedback about which test is running inside the browser, remember to log the name of the test inside the browser console. It is quite useless in case of fast tests (less than 1 second) but helpful in case of longer tests or to have a double-check about the test that you are running while playing with test.skip and test.only.

In Puppeteer this could be accomplished with:
```js
test('Test description', async () => {
  await page.evaluate(() => console.log('Test description'));

  // ... the test code...
})
```
If you need more intrusive feedback, you could consider even adding a fixed div at the top-left corner of the page that every test populates with its own description...

### Forward browser console.log to Node.js

With Puppeteer, a simple
```js
page.on('console', msg => console.log('BROWSER LOG:', msg.text()));
```
allows you to read both the test logs and the browser one in the same terminal window. Simple and effective.

### Launch the browser with the devtools already opened

Like in classic front-end development, opening the devtools after the page loading has already started could make you miss important stuff, especially in the network tab. While debugging your tests, launching the browser with the devtools already opened could save you precious time and info.
```js
const browser = await puppeteer.launch({
  headless: false,
  devtools: true
});
```
### Slow down the simulated user actions

A browser automation tool is fast as hell, this allows us to run a lot of tests in a bunch of seconds. While debugging, this could be a disadvantage, because you need to follow with your eyes whatâ€™s happening on the page. Slowing down **every action** could be counterproductiveâ€”because the whole test becomes slowâ€” but usually, it is the easiest way to perform some rapid checks. In Puppeteer, there is a global setting to do that.
```js
const browser = await puppeteer.launch({
  headless: false,
  slowMo: 250, // slow down every action by 250ms
});
```
Some actions, like typing, allows you to add a more specific delay (that occurs on top of the global slowMo setting)
```js
await page.type('.username', 'admin', {delay: 10});
```
### Pause the test with a debugger statement

Again, like in standard web development, you could add a debugger statement to the code running on your page to â€œpauseâ€ the JavaScript execution. Please note: the statement is effective only if the devtools are opened in the controlled browser.
```js
await page.evaluate(() => {debugger;});
```
By clicking â€œResume scripts executionâ€ or bypressing F8 (debugger is a â€œflyingâ€ breakpoint) will resume the test execution.

### Increase the test timeout

Test runners like Jest, Jasmine, etc. have test timeouts. Timeouts are useful to terminate a test if something goes wrong and the tests never end. In UI testing, this behavior is cumbersome because you open the browser when the test starts and you close it when the test ends. In the normal test's lifecycle, a high timeout does not work because it results in a huge loss of time in case of failure, while a low one could â€œtruncateâ€ the test before it is finished.

Instead, you need long timeouts because you do not want the end of the test make close the browser while you are inspecting it. Thatâ€™s why a 10-minutes timeout could be helpful while debugging the controlled browser.

Otherwise, you could...

### Avoid closing the browser when the test ends

When the tests start, you open the browser, then you close it when the tests end. Avoid closing it gives you the freedom of inspecting the front-end app without the fear of the test timeout. This is valid only when running the tests locally and the auto-close must be restored before running the tests on CI pipelines to avoid memory shortage due to the left open browser instances.

### Take screenshots

This is particularly helpful while running the tests in headless mode, in the phase when the tests are expected to be stable and to fail only in case of regressions. If a test fails, a lot of times a screenshot makes you to understand how the feature you are working on affected a previously working one. The most effective solution is to take a screenshot when the tests fail, otherwise, you could identify some checkpoints in your UI test and taking a screenshot at these steps.

### Assert frequently

A rule of thumb: if a test fails, it must drive you directly to understand what went wrong without re-launching the test and debugging it manually. Try to manually introduce bugs in your codebase (changing requests payload, removing elements, etc.) and check what the test reports. Is the error correlated to the bug you introduced? Who reads the failure could understand what needs to be fixed?

You need to add a lot of assertions to your test and it is totally fine! Unit tests take generally one single step and one or two assertions but UI tests are different, they have a lot of steps and hence you need a lot of assertions. Think of them as a series of uni tests where the previous test is necessary to create the ground for the second test, and so on.

### Use test.skip and test.only

It is one of the basics of every test runner but you never know: if you are not accustomed to using skip and only, start now! Otherwise, you are going to waste a lot of time, even if your test files are made by just two or three tests. Always run the least number of tests you are working on or you need to debug!

### Run the tests serially

If you are using Puppeteer in combination with Jest remember that Jest has a dedicated runInBand option that prevents it from spreading the execution of the tests over your CPU cores. Parallelizing the tests is perfect to fasten the execution but it is annoying when you need to follow the test actions with your eyes. runInBand runs the tests serially. Using it in combination with test.skip, test.only, and [jest-watch-typeahead](https://github.com/jest-community/jest-watch-typeahead) saves you a lot of debugging headaches.

### Keep your test code simple

Prefer duplication over abstraction. Strive to keep your tests code simple and easy to read. The more you debug UI tests, the more you realize how hard it could be. Your super-abstracted, completely DRYed, testing code becomes a pain as soon as you need to understand what is happening under the hood and which step is not working as expected.

More in general, tests are little scripts that must be two levels of magnitude simpler than the code they test, get them an ally, and not some more complex programs.

You can dig more about this topic in [Keep abstraction low to ease debugging the tests](/sections/generic-best-practices/test-code-with-debugging-in-mind.md), and [From unreadable React Component Tests to simple, stupid ones](/sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md).




<br /><br />

_Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/ui-tests-debugging-best-practices-1eg3) and [Medium](https://medium.com/@NoriSte/ui-tests-debugging-best-practices-789c4ed4daf6?sk=c6056f124f40b15e09669e5839e9f814)._



================================================
FILE: sections/generic-best-practices/ui-tests-debugging-best-practices.zh.md
================================================
[Binary file]


================================================
FILE: sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md
================================================
# Use your testing tool as your primary development tool

<br/><br/>

### One Paragraph Explainer


An example speaks itself. Let's say you're developing an authentication form, probably, you:
- code the username input field
- **try it manually** in the browser
- code the password input field
- **try it manually** in the browser
- code the submit button
- code the XHR request management

then, you can't go ahead because, without changing the source code, you need that a stubbed/mocked server responds to the app XHR requests. **Then you start writing an integration test** that:
- fill the username input field
- fill the password input field
- click the submit button
- check the XHR request
- stub the XHR response
- check the feedbacks
- re-do it for every error flow
- code the error flow management
- re-check the tests

Take a look at the first test steps, they are **the same we made manually** while coding the authentication form. Then, we stub the
server responses and check the final behavior of the form (with success/failure responses).

This working flow could be easily improved if we write the test alongside the form itself (TDD
developers are already trained to do that):
- **code the username input field** *
- **write the test to fill** the username input field *
- code the password input field
- update the test to fill the password input field
- code the submit button
- update the test to click the submit button
- stub the XHR response into the test
- code the XHR request management
- check the feedbacks
- code the error flow management
- update the test to check the error flow
- re-do the above steps for every single error flow

\* please note that the first and the second step could be inverted if you want to apply a strict TDD approach

What are the most important advantages of doing that?
- you **avoid (almost) completely manually testing** your app
- you leverage the speed of your testing tool, it fills the form at a blazing speed and let you **save
  a lot of time**
- you don't have to write the test after you coded the form (again, TDD developers already avoid it)
  that, only at the first approaches, could seem an annoying task
- you completely **avoid putting some temporary states into your source code** (input field default
  values, fake XHR responses)
- you test your app directly with a real network response (remember that your app does not know that
  the network request is stubbed by the testing tool)
- the test is relaunched every time you save the test file
- you can leverage both the Chrome DevTools and the framework-specific devtools

How to leverage the **existing Development Tools**?<br>
Well, you can do that in
almost every testing tool but Cypress stands out for this kind of goal. Cypress has a dedicated
Chrome user that's persisted across all your tests and all your projects. Doing so, Cypress allows
you to have a real testing-dedicated browser with your favorite extensions, even if you use the
same Chrome version you use to browse.<br>
Mix it with a great UI and you are ready to start developing all your app directly with Cypress.

Below you can find some screenshot of the Cypress UI to show you how much easy is using it as a
primary development tool.

<br>

**Browser Selection**
![Cypress browser
selection](../../assets/images/use-your-testing-tool-as-your-primary-development-tool/browser-selection.png
"Cypress browser selection")

**The Cypress-controlled browser DevTools**
![Cypress browser
devtools](../../assets/images/use-your-testing-tool-as-your-primary-development-tool/devtools.jpg
"Cypress browser devtools")

**Cypress [Skip and Only UI plugin](https://github.com/bahmutov/cypress-skip-and-only-ui)** that allows you to add some `.only` or `.skip` to the tests directly from the Cypress UI.
![Cypress Skip and Only
UI](../../assets/images/use-your-testing-tool-as-your-primary-development-tool/skip-and-only.gif
"Cypress Skip and Only UI")

**Cypress [Watch and Reload plugin](https://github.com/bahmutov/cypress-watch-and-reload)** that allows you to re-run the cypress tests on every source code compilation.


If you want to see the React/Redux devtools in action with the Cypress controlled browser you can use the [cypress-react-devtools](https://github.com/NoriSte/cypress-react-devtools) repository.

## Related chapters

- ğŸ”— [Found a bug? Write the test, then fix it](/sections/testing-strategy/write-test-then-fix-bug.md)

<br /><br />

*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/front-end-productivity-boost-cypress-as-your-main-development-browser-5cdk) and [Medium](https://medium.com/@NoriSte/front-end-productivity-boost-cypress-as-your-main-development-browser-f08721123498).*



================================================
FILE: sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.zh.md
================================================
[Binary file]


================================================
FILE: sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md
================================================
# From unreadable React Component Tests to simple, stupid ones

<br/><br/>

### One Paragraph Explainer

The test's code must be as straightforward as possible. The benefit is to save a lot of time to understand, update, refactor, fix it when needed. At the opposite, a terrible scenario happens when you are not able to read some tests, even if you are the author!

<br/><br/>

Here are the rationales, the mental process, and the patterns at the base of the refactor of some old React Component Tests of mine.


## The problem

One year after adding at the ["Testing a Virtual List component with Cypress and Storybook"](../../sections/tools/cypress-and-storybook-exposing-component-from-story.md) chapter, and the ["Unit Testing React components with Cypress"](../../sections/tools/cypress-react-component-test.md) one, I felt terrible while realizing that my tests were almost unreadable. Many abstractions prevented me from carefully understanding what the test did in a while, resulting in a long time reading them. This is unacceptable friction.


## How to improve tests readability?

Kent Beck, the father of TDD, said

> Test code is NOT production code. It must be 1000x times simpler and smaller.

but how? What adds such friction to my tests? What worsens readability?

I will to analyze a bunch of my tests, reasoning about them, and propose a more straightforward approach. The component under test is a VirtualList mentioned in the previous articles.

## Test 1, low complexity

The next test is the simplest one: checking that the VirtualList renders nothing when nothing is passed. Following is the original test

```tsx
it('When there are no items, then nothing is showed', () => {
  const itemsAmount = 0
  const itemHeight = 30
  const listHeight = 300
  const items = getStoryItems({ amount: itemsAmount })

  mount(
    <VirtualList
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={createRenderItem({ height: itemHeight })}
      listHeight={listHeight}
    />,
  )

  cy.findByTestId('VirtualList')
    .then($el => $el.text())
    .should('be.empty')
})
```

Considering the simplicity of the test, is speaking about readability here bikeshedding? No, I've already some questions about it, such as:
- What does `getStoryItems` do?
- What does `createRenderItem` do?

I don't report `getStoryItems`'s code here, but it's just a function that generates an array containing X items in the form of `[{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }, /* etc. */]`. Its purpose is to generate thousands of items easily, but I wrote it to ease writing Storybook's stories without tests in mind! Then, I reused it for the tests, but stories and tests have completely different needs and purposes!

At the same time, `createRenderItem` is a factory that generates the list items (some React components). Again, I made it such dynamic for Storybook, and tests weren't originally in my mind.

Both the functions are easy to read, but why am I forcing the reader to follow these abstractions? Are they needed? The answer is no.

Following is the simplified code of the test, following the differences.

```tsx
it('When there are no items, then nothing is showed', () => {
  // ------------------------------------------
  // Arrange
  const items = [];

  mount(
    <VirtualList
      items={items}
      listHeight={90}
      getItemHeights={() => 30}
      RenderItem={RenderItem}
    />
  );

  // ------------------------------------------
  // Assert
  cy.findByTestId('VirtualList')
    .then(($el) => $el.text())
    .should('be.empty');
});
```
```diff
-const itemsAmount = 0
-const itemHeight = 30
-const listHeight = 300
-const items = getStoryItems({ amount: itemsAmount })
+const items = [];

mount(
  <VirtualList
    items={items}
    listHeight={listHeight}
-   getItemHeights={() => itemHeight}
+   getItemHeights={() => 30}
-   RenderItem={createRenderItem({ height: itemHeight })}
+   RenderItem={RenderItem}
  />,
)
```

In the simplified test, the most significant changes are:
1. I made `items` explicit instead of generating them through `getStoryItems`. The goal is immediately to clarify to the reader which are the items the VirtualList renders.
2. I removed the "unnecessary" constants. How tall are the items and the list don't make a difference if no items are rendered.
3. I removed the need for the `createRenderItem` factory. Generating components with height pre-set is useless here.

## Test 2, medium complexity

The next test is not complex. But the way I implemented it adds complexity when not needed. The goal is testing the base functionality of a VirtualList: rendering the visible items and not rendering the invisible ones.

```tsx
it('When the list receives 10000 items, then only the minimum number of them are rendered', () => {
  const itemsAmount = 10000
  const itemHeight = 30
  const listHeight = 300
  const items = getStoryItems({ amount: itemsAmount })
  const visibleItemsAmount = listHeight / itemHeight

  mount(
    <VirtualList
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={createRenderItem({ height: itemHeight })}
      listHeight={listHeight}
    />,
  )

  const visibleItems = items.slice(0, visibleItemsAmount - 1)
  itemsShouldBeVisible(visibleItems)

  // first not-rendered item check
  cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
})
```

Here things are getting weirder. Again, there are some simple abstractions, but the reader must:
- Comprehend the value of `visibleItemsAmount`.
- Comprehend what `visibleItems` contains, by reading `items.slice`. Again, one more complexity layer.
- Guess about what `itemsShouldBeVisible` does, or reading its code.
- Guess what `items[visibleItemsAmount]` contains.

Yeah, there are some comments. Yeah, I tried to create meaningful names. But I could simplify it a lot.

One more thing. Imagine this situation: the test is failing. It doesn't matter what you have done. This test is failing. You start debugging it, but you know that debugging a highly dynamic test (you don't know what `items`, `visibleItemsAmount`, `visibleItems`, `items[visibleItemsAmount]` contains upfront) is hard. You need to `console.log`/`cy.log`/`debugger`/breakpoint the test code to have an overall idea of the contents managed by the test, and then you can start debugging the VirtualList. Could I avoid future debugger these problems? Do I need the test to render 10.000 items?

Following is how I improved the test.

```tsx
it('When the list is longer than the available space, then only the minimum number of items are rendered', () => {
  // ------------------------------------------
  // Arrange

  // creating the data
  const items = [
    // visible ones
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' },
    // invisible one
    { id: 3, name: 'Item 4' },
  ];

  // only 3 items are visible
  const itemHeight = 30;
  const listHeight = 90;

  // mounting the component
  mount(
    <VirtualList
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={RenderItem}
      listHeight={listHeight}
    />
  );

  // ------------------------------------------
  // Act

  // ------------------------------------------
  // Assert
  cy.findByText('Item 1').should('be.visible');
  cy.findByText('Item 2').should('be.visible');
  cy.findByText('Item 3').should('be.visible');
  cy.findByText('Item 4').should('not.exist');
});
```

Also, here, the sole and relevant change is easing the future reader/debugger. You don't have to guess/calculate/log the value of the constants, nor what the abstractions do. The code is under your eyes, following the KISS principle (Keep It Simple, Stupid).

```diff
-const itemsAmount = 10000
-const itemHeight = 30
-const listHeight = 300
-const items = getStoryItems({ amount: itemsAmount })
-const visibleItemsAmount = listHeight / itemHeight
+// creating the data
+const items = [
+ // visible ones
+ { id: 1, name: 'Item 1' },
+ { id: 2, name: 'Item 2' },
+ { id: 3, name: 'Item 3' },
+ // invisible one
+ { id: 3, name: 'Item 4' },
+];

+// only 3 items are visible
+const itemHeight = 30;
+const listHeight = 90;

/* ... */

-const visibleItems = items.slice(0, visibleItemsAmount - 1)
-itemsShouldBeVisible(visibleItems)
-cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
+cy.findByText('Item 1').should('be.visible');
+cy.findByText('Item 2').should('be.visible');
+cy.findByText('Item 3').should('be.visible');
+cy.findByText('Item 4').should('not.exist');
```

## Test 3, medium complexity

In the next test, the purpose is to test the VirtualList's `buffer` property that allows rendering some items even if they aren't visible yet.

```tsx
it('When some items buffered, then they exist in the page', () => {
  const itemsAmount = 1000
  const itemHeight = 30
  const listHeight = 300
  const items = getStoryItems({ amount: itemsAmount })
  const visibleItemsAmount = listHeight / itemHeight
  const bufferedItemsAmount = 5

  mount(
    <VirtualList
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={createRenderItem({ height: itemHeight })}
      listHeight={listHeight}
      buffer={bufferedItemsAmount}
    />,
  )

  fastScrollVirtualList().then(() => {
    const firstRenderedItemIndex = getFirstRenderedItemIndex(items, getItemText)
    const firstVisibleItemIndex = firstRenderedItemIndex + bufferedItemsAmount
    const lastVisibleItemIndex = firstVisibleItemIndex + visibleItemsAmount + 1
    const lastRenderedItemIndex = lastVisibleItemIndex + bufferedItemsAmount

    items.slice(firstRenderedItemIndex, firstVisibleItemIndex).forEach(item => {
      cy.findByText(getItemText(item)).should('not.be.visible')
    })

    items.slice(firstVisibleItemIndex, lastVisibleItemIndex).forEach(item => {
      cy.findByText(getItemText(item)).should('be.visible')
    })

    items.slice(lastVisibleItemIndex, lastRenderedItemIndex).forEach(item => {
      cy.findByText(getItemText(item)).should('not.be.visible')
    })
  })
})
```

The complexity comes from
1. Scrolling the list to test that the buffer acts on both sides.
2. When scrolling stops, I don't know in advance which items are visible and which not, that's why the content of `fastScrollVirtualList().then(() => { /* ... */ })` is dynamic.

I return on #2 later, but for this test, I cut the snake's head by removing #1: why do I need to test the entire `buffer` behavior here through a Cypress Component Test? I have a lot of unit tests that check that the internal VirtualList functions do their job. I don't need to re-test the same behavior again. Once `buffer` works, it works on both sides. The test benefit from this choice; now it's way simpler, containing a lot of comments that help the reader!

```tsx
it('Should render only the visible items and the buffered ones when an item is partially visible', () => {
  // ------------------------------------------
  // Arrange

  // creating the data
  const items = [
    // visible ones
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' },
    // visible ones
    { id: 4, name: 'Item 4' },
    // buffered ones
    { id: 5, name: 'Item 5' },
    { id: 6, name: 'Item 6' },
    // non-rendered one
    { id: 7, name: 'Item 7' },
  ];

  const itemHeight = 30;
  // 3 items are fully visible, 1 is partially visible
  const listHeight = 100;
  // 2 items are buffered
  const buffer = 2;

  // mounting the component
  mount(
    <VirtualList
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={RenderItem}
      listHeight={listHeight}
      buffer={buffer}
    />
  );

  // ------------------------------------------
  // Act

  // ------------------------------------------
  // Assert
  cy.findByText('Item 1').should('be.visible');
  cy.findByText('Item 2').should('be.visible');
  cy.findByText('Item 3').should('be.visible');
  cy.findByText('Item 4').should('be.visible');
  cy.findByText('Item 5').should('not.be.visible');
  cy.findByText('Item 6').should('not.be.visible');
  cy.findByText('Item 7').should('not.exist');
});
```

## Test 4, high complexity

Testing the selection is the hardest part of the VirtualList, because:
1. The VirtualList manages keyboard modifiers, allowing simple, additive, subtractive, and range selection.
2. The VirtualList is stateless: we need to wrap it with a stateful wrapper that stores the previous selection to test the additive, subtractive, and range selection.

My old test is very hard or read, because:
1. The stateful wrapper is declared in the body of the test itself, using the test's scope.
2. All the selections are checked out in a single long flow.

Step by step, let's simplify it.

### Moving the abstraction away

The first part of the old test is the following

```tsx
it('When the items are clicked, then they are selected', () => {
  const itemHeight = 30
  const listHeight = 300
  let testItems

  const WithSelectionManagement: React.FC<{
    testHandleSelect: (newSelectedIds: ItemId[]) => {}
  }> = props => {
    const { testHandleSelect } = props
    const items = getStoryItems({ amount: 10000 })

    const [selectedItems, setSelectedItems] = React.useState<(string | number)[]>([])

    const handleSelect = React.useCallback<(params: OnSelectCallbackParams<StoryItem>) => void>(
      ({ newSelectedIds }) => {
        setSelectedItems(newSelectedIds)
        testHandleSelect(newSelectedIds)
      },
      [setSelectedItems, testHandleSelect],
    )

    React.useEffect(() => {
      testItems = items
    }, [items])

    return (
      <VirtualList
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={createSelectableRenderItem({ height: itemHeight })}
        listHeight={listHeight}
        updateScrollModeOnDataChange={{
          addedAtTop: true,
          removedFromTop: true,
          addedAtBottom: true,
          removedFromBottom: true,
        }}
        selectedItemIds={selectedItems}
        onSelect={handleSelect}
      />
    )
  }
  WithSelectionManagement.displayName = 'WithSelectionManagement'

  mount(<WithSelectionManagement testHandleSelect={cy.stub().as('handleSelect')} />)

  /* ... rest of the test ... */
})
```

It's pretty hard reading a test that starts with such a boilerplate. You get lost in a while, losing the critical parts of the test itself. Let's move it away from the test.

```tsx
// wrap the VirtualList to internally manage the selection, passing outside only the new selection
function SelectableList(props) {
  const { onSelect, ...virtualListProps } = props;

  // store the selection in an internal state
  const [selectedItems, setSelectedItems] = React.useState([]);
  const handleSelect = React.useCallback(
    ({ newSelectedIds }) => {
      setSelectedItems(newSelectedIds);
      // call the passed spy to notify the test about the new selected ids
      onSelect({ newSelectedIds });
    },
    [setSelectedItems, onSelect]
  );

  // Transparently renders the VirtualList, apart from:
  // - storing the selection
  // - passing the new selection back to the test
  return (
    <VirtualList
      selectedItemIds={selectedItems}
      onSelect={handleSelect}
      // VirtualList props passed from the test
      {...virtualListProps}
    />
  );
}

it('When two items are clicked pressing the meta button, then they are both selected', () => {
    // ------------------------------------------
    // Arrange

    // creating the data
    const itemHeight = 30;
    const listHeight = 90;
    const items = [
      { id: 1, name: 'Item 1' },
      { id: 2, name: 'Item 2' },
      { id: 3, name: 'Item 3' },
    ];

    // mounting the component
    mount(
      <SelectableList
        // test-specific props
        onSelect={cy.spy().as('onSelect')}
        // VirtualList props
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={RenderItem}
        listHeight={listHeight}
      />
    );

  /* ... rest of the test ... */
})
```

The background noise is still high, but you don't encounter it when you read the test. Then, do you notice that consuming the wrapper moved from
```tsx
mount(<WithSelectionManagement testHandleSelect={cy.stub().as('handleSelect')} />)
```
to
```tsx
mount(
  <SelectableList
    // test-specific props
    onSelect={cy.spy().as('onSelect')}
    // VirtualList props
    items={items}
    getItemHeights={() => itemHeight}
    RenderItem={RenderItem}
    listHeight={listHeight}
  />
);
```
? The purpose is getting the code similar as much as possible to the previous, simpler tests. `SelectableList` is now more transparent, and its code is simpler because it does just one thing: storing the previous selection.

### Splitting the long test

Fasten the seatbelt: apart from the wrapper, the old test is the following

```tsx
it('When the items are clicked, then they are selected', () => {
  /* ... the code of the wrapper ... */

  cy.then(() => expect(testItems).to.have.length.greaterThan(0))
  cy.wrap(testItems).then(() => {
    cy.findByText(getItemText(testItems[0])).click()
    cy.get('@handleSelect').should(stub => {
      expect(stub).to.have.been.calledOnce
      expect(stub).to.have.been.calledWith([testItems[0].id])
    })

    cy.findByText(getItemText(testItems[1])).click().window()
    cy.get('@handleSelect').should(stub => {
      expect(stub).to.have.been.calledTwice
      expect(stub).to.have.been.calledWith([testItems[1].id])
    })

    cy.get('body')
      .type('{meta}', { release: false })
      .findByText(getItemText(testItems[2]))
      .click()
      .get('@handleSelect')
      .should(stub => {
        expect(stub).to.have.been.calledThrice
        expect(stub).to.have.been.calledWith([testItems[1].id, testItems[2].id])
      })
      .get('body')
      .type('{meta}', { release: true })

    cy.get('body')
      .type('{shift}', { release: false })
      .findByText(getItemText(testItems[0]))
      .click()
      .get('@handleSelect')
      .should(stub => {
        expect(stub).to.have.been.callCount(4)
        expect(stub).to.have.been.calledWith([testItems[2].id, testItems[1].id, testItems[0].id])
      })
      .get('body')
      .type('{shift}', { release: true })

    cy.get('body')
      .type('{alt}', { release: false })
      .findByText(getItemText(testItems[1]))
      .click()
      .get('@handleSelect')
      .should(stub => {
        expect(stub).to.have.been.callCount(5)
        expect(stub).to.have.been.calledWith([testItems[2].id, testItems[0].id])
      })
      .get('body')
      .type('{alt}', { release: true })

    fastScrollVirtualList().then(() => {
      const firstRenderedItemIndex = getFirstRenderedItemIndex(testItems, getItemText)
      const firstRenderedItem = testItems[firstRenderedItemIndex]
      const expectedSelectedItemIds = testItems
        .slice(0, firstRenderedItemIndex + 1)
        .map(item => item.id)

      cy.get('body')
        .type('{shift}', { release: false })
        .findByText(getItemText(firstRenderedItem))
        .click()
        .get('@handleSelect')
        .should(stub => {
          expect(stub).to.have.been.callCount(6)
          expect(stub).to.have.been.calledWith(expectedSelectedItemIds)
        })
        .get('body')
        .type('{shift}', { release: true })
    })
  })
})
```

Looking at it now, the weird things are:
- `cy.then(() => expect(testItems).to.have.length.greaterThan(0))` since the items were generated dynamically, I bailed out in case of problems with the  external function.
- `cy.findByText(getItemText(testItems[0])).click()` is too much dynamic, what `testItems[0]` contains?
- The `fastScrollVirtualList().then(() => { /* ... */ }` content ğŸ˜©
- The length of the test itself.
- It's not clear where testing a type of selection ends and where testing the next one begins.

Let's start by removing the need for such an extended test splitting a four-selection test into four ones.

#### Single selection

Guess what? Testing the simple selection doesn't need the wrapper at all ğŸ˜Š

```tsx
it('When an item is clicked, then it is selected', () => {
  // ------------------------------------------
  // Arrange

  // creating the spy
  // a spy is needed to intercept the call the VirtualList does
  const onSelectSpy = cy.spy().as('onSelect');

  // creating the data
  const items = [
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' },
  ];

  // mounting the component
  mount(
    <VirtualList
      items={items}
      getItemHeights={() => 30}
      RenderItem={RenderItem}
      listHeight={90}
      onSelect={onSelectSpy}
    />
  );

  // ------------------------------------------
  // Act
  cy.findByText('Item 1').click();

  // ------------------------------------------
  // Assert
  cy.get('@onSelect').should((spy) => {
    expect(spy).to.have.been.calledOnce;

    // Sinon matchers allow to assert about partials of the params
    // see
    // https://sinonjs.org/releases/latest/assertions/
    // https://sinonjs.org/releases/latest/matchers/
    expect(spy).to.have.been.calledWith(
      Cypress.sinon.match({ newSelectedIds: [1] })
    );
    expect(spy).to.have.been.calledWith(
      Cypress.sinon.match({ item: { id: 1, name: 'Item 1' } })
    );
  });
});
```

The most relevant changes, compared to the first part of the old test:
- No need for the wrapper.
- No more dynamic values.
- More expressive assertions.
- It's a single-purpose test.

#### Additive and subtractive selection

Here we need to leverage the wrapper.

```tsx
it('When two items are clicked pressing the meta button, then they are both selected', () => {
    // ------------------------------------------
    // Arrange

    // creating the data
    const itemHeight = 30;
    const listHeight = 90;
    const items = [
      { id: 1, name: 'Item 1' },
      { id: 2, name: 'Item 2' },
      { id: 3, name: 'Item 3' },
    ];

    // mounting the component
    mount(
      // mount `SelectableList`instead of `VirtualList`
      <SelectableList
        // test-specific props
        onSelect={cy.spy().as('onSelect')}
        // VirtualList props
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={RenderItem}
        listHeight={listHeight}
      />
    );

    // ------------------------------------------
    // click on the first item
    // Act
    cy.findByText('Item 1')
      .click()
      // Assert
      .get('@onSelect')
      .should((spy) => {
        expect(spy).to.have.been.calledOnce;
        expect(spy).to.have.been.calledWith({ newSelectedIds: [1] });
      });

    // ------------------------------------------
    // click on the second item
    // Act
    // keep the meta button  pressed
    cy.get('body').type('{meta}', { release: false });

    cy.findByText('Item 2')
      .click()
      // Assert
      .get('@onSelect')
      .should((spy) => {
        expect(spy).to.have.been.calledTwice;
        expect(spy).to.have.been.calledWith({ newSelectedIds: [1, 2] });
      });
  });
```

The huge difference here is avoiding scrolling because it doesn't affect the additive selection. Again explicit values, clarity, and brevity allow having a more straightforward and more expressive test.

Testing the subtractive selection follows the same pattern. I don't report it here.

#### Range selection

Compared to the previous selections, I think that the range selection **could be** affected by scrolling the list because some items that will be selected aren't rendered anymore. How could I make something that's dynamic by definitionâ€”scrolling the listâ€”more static? Through manual tests and some comments.

```tsx
it('When the list is scrolled amd some items are clicked pressing the shift button, then the range selection works', () => {
  // ------------------------------------------
  // Arrange

  // creating the data
  const items = [
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' },
    { id: 4, name: 'Item 4' },
    { id: 5, name: 'Item 5' },
    { id: 6, name: 'Item 6' },
    { id: 7, name: 'Item 7' },
    { id: 8, name: 'Item 8' },
    { id: 9, name: 'Item 9' },
    { id: 10, name: 'Item 10' },
    { id: 11, name: 'Item 11' },
    { id: 12, name: 'Item 12' },
    { id: 13, name: 'Item 13' },
    { id: 14, name: 'Item 14' },
    { id: 15, name: 'Item 15' },
    { id: 16, name: 'Item 16' },
    { id: 17, name: 'Item 17' },
    { id: 18, name: 'Item 18' },
    { id: 19, name: 'Item 19' },
    { id: 20, name: 'Item 20' },
  ];
  // only 3 items are visible
  const itemHeight = 30;
  const listHeight = 90;

  // mounting the component
  mount(
    <SelectableList
      // test-specific props
      onSelect={cy.spy().as('onSelect')}
      // VirtualList props
      items={items}
      getItemHeights={() => itemHeight}
      RenderItem={RenderItem}
      listHeight={listHeight}
    />
  );

  // Act

  // click on the first item
  cy.findByText('Item 1').click();

  // scroll the list
  cy.findAllByTestId('VirtualList').first().trigger('wheel', {
    deltaX: 0,
    deltaY: 200,
  });

  cy.get('body').type('{shift}', { release: false });

  // Item 7, 8, 9, and 10 are going to be visible after the scroll
  // click on the 10th item. It's going to be clicked as soon as it's in the DOM and clickable
  cy.findByText('Item 10')
    .click()
    // Assert
    .get('@onSelect')
    .should((spy) => {
      expect(spy).to.have.been.calledTwice;
      expect(spy).to.have.been.calledWith({ newSelectedIds: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] });
    });
});
```

The worst thing that could happen here is that the scrolling logics of the VirtualList scroll less or more when triggering the `wheel` event
```tsx
cy.findAllByTestId('VirtualList').first().trigger('wheel', {
  deltaX: 0,
  deltaY: 200,
});
```

but if it happens, the reader has a clear idea of what went wrong because of the comments ğŸ˜Š


## Related chapters

- ğŸ”— [Keep abstraction low to ease debugging the tests](/sections/generic-best-practices/test-code-with-debugging-in-mind.md)

<br/><br/>

*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/from-unreadable-react-component-tests-to-simple-stupid-ones-3ge6).*



================================================
FILE: sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.zh.md
================================================
[Binary file]


================================================
FILE: sections/real-life-examples/test-front-end-with-integration-back-end-with-e2e.md
================================================
# Real life example: *Test the front-end with the integration tests, the back-end with the E2E ones* - in reference to  [Component vs Integration vs E2e Testing](..//testing-strategy/component-vs-integration-vs-e2e-testing.md):

<br/><br/>

### One Paragraph Explainer

UI tests with a stubbed server are [highly reliable and faster](../testing-strategy/component-vs-integration-vs-e2e-testing.md#ui-integration-tests)<!--TODO: check that the deeplinkl works--> in comparison to full E2E tests.

Full E2E tests still provide the highest possible confidence, but at a high cost: being brittle, potentially unreliable, and slow.

We can still achieve high confidence for the front-end by using lower-cost UI integration tests and saving higher cost E2E tests for the back-end.


<br/><br/>

### Sample Test Architecture Diagram

A high-level architectural view from a real-world [Building Controls Cloud application](https://new.siemens.com/global/en/products/buildings/digitalization/building-operator.html).

* Angular front-end
* Node-Express API (back-end)
* Services (Go lambdas) (back-end)
* Hardware (back-end)

> Depending on needs, UI-E2E tests can be supplemented with pure API tests. Some popular tools for API testing are [Postman](https://www.getpostman.com/), [Rest Client for VS COde](https://marketplace.visualstudio.com/items?itemName=humao.rest-client), as well as Cypress.

![](./../../assets/images/test-architecture-example.png)

<br/>

*Please note: all the following examples are for Cypress, it has the best XHR testing support at the moment. [Full XHR request waiting and inspection is not so common](../generic-best-practices/await-dont-sleep.md#xhr-request-waitings) in the existing testing tools, Cypress provides the most complete inspection support at the moment.*

<br/>

### Code Example: Login testing

The following example has 2 tests for covering Login functionality. The first test covers the front-end application with a UI integration trest, the second test covers the back-end with an E2E test.

```javascript
/** function to fill username, password and Login*/
const fillFormAndClick = ({ username, password }) => { .. };

// This is an UI integration test with server stubbing.
// Remember to write a few E2E tests and a lot of integration ones
// @see https://github.com/NoriSte/ui-testing-best-practices/blob/master/sections/testing-strategy/component-vs-integration-vs-e2e-testing.md#ui-integration-tests
it("Login: front-end integration tests", () => {

  // A route that intercepts / sniffs every POST request that goes to the authentication URL.
  // Stubs the response with authentication-success.json fixture. This is called server stubbing
  cy.intercept({
    method: "POST",
    fixture: "authentication/authentication-success.json", // Stubs the response
    url: `**${AUTHENTICATE_API_URL}`
  }).as("auth-xhr");

  fillFormAndClick(USERNAME_PLACEHOLDER, PASSWORD_PLACEHOLDER);

  // wait for the POST XHR
  cy.wait("@auth-xhr").then(interception => {
    // assert the payload body that the front end is sending to the back-end
    expect(interception.request.body).to.have.property("username", username);
    expect(interception.request.body).to.have.property("password", password);
    // assert the request headers in the payload
    expect(interception.request.headers).to.have.property('Content-Type', 'application/json;charset=utf-8');
  });

  // finally, the user must see the feedback
  cy.getByText(SUCCESS_FEEDBACK).should("be.visible");
});

// this is a copy of the integration test but without server stubbing.
it("Login: back-end E2E tests", () => {

  // A route that intercepts / sniffs every POST request that goes to the authentication URL.
  // Distinction: this is NOT stubbed!
  cy.intercept({
    method: "POST",
    url: `**${AUTHENTICATE_API_URL}`
  }).as("auth-xhr");

  fillFormAndClick(USERNAME_PLACEHOLDER, PASSWORD_PLACEHOLDER);

  cy.wait("@auth-xhr").then(interception => {
    // since the integration tests already tested the front-end app, we use E2E tests to check the
    // back-end app. It needs to ensure that the back-end app works and gets the correct response data

    // response body assertions and status should be in the E2E tests since they rely on the server
    expect(interception.status).to.equal(200);
    expect(interception.response.body).to.have.property("token");
  });

  // finally, the user must see the feedback
  cy.getByText(SUCCESS_FEEDBACK).should("be.visible");
});
```

<br/><br/>

### Code Example 2: switching UI integration tests to UI-E2E tests

Sometimes, you may want to switch UI integration tests to E2E tests.

At lower-level test layers - for example when isolating tests to only the UI code - you may prefer to use cost-effective UI integration tests.

At higher level test layers - for example, when you integrate with intermediate level services - you may need higher confidence and target the tests to the back-end.

You can switch focus between UI integration and E2E tests by using a conditional stub.

```javascript
// stub-services.js : a file that only includes a function to stub the back-end services
export default function() {
  // all routes to the specified endpoint will respond with pre-packaged Json data
  cy.intercept('/api/../me', {fixture:'services/me.json'});
  cy.intercept('/api/../permissions', {fixture:'services/permissions.json'});
  // Lots of other fixtures ...
}

// spec file:
import stubServices from '../../support/stub-services';

/** isLocalhost is a function that checks the configuration environment*/
const isLocalHost = () => Cypress.env('ENVIRONMENT') === "localhost";

// ... in your tests, or in before / beforeEach blocks,
// stub the services if you are testing front-end (UI integration tests)
// do not stub if you are testing the back-end (UI-E2E tests)
if (isLocalHost()) {
  stubServices();
}

```


### References

[Mastering UI Testing - conference video](https://www.youtube.com/watch?v=RwWz4hllDtg)
<!-- TODO: in the end, decide if you want to move all the resources to a common chapter too -->



================================================
FILE: sections/real-life-examples/test-front-end-with-integration-back-end-with-e2e.zh.md
================================================
[Binary file]


================================================
FILE: sections/server-communication-testing/monitoring-tests.md
================================================
# Monitoring tests

<br/><br/>

### One Paragraph Explainer

The more the front-end expectations grow, the more the server and services complexity grows. Front-end applications need to be faster every day: code splitting, lazy loading, brotli compression and a lot of other performance-oriented solutions became a standard during the last years. Not to cite some amazing solutions like code splitting and resources preloading based on machine learning and analytics data. More: JAMstack site generators are useful to avoid manually managing a lot of performance optimizations but their configuration and their build processes could break an **already tested feature**.

There are a lot of features that we take for granted once tested that are not regression-free and that could lead to disasters. Some examples could be:
- `sitemap.xml` and `robots.txt` crawling configurations (usually different for every environment)
- Brotli/gzip served assets: a wrong content-encoding could break all the site functionalities
- cache management with different configurations for static or dynamic assets

They could seem obvious things but they are more subtle then what you think. If you care about the good user experience you should keep it monitored because it's usually too late when you discover that something did not work. You could not monitor everything, I know, but the more you test your applications, the more you leverage tests as your first quality checker.

Monitoring tests could also be integrated with E2E ones (after all, they are super-simple E2E tests) but keeping them separated helps you running them-only if you need. Most of the above-cited things are DevOps-related and having super-fast monitoring tests allows you to have immediate and focused feedbacks.

<br/><br/>

## Cypress examples

Cache monitoring tests

```javascript
const urls = {
  staging: "https://staging.example.com",
  production: "https://example.com",
}

const shouldNotBeCached = (xhr) => cy.wrap(xhr).its("headers.cache-control").should("equal", "public,max-age=0,must-revalidate")
const shouldBeCached = (xhr) => cy.wrap(xhr).its("headers.cache-control").should("equal", "public,max-age=31536000,immutable")
// extract the main JS file from the source code of the page
const getMainJsUrl = pageSource => "/app-56a3f6cb9e6156c82be6.js"

context('Site monitoring', () => {
  context('The HTML should not be cached', () => {
    const test = url =>
      cy.request(url)
        .then(shouldNotBeCached)

    it("staging", () => test(urls.staging))
    it("production", () => test(urls.production))
  })

  context('The static assets should be cached', () => {
    const test = url =>
      cy.request(url)
        .its("body")
        .then(getMainJsUrl)
        .then(appUrl => url+appUrl)
        .then(cy.request)
        .then(shouldBeCached)

    it('staging', () => test(urls.staging))
    it('production', () => test(urls.production))
  })
})
```

Content encoding monitoring tests

```javascript
context('The Brotli-compressed assets should be served with the correct content encoding', () => {
  const test = url => {
    cy.request(url)
    .its("body")
    .then(getMainJsUrl)
    .then(appUrl => cy.request({url: url + appUrl, headers: {"Accept-Encoding": "br"}})
      .its("headers.content-encoding")
      .should("equal", "br"))
  }

  it('staging', () => test(urls.staging))
  it('production', () => test(urls.production))
})
```

Crawling monitoring tests
```javascript
context('The robots.txt file should disallow the crawling of the staging site and allow the production one', () => {
  const test = (url, content) =>
    cy.request(`${url}/robots.txt`)
      .its("body")
      .should("contain", content)

  it('staging', () => test(urls.staging, "Disallow: /"))
  it('production', () => test(urls.production, "Allow: /"))
})
```

<br /><br />

*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/the-concept-of-monitoring-tests-4l5j) and [Medium](https://medium.com/@NoriSte/the-concept-of-monitoring-tests-d7cb5af514e5).*



================================================
FILE: sections/server-communication-testing/monitoring-tests.zh.md
================================================
[Binary file]


================================================
FILE: sections/server-communication-testing/test-request-and-response-payload.md
================================================
# Test the request and response payloads

<br/><br/>

### One Paragraph Explainer

How many times the front-end application stops working because of a misaligned communication with the back-end?

The front-end application and the back-end one have a contract, and you always need to test contract compliance. Every communication between the two apps is defined by:

- its URL
- the HTTP verb used (GET, POST, etc.)
- the request payload and headers: the data that the front-end application sends to the back-end one
- the response payload, headers, and status: the data that the back-end application sends back to the front-end one

You need to test all of them and, more in general, you need to wait for every relevant AJAX request, why?

- a relevant XHR request is part of the application flow that you're testing
- if an XHR request is not part of the flow that you're testing, it could be relevant to reach the desired UI state
- waiting for XHR requests make your test more robust, see the [Await, don't sleep](/sections/generic-best-practices/await-dont-sleep.md) chapter and its [XHR request waitings](/sections/generic-best-practices/await-dont-sleep.md#xhr-request-waitings) section

Full XHR request waiting and inspection is not so common in the existing testing tools, Cypress provides the most complete inspection support at the moment.

<br/><br/>

*Please note: all the following examples are for Cypress, it has the best XHR testing support at the moment.*

## Asserting about an XHR request, a complete example

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // request headers assertion
  expect(interception.request.headers).to.have.property("Content-Type", "application/json");
  // request payload assertions
  expect(interception.request.body).to.have.property("username", "admin");
  expect(interception.request.body).to.have.property("password", "asupersecretpassword");
  // status assertion
  expect(interception.response.statusCode).to.equal(200);
  // response headers assertions
  expect(interception.response.body).to.have.property("access-control-allow-origin", "*");
  // response payload assertions
  expect(interception.response.body).to.have.property("token");
});
```

In the next sections, we are going to split the different characteristics of an XHR request.





<details><summary>Asserting about the XHR request URL</summary>

With Cypress, the URL used for the request is defined with the `cy.intercept` call. You could need to inspect the query string of the URL.

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("**/authentication**").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // query string assertion
  expect(interception.request.url).to.contain("username=admin");
  expect(interception.request.url).to.contain("password=asupersecretpassword");
});
```

Please note that the `then => expect` syntax of Cypress is helpful when you need to assert about multiple subjects (ex. both the URL and the status). If you need to assert about a single subject you could use more expressive `should` syntax

```javascript
cy.wait("@authentication-xhr")
  .its("url")
  .should("contain", "username=admin")
  .and("contain", "password=asupersecretpassword");
```
</details>





<details><summary>The XHR request method</summary>

With Cypress, the method used for the request is defined calling the `cy.intercept` function. You specify it to define what kind of request you want to intercept.

```javascript
// the most compact `cy.intercept` call, the GET method is implied
cy.intercept("**/authentication").as("authentication-xhr");

// method can be explicitly defined
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// the extended `cy.intercept` call is available too
cy.intercept({
  method: "POST",
  url: "**/authentication"
}).as("authentication-xhr");
```
</details>





<details><summary>Asserting about the XHR request payload and headers</summary>

Asserting about the request payload and headers allows you to have immediate and detailed feedback about the reason for a bad XHR request. They must be checked on every single XHR request to be sure that everything represents correctly the UI actions the test makes.

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // request headers assertion
  expect(interception.request.headers).to.have.property("Content-Type", "application/json");
  // request payload assertions
  expect(interception.request.body).to.have.property("username", "admin");
  expect(interception.request.body).to.have.property("password", "asupersecretpassword");
});
```
</details>




<details><summary>Asserting about the XHR response payload, headers, and status</summary>

The response must adhere 100% to what the front-end application expects, otherwise, an unexpected state could be shown to the user. Response assertions are useful for full E2E tests, while they're useless in UI integration tests (TODO: link the integration test page).

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(intercept => {
  // status assertions
  expect(intercept.response.statusCode).to.equal(200);
  // response headers assertions
  expect(intercept.response.body).to.have.property("access-control-allow-origin", "*");
  // response payload assertions
  expect(intercept.response.body).to.have.property("token");
});
```
</details>



================================================
FILE: sections/server-communication-testing/test-request-and-response-payload.zh.md
================================================
# æ£€éªŒè¯·æ±‚å’Œå“åº”è´Ÿè½½

<br/><br/>

## ä¸€æ®µç®€è¦è¯´æ˜

å‰ç«¯åº”ç”¨å› ä¸åç«¯é€šä¿¡ä¸åè°ƒè€Œå¯¼è‡´åœæ­¢å·¥ä½œçš„é¢‘ç‡æœ‰å¤šé«˜ï¼Ÿ

å‰ç«¯åº”ç”¨å’Œåç«¯åº”ç”¨ä¹‹é—´å­˜åœ¨ä¸€ä»½åˆåŒï¼Œä½ å§‹ç»ˆéœ€è¦æµ‹è¯•åˆåŒæ˜¯å¦å¾—åˆ°éµå®ˆã€‚æ¯ä¸€æ¬¡å‰åç«¯åº”ç”¨ä¹‹é—´çš„é€šä¿¡éƒ½ç”±ä»¥ä¸‹å‡ ä¸ªæ–¹é¢å®šä¹‰ï¼š

- è¯·æ±‚çš„ URL
- æ‰€ä½¿ç”¨çš„ HTTP åŠ¨è¯ï¼ˆGETã€POST ç­‰ï¼‰
- è¯·æ±‚çš„æœ‰æ•ˆè´Ÿè½½å’Œæ ‡å¤´ï¼šå‰ç«¯åº”ç”¨å‘é€ç»™åç«¯åº”ç”¨çš„æ•°æ®
- å“åº”çš„æœ‰æ•ˆè´Ÿè½½ã€æ ‡å¤´å’ŒçŠ¶æ€ï¼šåç«¯åº”ç”¨å‘é€å›å‰ç«¯åº”ç”¨çš„æ•°æ®

ä½ éœ€è¦å¯¹æ‰€æœ‰è¿™äº›æ–¹é¢è¿›è¡Œæµ‹è¯•ï¼Œæ›´å¹¿ä¹‰åœ°è¯´ï¼Œä½ éœ€è¦ç­‰å¾…æ¯ä¸ªç›¸å…³çš„ AJAX è¯·æ±‚ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

- ç›¸å…³çš„ XHR è¯·æ±‚æ˜¯ä½ æ­£åœ¨æµ‹è¯•çš„åº”ç”¨ç¨‹åºæµç¨‹çš„ä¸€éƒ¨åˆ†
- å³ä½¿ XHR è¯·æ±‚ä¸æ˜¯ä½ æ­£åœ¨æµ‹è¯•çš„æµç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒå¯¹è¾¾åˆ°æœŸæœ›çš„ UI çŠ¶æ€ä¹Ÿå¯èƒ½æ˜¯ç›¸å…³çš„
- ç­‰å¾… XHR è¯·æ±‚å¯ä»¥ä½¿ä½ çš„æµ‹è¯•æ›´ä¸ºå¥å£®ï¼Œå‚è§[ç­‰å¾…ï¼Œä¸è¦ä¼‘çœ ](/sections/generic-best-practices/await-dont-sleep.zh.md)ç« èŠ‚åŠå…¶[XHR è¯·æ±‚ç­‰å¾…](/sections/generic-best-practices/await-dont-sleep.zh.md#XHR-è¯·æ±‚ç­‰å¾…)éƒ¨åˆ†

åœ¨ç°æœ‰çš„æµ‹è¯•å·¥å…·ä¸­ï¼Œå®Œå…¨ç­‰å¾…å’Œæ£€æŸ¥ XHR è¯·æ±‚å¹¶ä¸é‚£ä¹ˆå¸¸è§ï¼Œç›®å‰ Cypress æä¾›äº†æœ€å…¨é¢çš„æ£€æŸ¥æ”¯æŒã€‚

<br/><br/>

*è¯·æ³¨æ„ï¼šä»¥ä¸‹æ‰€æœ‰ç¤ºä¾‹å‡åŸºäº Cypressï¼Œå®ƒç›®å‰æä¾›äº†æœ€ä½³çš„ XHR æµ‹è¯•æ”¯æŒã€‚*

## å¯¹ XHR è¯·æ±‚è¿›è¡Œæ–­è¨€çš„å®Œæ•´ç¤ºä¾‹

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // request headers assertion
  expect(interception.request.headers).to.have.property("Content-Type", "application/json");
  // request payload assertions
  expect(interception.request.body).to.have.property("username", "admin");
  expect(interception.request.body).to.have.property("password", "asupersecretpassword");
  // status assertion
  expect(interception.response.statusCode).to.equal(200);
  // response headers assertions
  expect(interception.response.body).to.have.property("access-control-allow-origin", "*");
  // response payload assertions
  expect(interception.response.body).to.have.property("token");
});
```

åœ¨ä¸‹é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†è®¨è®º XHR è¯·æ±‚çš„ä¸åŒç‰¹å¾ã€‚

<details><summary>éªŒè¯ XHR è¯·æ±‚çš„ URL</summary>

åœ¨ Cypress ä¸­ï¼Œç”¨äºè¯·æ±‚çš„ URL æ˜¯é€šè¿‡`cy.intercept`è°ƒç”¨å®šä¹‰çš„ã€‚ä½ å¯èƒ½éœ€è¦æ£€æŸ¥ URL çš„æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("**/authentication**").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // query string assertion
  expect(interception.request.url).to.contain("username=admin");
  expect(interception.request.url).to.contain("password=asupersecretpassword");
});
```

è¯·æ³¨æ„ï¼Œå½“ä½ éœ€è¦å¯¹å¤šä¸ªä¸»é¢˜è¿›è¡Œæ–­è¨€æ—¶ï¼ŒCypress çš„`then => expect`è¯­æ³•éå¸¸æœ‰å¸®åŠ©ï¼ˆä¾‹å¦‚ï¼ŒURL å’ŒçŠ¶æ€ï¼‰ã€‚å¦‚æœä½ åªéœ€è¦å¯¹å•ä¸ªä¸»é¢˜è¿›è¡Œæ–­è¨€ï¼Œå¯ä»¥ä½¿ç”¨æ›´å…·è¡¨ç°åŠ›çš„`should`è¯­æ³•ã€‚

```javascript
cy.wait("@authentication-xhr")
  .its("url")
  .should("contain", "username=admin")
  .and("contain", "password=asupersecretpassword");
```

</details>

<details><summary>XHR è¯·æ±‚çš„æ–¹æ³•</summary>

åœ¨ Cypress ä¸­ï¼Œè¯·æ±‚ä½¿ç”¨`cy.intercept`å‡½æ•°å®šä¹‰ã€‚ä½ å¯ä»¥é€šè¿‡æŒ‡å®šå®ƒæ¥å®šä¹‰è¦æ‹¦æˆªçš„è¯·æ±‚ç±»å‹ã€‚

```javascript
// the most compact `cy.intercept` call, the GET method is implied
cy.intercept("**/authentication").as("authentication-xhr");

// method can be explicitly defined
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// the extended `cy.intercept` call is available too
cy.intercept({
  method: "POST",
  url: "**/authentication"
}).as("authentication-xhr");
```

</details>

<details><summary>éªŒè¯ XHR è¯·æ±‚çš„ payload å’Œ headers</summary>

å¯¹ XHR è¯·æ±‚çš„ payload å’Œ headers è¿›è¡Œæ–­è¨€å…è®¸ä½ ç«‹å³è·å¾—æœ‰å…³ç³Ÿç³•çš„ XHR è¯·æ±‚åŸå› çš„è¯¦ç»†åé¦ˆã€‚å¿…é¡»åœ¨æ¯ä¸ª XHR è¯·æ±‚ä¸Šè¿›è¡Œæ£€æŸ¥ï¼Œä»¥ç¡®ä¿ä¸€åˆ‡éƒ½æ­£ç¡®åœ°è¡¨ç¤ºäº†æµ‹è¯•æ‰§è¡Œçš„ UI æ“ä½œã€‚

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(interception => {
  // request headers assertion
  expect(interception.request.headers).to.have.property("Content-Type", "application/json");
  // request payload assertions
  expect(interception.request.body).to.have.property("username", "admin");
  expect(interception.request.body).to.have.property("password", "asupersecretpassword");
});
```

</details>

<details><summary>éªŒè¯ XHR è¯·æ±‚å“åº”çš„ payload, headers å’Œ status</summary>

å“åº”å¿…é¡»ç™¾åˆ†ä¹‹ç™¾ç¬¦åˆå‰ç«¯åº”ç”¨çš„é¢„æœŸï¼Œå¦åˆ™å¯èƒ½å‘ç”¨æˆ·å±•ç¤ºæ„æ–™ä¹‹å¤–çš„çŠ¶æ€ã€‚å“åº”æ–­è¨€åœ¨å®Œæ•´çš„ç«¯åˆ°ç«¯æµ‹è¯•ä¸­å¾ˆæœ‰ç”¨ï¼Œä½†åœ¨ UI é›†æˆæµ‹è¯•ä¸­åˆ™æ— å…³ç´§è¦ï¼ˆTODOï¼šé“¾æ¥åˆ°é›†æˆæµ‹è¯•é¡µé¢ï¼‰ã€‚

```javascript
// ask Cypress to intercept every XHR request made to a URL ending with `/authentication`
cy.intercept("POST", "**/authentication").as("authentication-xhr");

// ... your test actions...

cy.wait("@authentication-xhr").then(intercept => {
  // status assertions
  expect(intercept.response.statusCode).to.equal(200);
  // response headers assertions
  expect(intercept.response.body).to.have.property("access-control-allow-origin", "*");
  // response payload assertions
  expect(intercept.response.body).to.have.property("token");
});
```

</details>



================================================
FILE: sections/testing-perks/tests-as-documentation.md
================================================
# Software tests as a documentation tool

<br/><br/>

### One Paragraph Explainer

Documenting is generally hard, it requires precise and meticulous work and it requires that all the members of the team understand and value writing good documentation. Documenting is selfless and it is **helpful for both other developers and the future you**.

Testing methodologies are a great way not only to be sure that we code what the project needs, not only to grant we do not introduce regressions but to document the code and the user flows too.

The perks that come from using the tests as a documentation tool are:

- **the documentation is coupled** with what the code has been created for: all the UI tests should be written from the user perspective and their descriptions either. Watching what the user is able to do with the project is a really effective way to know the project from a functional point of view.<br>Every codebase is composed of thousands of small pieces of code and sometimes **it could be hard to connect all the dots**. The tests could allow a general understanding of the project and even a lot of technical details.

  <!-- TODO: add a link to the blackbox testing chapter -->

- you do **not rely on the historical memory** of some employees: a lot of times you end up asking to some employees that know the project and remember some particular edge cases. A good test suite can reduce a lot the needed for this kind of knowledge and avoid every fresh developer to add regressions with a few lines of code.

- at the same time, the **handover and onboarding** phases become quite easy.

Bonus point: if you leverage the [Gherkin](https://cucumber.io/docs/gherkin/reference/) syntax, the documentation effectiveness is increased even for some less-technical people like a QA team.

Please, keep in mind that:

- test descriptions must be clear even for developers that do not know the project context the same way as you.

- the re-used test functions, fixtures, etc. must have meaningful names. A `registration-success.json` fixture used for both the sign-up and the login tests could mislead the future reader and make historical knowledge needed. Remember that relying on historical knowledge is always negative for a codebase that must survive the developers' turnover.

- in general, UI Testing plays a fundamental role in a front-end application, they are the only ones that document the real goals the user is expected to be able to accomplish.

- the code of the tests must as simple as possible. Simple to be read, condition-free, with a low-abstraction level, with a good level of logging, etc. Always remember that **the tests must reduce the cognitive load of reading and understanding the code**, hence their complexity should be an order of magnitude lower compared to the code to be understood. This improves the deepening process that a developer must go through just after have watched the tests in the automated browser.

  <!-- TODO: add a link to the chapter that speaks about why the test code must be simple -->

- "connect" the code with the tests: if a user flow is quite long, it could be useful to share some "steps" (with some comments) between the source code and the code of the tests. Something like `/** #1 \*/`, `/** #2 \*/`, etc.

- UI tests are not the only ones: having more low-level tests for parts of the code that could be hard to be understood is a great way to describe the code expected behaviors.

- comments in the test could help a lot the reader, look at the ["Matching the test's code and test runner's commands" section of the "Keep abstraction low to ease debugging the tests" chapter](../generic-best-practices/test-code-with-debugging-in-mind.md#matching-the-tests-code-and-test-runners-commands).

## Related chapters

- ğŸ”— [Found a bug? Write the test, then fix it](/sections/testing-strategy/write-test-then-fix-bug.md)
- ğŸ”— [Name the test files wisely](/sections/generic-best-practices/name-test-files-wisely.md)
- ğŸ”— [Use your testing tool as your primary development tool](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md)
- ğŸ”— [Keep abstraction low to ease debugging the tests](/sections/generic-best-practices/test-code-with-debugging-in-mind.md)
- ğŸ”— [Test the request and response payloads](/sections/server-communication-testing/test-request-and-response-payload.md)



================================================
FILE: sections/testing-perks/tests-as-documentation.zh.md
================================================
[Binary file]


================================================
FILE: sections/testing-strategy/avoid-perfectionism.md
================================================
# In the beginning, avoid perfectionism

<br/>

### One Paragraph Explainer

Testing really changes the way you work but, like everything, it requires a bit of experience to get the best of it. In the beginning, avoid perfectionism at all. Why?

- tests are little programs after all. Perfectionism could drive you to write **extremely complex tests** before knowing how to manage the different testing contexts.

  Tests complexity is a big enemy because debugging a failing test is harder than debugging a failing application. And complex tests make you lose the advantage of testing practices themselves, make you lose a lot of time, and inevitably make you exclude them sooner or later. **If it happens to you don't give up**, it's the same for a lot of testing beginners (it was the same for me, that's why I started writing this repo ğŸ˜Š) and do not be afraid of asking your colleagues or publicly to other developers.

- false negatives: perfectionism-driven tests lead to a lot of false negatives. A false negative is a situation where your application works as expected but the test fails.

  **False negatives are really de-motivating** at the beginning because you started writing tests to have an ally in checking the application status... But you ended up with another application to maintain with no help from the tests. If you realize you are fighting with false negatives, stop yourself, restart studying and ask for help!

- tests utility: successful tests drive you directly to the problem when they fail. The right assertions and [deterministic events](/sections/generic-best-practices/await-dont-sleep.md) make your tests robust and, super important, useful if they fail. At the opposite, too much assertions/checks could make your tests brittle because of their uselessness

What do you mean for perfectionism? I mean checking every front-end detail. Your working experience allows you to write complex user interactions but, in the beginning, your limited testing experience do not allow you to test all of the interactions profitably. Start testing the easiest things like
- is my page loading correctly?
- do the menu buttons works?
- can the user fill the form and reach the thank you page?

and forget, in the beginning, to test things like
- conditional data loading
- complex form rules
- uncontrolled (third party) integrations
- element selectors

<br />

A beginning todo list to avoid falling into the perfectionism trap could be:

1. choose the simplest thing to test (something that's useful for the users)
2. think about it from the users perspective. Remember that the **users care about contents and functionalities**, not about selectors and internal application states
3. write your test
4. run it more than once to be sure that it's stable
5. when it succeeds, insert a bug into the front-end app that breaks it and checks that the test fails. Then, remove your made-on-purpose bug
6. run the test both in headless and non-headless mode
7. think about, based on your experience (ask your colleagues too), what are the reasons that could break the front-end application from the perspective of what you're testing
8. simulate the different front-end failures (kill the server, insert other bugs) and check if the test gives you enough feedback to understand what failed
9. do that for just two or three kinds of failures, remember that your limited experience could drive you to test the wrong things
10. then, move to another thing to test and repeat all the previous steps

Software testing is an amazing journey and the goal of this repo is helping you avoid the most common pitfalls.

The suggested flow is just one of the possible approaches. I know that everything is subjective and please, open a PR for every suggestion!

## Related chapters

- ğŸ”— [From unreadable React Component Tests to simple, stupid ones](/sections/real-life-examples/from-unreadable-react-component-tests-to-simple-ones.md)
- ğŸ”— [Use your testing tool as your primary development tool](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md)



================================================
FILE: sections/testing-strategy/avoid-perfectionism.zh.md
================================================
[Binary file]


================================================
FILE: sections/testing-strategy/choose-a-reference-browser.md
================================================
# Choose a reference browser

<br/>

### One Paragraph Explainer

Everyone cares about cross-browser testing. We are used to manually testing everything on every browser because, we know, there are a lot of browser differences. Obviously, we'd like to have the same cross-browser support from the tool we use to test our front-end application... But the reality is that cross-browser support is very limited.

Don't take for granted that testing everything on every browser is always the best solution. Try to think about what you need to test before choosing a testing tool. Think that:

- **Selenium, and Puppeteer are generic automation tools**. They can be used as testing tools (there are a lot of plugins and modules that help you do that) but they are not created with testing in mind so they miss some integrated utilities that could simplify your life as a test writer.

- consider only **Cypress, Playwright, and TestCafÃ©** because they are both tools created to **simplify the UI testing process**. Half of the best practices you should care in your tests are automatically managed by Cypress/Playwright/TestCafÃ© out of the box. Choosing the right testing tool is all about finding the right trade-off. UI testing is hard by definition so, spend some time experimenting with the mentioned tools.

- think about what you need to test. Choose [TestCafÃ©](https://testcafe.devexpress.com) if you need to test a particular mobile capability, but if you need to test that the forms and the buttons work you are less limited with your choice.

- take a look at the [Cypress Test Runner](https://docs.cypress.io/guides/core-concepts/test-runner.html#Command-Log), it's what makes Cypress outstanding and it's a precious ally during test development.

- take a look at what [Playwright offers in terms of debugging](https://playwright.dev/docs/trace-viewer-intro). Playwright is very fast and stable, and its DX improved a lot recently.

- cross-browser testing is usually related to visual testing (CSS browser differences) but this is not related to functional testing. Visual testing is made easy by a lot of dedicated plugins and tools. Take a look at [the dedicated chapter](../tools/visual-regression-testing.md) [Applitools](https://applitools.com) where we talk about some dedicated products that can be integrated with almost all the testing tools and work by uploading a snapshot of the page under test into their servers and render them.

You can also take a sneak peek at some differences between the various testing tools into the [Await, don't sleep](/sections/generic-best-practices/await-dont-sleep.md) chapter.

## Related chapters

- ğŸ”— [Combinatorial Testing](/sections/advanced/combinatorial-testing.md)



================================================
FILE: sections/testing-strategy/choose-a-reference-browser.zh.md
================================================
# é€‰æ‹©ä¸€ä¸ªå‚è€ƒæµè§ˆå™¨

<br/>

## ä¸€æ®µç®€è¦è¯´æ˜

æ¯ä¸ªäººéƒ½å…³å¿ƒè·¨æµè§ˆå™¨æµ‹è¯•ã€‚æˆ‘ä»¬é€šå¸¸ä¹ æƒ¯åœ¨æ¯ä¸ªæµè§ˆå™¨ä¸Šæ‰‹åŠ¨æµ‹è¯•æ‰€æœ‰å†…å®¹ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ï¼Œä¸åŒæµè§ˆå™¨ä¹‹é—´å­˜åœ¨è®¸å¤šå·®å¼‚ã€‚å½“æˆ‘ä»¬å¼€å§‹è¯„ä¼°åˆé€‚çš„æµ‹è¯•å·¥å…·æ—¶ï¼Œè·¨æµè§ˆå™¨æµ‹è¯•æ˜¯ä¸€ä¸ªé‡è¦çš„è¯é¢˜ï¼Œä¹Ÿæ˜¯ä½ åœ¨è€ƒè™‘æ—¶å¯èƒ½é¦–å…ˆæƒ³åˆ°çš„ã€‚ä½†æ˜¯ä¸è¦æ‹…å¿ƒï¼šé¦–å…ˆä»åŠŸèƒ½æµ‹è¯•å’Œè§†è§‰æµ‹è¯•åˆ†ç¦»å¼€å§‹ï¼Œè¿™æ˜¯æ­£ç¡®è¯„ä¼°è·¨æµè§ˆå™¨æ”¯æŒéœ€æ±‚ï¼ˆä¹Ÿæ˜¯é€‰æ‹©æ­£ç¡®æµ‹è¯•å·¥å…·çš„ç¬¬ä¸€æ­¥ï¼‰ã€‚è§†è§‰æµ‹è¯•å¯ä»¥é›†æˆåˆ°æ¯ä¸ªæµ‹è¯•å·¥å…·ä¸­ï¼Œæ„Ÿè°¢è¯¸å¦‚ Applitools å’Œ Percy è¿™æ ·çš„æœåŠ¡ã€‚

æ¢å¥è¯è¯´ï¼Œä¸è¦ä»…ä»…åŸºäºè·¨æµè§ˆå™¨æ”¯æŒæ¥é€‰æ‹©æµ‹è¯•å·¥å…·ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å»ºè®®ï¼š

- **Selenium å’Œ Puppeteer æ˜¯é€šç”¨çš„è‡ªåŠ¨åŒ–å·¥å…·**ã€‚å®ƒä»¬å¯ä»¥ç”¨ä½œæµ‹è¯•å·¥å…·ï¼ˆæœ‰è®¸å¤šæ’ä»¶å’Œæ¨¡å—å¯å¸®åŠ©ä½ å®ç°ï¼‰ï¼Œä½†å®ƒä»¬å¹¶éä¸“ä¸ºæµ‹è¯•è€Œè®¾è®¡ï¼Œå› æ­¤å®ƒä»¬ç¼ºå°‘ä¸€äº›é›†æˆå®ç”¨å·¥å…·ï¼Œè¿™å¯èƒ½ä½¿æµ‹è¯•ç¼–å†™æ›´åŠ ç®€ä¾¿ã€‚

- åªè€ƒè™‘ **Cypressã€Playwright å’Œ TestCafÃ©**ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸“ä¸º**ç®€åŒ– UI æµ‹è¯•è¿‡ç¨‹**è€Œåˆ›å»ºçš„å·¥å…·ã€‚è¿™äº›å·¥å…·è‡ªåŠ¨å¤„ç†ä¸€åŠçš„æœ€ä½³å®è·µï¼Œè€Œåœ¨æµ‹è¯•ä¸­çš„ä¸€äº›æ–¹é¢ï¼Œå®ƒä»¬å¯èƒ½æ›´ç¬¦åˆä½ çš„éœ€æ±‚ã€‚åœ¨ UI æµ‹è¯•æ–¹é¢ï¼Œç”±äºå…¶

å›°éš¾æ€§ï¼ŒèŠ±äº›æ—¶é—´è¯•éªŒè¿™äº›å·¥å…·æ˜¯å€¼å¾—çš„ã€‚

- ä»”ç»†æ€è€ƒä½ éœ€è¦æµ‹è¯•ä»€ä¹ˆã€‚å¦‚æœä½ éœ€è¦æµ‹è¯•ç‰¹å®šçš„ç§»åŠ¨èƒ½åŠ›ï¼Œè¯·é€‰æ‹© [TestCafÃ©](https://testcafe.devexpress.com)ï¼Œä½†å¦‚æœä½ åªéœ€è¦æµ‹è¯•è¡¨å•å’ŒæŒ‰é’®æ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œä½ åœ¨é€‰æ‹©ä¸Šå°±æ›´åŠ çµæ´»ã€‚

- æŸ¥çœ‹ [Cypress Test Runner](https://docs.cypress.io/guides/core-concepts/test-runner.html#Command-Log)ï¼Œè¿™æ˜¯ä½¿ Cypress å¼‚äºå¸¸äººçš„å·¥å…·ï¼Œå¯¹äºæµ‹è¯•å¼€å‘è¿‡ç¨‹ä¸­éå¸¸æœ‰å¸®åŠ©ã€‚

- ç ”ç©¶ [Playwright åœ¨è°ƒè¯•æ–¹é¢çš„ä¼˜åŠ¿](https://playwright.dev/docs/trace-viewer-intro)ã€‚Playwright éå¸¸å¿«é€Ÿç¨³å®šï¼Œæœ€è¿‘å…¶å¼€å‘ä½“éªŒæœ‰äº†å¾ˆå¤§æ”¹è¿›ã€‚

- è·¨æµè§ˆå™¨æµ‹è¯•é€šå¸¸æ¶‰åŠåˆ°è§†è§‰æµ‹è¯•ï¼ˆCSS æµè§ˆå™¨å·®å¼‚ï¼‰ï¼Œä½†è¿™ä¸åŠŸèƒ½æµ‹è¯•ä¸åŒã€‚è§†è§‰æµ‹è¯•å¾—ç›Šäºè®¸å¤šä¸“ç”¨æ’ä»¶å’Œå·¥å…·çš„æ”¯æŒã€‚è¯¦ç»†äº†è§£ [è§†è§‰æµ‹è¯•å¯¹åº”çš„ç« èŠ‚](../tools/visual-regression-testing.zh.md) [Applitools](https://applitools.com)ï¼Œå…¶ä¸­æˆ‘ä»¬è®¨è®ºäº†ä¸€äº›ä¸“ç”¨äº§å“ï¼Œè¿™äº›äº§å“å¯ä»¥ä¸å‡ ä¹æ‰€æœ‰æµ‹è¯•å·¥å…·é›†æˆï¼Œé€šè¿‡å°†è¢«æµ‹è¯•é¡µé¢çš„å¿«ç…§ä¸Šä¼ åˆ°å…¶æœåŠ¡å™¨å¹¶è¿›è¡Œå‘ˆç°æ¥è¿›è¡Œå·¥ä½œã€‚

ä½ è¿˜å¯ä»¥åœ¨ [ç­‰å¾…ï¼Œä¸æ˜¯ä¼‘çœ ](/sections/generic-best-practices/await-dont-sleep.zh.md) ç« èŠ‚ä¸­äº†è§£å„ç§æµ‹è¯•å·¥å…·ä¹‹é—´çš„ä¸€äº›å·®å¼‚ã€‚

## ç›¸å…³ç« èŠ‚

- ğŸ”— [ç»„åˆæµ‹è¯•](/sections/advanced/combinatorial-testing.zh.md)



================================================
FILE: sections/testing-strategy/component-vs-integration-vs-e2e-testing.md
================================================
# Component vs (UI) Integration vs E2E tests

<br/>

### One Paragraph Explainer

Speaking about UI Testing (remember that we are speaking about the UI only, not the underlying JavaScript code), there are three main test types:
- **Component tests**: the unit tests of a UI, they test every single component in an isolated environment.

  Developing components in isolation is important because it allows you to isolate them from the corresponding container/use. A component exists to isolate a single behavior/content (the [Single responsibility principle](https://www.wikiwand.com/en/Single_responsibility_principle)) and therefore, coding it in isolation is profitable.

  There are many ways and tools to develop components in isolation but [Storybook](https://storybook.js.org) became the standard choice because of its effectiveness and its ecosystem. The latest Storybook versions wrap the excellent [Vitest Browser Mode](https://vitest.dev/guide/browser/), which is the fastest way to test UI components in isolation.

  Components have three types of contracts: the exposed data (**HTML**), their visual aspect (**CSS**), and the external APIs (**props and callbacks**). Testing every aspect could be cumbersome, that's where [Storybook](https://storybook.js.org/) comes in handy. It allows you to automate:
  - **the a11y (accessibility) tests**: HTML serves different purposes, SEO and a11y for example, and testing the accessibility of the HTML is the most thorough way to ensure HTML is semantically correct and maintain a high-level of compatibility with screen readers. As a result, SEO benefits too.
  - **the visual regression tests**: the visual aspect of the component compared **pixel by pixel** with the previous one, again, you are prompted to choose if you accept the changes or not.
  - **the interaction tests**: some interactions with a component expect correct state management. This kind of test must be written from the consumer point of view, not from the inner one (ex. the value of the input field when the user fills it, not the inner component state). An interaction/state test should assert the input field value after the keyboard events triggered. If the callbacks accepted by the component are correctly called is testable through this type of tests.


- <strong id="ui-integration-tests">UI integration tests</strong>: they run the whole app in a real browser **without hitting a real server**. These tests are the ace in the hole of every front-end developer. They are blazing fast and less exposed to random failures or false negatives.

  The front-end application does not know that there is not a real server: every AJAX call is resolved in no time by the testing tool. Static JSON responses (called "fixtures") are used to simulate the server responses. Fixtures allow us to test the front-end state simulating every possible back-end state.

  Another interesting effect: Fixtures **allow you to work without a working back-end** application. You can think about UI integration tests as "front-end-only tests".

  At the core of the most successful test suites, there is a lot of UI integration tests, considering the best type of test for your front-end app.

- **End-to-end (E2E) tests**: they run the whole app interacting with the real server. From the user interactions (one of the "end") to the business data (the other "end"): everything must work as designed. E2E tests are typically slow because
  - they need a **working back-end** application, typically launched alongside the front-end application. You can't launch them without a server, so you depend on the back-end developers to work
  - they need **reliable data**, seeding and cleaning it before every test

  That's why E2E tests are not feasible to be used as the only/main test type. They are pretty important because they are testing everything (front-end + back-end) but they must be used carefully to avoid brittle and hour-long test suites.

  In a complete suite with a lot of UI integration tests, you can think about E2E tests as "back-end tests". What flows should you test through them?
  - the Happy Path flows: you need to be sure that, at least, the users are able to complete the basic operations
  - everything valuable for your business: happy path or not, test whatever your business cares about (prioritizing them, obviously)
  - everything that breaks often: weak areas of the system must be monitored too

Identifying/defining the type of test is useful to group them, to [name the test files](/sections/generic-best-practices/name-test-files-wisely.md), to limit their scope, and to choose where to run them or not though the whole application and deployment pipelines.

<br /><br />

*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/component-vs-ui-integration-vs-e2e-tests-3i0d) and [Medium](https://medium.com/@NoriSte/component-vs-ui-integration-vs-e2e-tests-f02b575339dc).*



================================================
FILE: sections/testing-strategy/component-vs-integration-vs-e2e-testing.zh.md
================================================
[Binary file]


================================================
FILE: sections/testing-strategy/small-tests-or-long-ones.md
================================================

# One long E2E test or small, independent ones?

<br/><br/>

### One Paragraph Explainer


While speaking about testing a CRUD app, how should we organize the "create", "modify", and "delete" E2E tests?

The complete list of options are:

1. To have **three small E2E tests dependent on the execution order** (test B takes for granted that test A run) - The only bad solution, I'm going to explain why.
2. To have **three small E2E tests independent from the execution order** (test B works regardless from whether test A was launched or not) - Theoretically, the best solution. Still, it requires a lot of boilerplates also to be fast.
3. To have **one extended E2E test** that does everything - A good tradeoff for the case presented in this article.

It depends, and most of the problems I present are related to the implicit issues of the E2E tests, a strong signal that we should write only a few of them. As a Front-end Engineer, I strongly prefer to invest my time in server-free tests, not E2E ones. Go ahead, and you will understand why.

Please note: this results from working on Hasura's Console E2E tests.

<br/><br/>



## 1 - To have three small E2E tests dependent on the execution order (test B takes for granted that test A run)

The test flow would be something like this:

1. START (*the application state is empty*)
2. Test 1: create the entity
3. Test 2: modify the entity
4. Test 3: delete the entity
5. END (*the application state is empty*)

In this case, the tests are not independent but based on execution order. To test a CRUD flow, the three primary tests are "create an entity", "modify an entity", "delete the entity". The second test ("modify the entity") takes for granted that when it starts, the application state is okay because it runs after the "create the entity" one. "delete the entity" must run after the "modify the entity" too, etc.

Coupling multiple tests together is an anti-pattern because of:

- **False negatives**: The tests will fail in a row once one fails.
- **Hard to debug**: understanding the root of a failure is more complicated because of higher ambiguity. Did the test fail because of its code? Or because the state of the previous test changed? Then, you have to debug two tests when one fails.
- **Hard to debug**Â (again): the developers waste a lot of time because they can not run a single test nor use `skip` and `only` to launch a portion of them.
- **Hard to refactor**: The tests cannot be moved elsewhere. If the code of the tests becomes too long, too complex, etc., you cannot move it to a dedicated file/directory because it depends on the previous one.
- **Hard to read**: The readers cannot know what a test does because they must also know the previous tests. You have to read two tests instead of one, which is not good.

I do not recommend writing tests coupled this way, but I want to include them to be sure you realize why.

## 2 - To have three small E2E tests independent from the execution order

To get every test independent, every test should create the application state that it needs to run, then clear it after completion. The flow presented in the previous chapter should become something like (inÂ *italic*Â the new steps compared to the original create->modify->delete three tests in a row)

1. START (*the application state is empty*)
2. Test 1: create the entity
    1. ***BEFORE****: Load the page (the application state is empty)*
    2. create the entity
    3. ***AFTER****: Delete theÂ *entity*Â (the application state is empty)*
3. Test 2: modify the entity
    1. ***BEFORE****: create theÂ *entity*Â (through APIs)*
    2. ***BEFORE****: Load the page (the application state is empty)*
    3. modify the entity
    4. ***AFTER****: Delete theÂ *entity*Â (through APIs, the application state is empty)*
4. Test 3: delete the entity
    1. ***BEFORE****: create theÂ *entity*Â (through APIs)*
    2. ***BEFORE****: Load the page (the application state is empty)*
    3. delete the entity
    4. ***AFTER****: Delete the action (the application state is empty)*
5. END (*the application state is empty*)

By doing so, every test is independent. Please note that the before and after actions are done directly by calling the server APIs. Doing them through the UI would be too slow.

Anyway, the presented approach's problem is that **tests become slower** because every test creates the entity, and every test visits the page. When the application takes 10 seconds to load (it was initially the case of Hasura's Console), reloading the app is a problem.

To get the best of both worlds (independent but fast tests), we should evolve the above flow to

- Exploit the previous test's application state.
- But also create the needed application state if no tests have run.

Something like (inÂ *italic*Â the new steps compared to the flow presented in the previous chapter)

1. START (*the application state is empty*)
2. Test 1: create the entity
    1. ***BEFORE****: Does theÂ *entity*Â exist?*
        1. *NO: it's ok!*
        2. *YES: delete the entity (through APIs)*

    2. **BEFORE**: Load the page (the application state is empty)
    3. create the entity
3. Test 2: modify the entity
    1. ***BEFORE****: Does theÂ *entity*Â exist?*
        1. *YES: it's ok!*
        2. *NO: create the entity (through APIs)*
    2. ***BEFORE****: Does theÂ *entity*Â already includes the change the test is going to make?*
        1. *YES: it's ok!*
        2. *NO: modify the entity (through APIs)*
    3. ***BEFORE****: Are we already on the correct page?*
        1. *YES: it's ok!*
        2. *NO: load the page*
    4. modify the entity
4. Test 3: delete the entity
    1. ***BEFORE****: Does the entity exist?*
        1. *YES: it's ok!*
        2. *NO: create the entity (through APIs)*
    2. ***BEFORE****: Are we already on the correct page?*
        1. *YES: it's ok!*
        2. *NO: load the page*

5. delete the entity
6. END

Now, if you run all the tests in a row, each of them leverages the existing application state. If you run just the "modify the entity" for instance, it creates whatever it needs, then runs the test itself.

Now we have both test independence and test performance! Cool!

Well... Did you notice the amount of code we need to write? TheÂ [cypress-data-session](https://github.com/bahmutov/cypress-data-session)Â plugin comes in handy but

1. You have a lot of cypress-data-session related boilerplate
2. You have to maintain, in the E2E tests, a lot of API calls that could go out of sync with the ones used in the main application in a while

Here is an example of the cypress-data-session related boilerplate (coming from the Hasura Console codebase)

```ts
import { readMetadata } from '../services/readMetadata';
import { deleteHakunaMatataPermission } from '../services/deleteHakunaMatataPermission';

/**
 * Ensure the Action does not have the Permission.
 *
 * ATTENTION: if you get the "setup function changed for session..." error, simply close the
 * Cypress-controlled browser and re-launch the test file.
 */
export function hakunaMatataPermissionMustNotExist(
  settingUpApplicationState = true
) {
  cy.dataSession({
    name: 'hakunaMatataPermissionMustNotExist',

    // Without it, cy.dataSession run the setup function also the very first time, trying to
    // delete a Permission that does not exist
    init: () => true,

    // Check if the Permission exists
    validate: () => {
      Cypress.log({ message: '**--- Action check: start**' });

      return readMetadata().then(response => {
        const loginAction = response.body.actions?.find(
          action => action.name === 'login'
        );

        if (!loginAction || !loginAction.permissions) return true;

        const permission = loginAction.permissions.find(
          permission => permission.role === 'hakuna_matata'
        );

        // Returns true if the permission does not exist
        return !permission;
      });
    },

    preSetup: () =>
      Cypress.log({ message: '**--- The permission must be deleted**' }),

    // Delete the Permission
    setup: () => {
      deleteHakunaMatataPermission();

      if (settingUpApplicationState) {
        // Ensure the UI read the latest data if it were previously loaded
        cy.reload();
      }
    },
  });
}

```

and here is an example of the API call to create the entity (coming from the Hasura Console codebase)

```ts
/**
 * Create the Action straight on the server.
 */
export function createLoginAction() {
  Cypress.log({ message: '**--- Action creation: start**' });

  cy.request('POST', 'http://localhost:8080/v1/metadata', {
    type: 'bulk',
    source: 'default',
    args: [
      {
        type: 'set_custom_types',
        args: {
          scalars: [],
          input_objects: [
            {
              name: 'SampleInput',
              fields: [
                { name: 'username', type: 'String!' },
                { name: 'password', type: 'String!' },
              ],
            },
          ],
          objects: [
            {
              name: 'SampleOutput',
              fields: [{ name: 'accessToken', type: 'String!' }],
            },
            {
              name: 'LoginResponse',
              description: null,
              fields: [
                {
                  name: 'accessToken',
                  type: 'String!',
                  description: null,
                },
              ],
            },
            {
              name: 'AddResult',
              fields: [{ name: 'sum', type: 'Int' }],
            },
          ],
          enums: [],
        },
      },
      {
        type: 'create_action',
        args: {
          name: 'login',
          definition: {
            arguments: [
              {
                name: 'username',
                type: 'String!',
                description: null,
              },
              {
                name: 'password',
                type: 'String!',
                description: null,
              },
            ],
            kind: 'synchronous',
            output_type: 'LoginResponse',
            handler: 'https://hasura-actions-demo.glitch.me/login',
            type: 'mutation',
            headers: [],
            timeout: 25,
            request_transform: null,
          },
          comment: null,
        },
      },
    ],
  }).then(() => Cypress.log({ message: '**--- Action creation: end**' }));
}
```

So, having independent tests is essential, but it comes with a cost.

That's why, for this specific problem, I then opted for the last option...

## 3 - To have one extended E2E test that does everything

Pros: a lot of boilerplate files can be removed.

Cons: Working with the tests becomes slower (you cannot launch only the third test anymore)

Compared to the boilerplate we need to write and the code we need to maintain, it is worth unifying them. After all, the specific CRUD flow I was working on took ~20 seconds.

1. START (*the application state is empty*)
2. Test: CRUD
  1. ***BEFORE****: Delete the entity if it exists (the application state is empty)*
  2. ***BEFORE****: Load the page*
  3. create the entity
  4. modify the entity
  5. delete the entity
  6. ***AFTER****: Delete the entity if it exists (the application state is empty)*
3. END (*the application state is empty*)

And at the same time, it makes cypress-data-session useless. Hence one less dependency to keep updated.

## Conclusions

Working with E2E tests is hard. Dealing with real data, real application state to clear, etc., has a cost. I know that E2E tests are the only ones that give complete confidence, but as a Front-end Engineer (remember, I'm not a QA Engineer), I strongly prefer to work with server-free tests.


## Related chapters


- ğŸ”— [Component vs (UI) Integration vs E2E tests](/sections/testing-strategy/component-vs-integration-vs-e2e-testing.md)
- ğŸ”— [Approach the testing pyramid from the top!](/sections/beginners/top-to-bottom-approach.md)
- ğŸ”— [Use your testing tool as your primary development tool](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md)
<br/><br/>

*Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/decouple-the-back-end-and-front-end-test-through-contract-testing-112k).*



================================================
FILE: sections/testing-strategy/small-tests-or-long-ones.zh.md
================================================
[Binary file]


================================================
FILE: sections/testing-strategy/write-test-then-fix-bug.md
================================================
# Found a bug? Write the test, then fix it

<br/>

### One Paragraph Explainer

So, you have found a bug in your front-end application and you have already debugged it. You can reproduce it systematically and you're ready to fix it. A testing-oriented mind must pass through these steps:
1. identify the expected behavior
2. write a test that aims to consume the front-end application the correct way
3. the test must fail, obviously, because the bug does not allow the user to perform his task
4. fix the bug
5. check that the test now passes

What are the advantages of this approach? Why should you write a test? I know that fixing the bug without a test could seem faster but consider that:

- as usual, your testing tool is faster than you to reach the state of the application that shows the bug (see the [Use your testing tool as your primary development tool](/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md) chapter)

- sometimes you think that you're able to reproduce the bug systematically, but it's not always true. Writing a test that unearths the bug make you 100% sure that the bug is reproducible **excluding a lot of deviant variables** like existing sessions, caches, service workers, browser extensions, browser version, etc. that could influence your confidence. Sometimes you discover that you did not identify the bug correctly

- at the same time, when the test passes thanks to your fix, you are really sure that your solution works as expected. The same variables that could influence your bug identification process could mine the false sense of the job's effectiveness

- **with a test, the bug is fixed forever!** The test will be run thousands of times and let you sleep well about that forever

- a successful test could be used as a proven track of the work you've done

Last but not least: be sure that the test you write fails at the beginning! And that it fails because of the bug!<br/>
The test is not useful only to reproduce the bug and check it visually, but it must put you in the position of having positive feedback after the bug fixing process. **A bug-related test that does not fail is really dangerous** because you can think that you've made a good job when the reality is that you have not reproduced the bug correctly since the beginning.

As a general rule: **a broken flow must have a broken test**, a successful test must be related to a working app.



================================================
FILE: sections/testing-strategy/write-test-then-fix-bug.zh.md
================================================
[Binary file]


================================================
FILE: sections/tools/cypress-and-storybook-exposing-component-from-story.md
================================================
# [OBSOLETE] Cypress + Storybook. Keeping test scenario, data and component rendering in one place.

*This section is now marked as obsolete because it refers to a very old version of Cypress and Storybook (either of them now fully support component tests).*

---

_Russian version: [Cypress + Storybook. Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ñ, Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ Ñ€ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ° Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¼ĞµÑÑ‚Ğµ](https://habr.com/ru/post/497544/)._

### One Paragraph Explainer

Many of us have chosen Cypress as a tool to test components hosted via Storybook/Styleguidist/Docz. [@NoriSte's example](./cypress-and-storybook.md) suggests creating some Storybook Stories, put components there and expose important data to the global variable in order to have access to the test. The nice approach actually, but the test becomes broken into the pieces between Storybook and Cypress.

Here I'd like to show how to go a little bit further and get the most out of executing JavaScript in Cypress. To see it in action, you may [download the source code](https://github.com/daedalius/article-exposing-component-from-storybook-to-handle-them-in-cypress) and execute then `npm i` and `npm test` in the console.

- You may expose the component reference from Storybook Story to test it however you wish in Cypress (without breaking testing logic into pieces).
- Cypress turned up so powerful for our team, so we do not have another utility that uses js-dom under the hood to test UI components.

## The task

Imagine that we are writing an adaptor for existing Datepicker component to use it across all company websites. We don't want to accidentally break anything, so we have to cover it by tests.

## Storybook

All we need from Storybook - an empty Story that saves a reference to the testing component in the global variable. In order not to be so useless this Story renders the single DOM node. This node will be our war zone inside the test.

```jsx
import React from 'react'
import Datepicker from './Datepicker.jsx'

export default {
  component: Datepicker,
  title: 'Datepicker',
}

export const emptyStory = () => {
  // Reference to retrieve it in Cypress during the test
  window.Datepicker = Datepicker

  // Just a mount point
  return <div id="component-test-mount-point"></div>
}
```

Okay, we've finished with Storybook. Let's take a look at Cypress.

## Cypress

Personally, I like to get started with test cases enumeration. Seems we have next test structure:

```jsx
/// <reference types="cypress" />

import React from 'react'
import ReactDOM from 'react-dom'

/**
 * <Datepicker />
 * * renders text field.
 * * renders desired placeholder text.
 * * renders chosen date.
 * * opens calendar after clicking on text field.
 */

context('<Datepicker />', () => {
  it('renders text field.', () => {})

  it('renders desired placeholder text.', () => {})

  it('renders chosen date.', () => {})

  it('opens calendar after clicking on text field.', () => {})
})
```

Fine. We have to run this test in any environment. Open the Storybook, go directly to the empty Story by clicking at "Open canvas in new tab" button in the sidebar. Copy that URL and make Cypress visit it:

```jsx
const rootToMountSelector = '#component-test-mount-point'

before(() => {
  cy.visit('http://localhost:12345/iframe.html?id=datepicker--empty-story')
  cy.get(rootToMountSelector)
})
```

As you may guess, in order to test we are going to render all components states in the same `<div>` with `id=component-test-mount-point`. So that the tests do not affect each other, we must unmount any component here before the next test execution. Let's add some cleanup code:

```jsx
afterEach(() => {
  cy.document().then((doc) => {
    ReactDOM.unmountComponentAtNode(doc.querySelector(rootToMountSelector))
  })
})
```

Now we are ready to complete the test. Retrieve the component reference, render the component and make some assertions:

```jsx
const selectors = {
  innerInput: '.react-datepicker__input-container input',
}

it('renders text field.', () => {
  cy.window().then((win) => {
    ReactDOM.render(<win.Datepicker />, win.document.querySelector(rootToMountSelector))
  })

  cy.get(selectors.innerInput).should('be.visible')
})
```

Do you see that? Nothing stops us from passing any props or data to the component directly! It's all in one place - in Cypress!

## Testing in a few steps with wrapper

Sometimes we'd like to test that component behaves predictably according to changing props.
Examine `<Popup />` component with `showed` props. When `showed` is `true`, `<Popup />` is visible. After that, changing `showed` to `false`, `<Popup />` should become hidden. How to test that transition?

Those problems are easy to handle in an imperative way, but in case of declarative React we need to come up with something.
In our team, we use an additional wrapper component with state to handle it. The state here is boolean, it responses to "showed" props.

```jsx
let setPopupTestWrapperState = null
const PopupTestWrapper = ({ showed, win }) => {
  const [isShown, setState] = React.useState(showed)
  setPopupTestWrapperState = setState
  return <win.Popup showed={isShown} />
}
```

Now we are about to finish the test:

```jsx
it('becomes hidden after being shown when showed=false passed.', () => {
  // arrange
  cy.window().then((win) => {
    // initial state - popup is visible
    ReactDOM.render(
      <PopupTestWrapper showed={true} win={win} />,
      win.document.querySelector(rootToMountSelector)
    )
  })

  // act
  cy.then(() => {
    setPopupTestWrapperState(false)
  })

  // assert
  cy.get(selectors.popupWindow).should('not.be.visible')
})
```

> Tip: If such hook hasn't worked or you dislike calling the hook outside the component - rewrite the wrapper via simple class.

## Testing component methods

Actually, I've never written such a test. The idea has come up while writing this article. Probably it may be useful to test a component in a unit test style.

However, you may easily do it in Cypress. Just create a ref to the component before rendering. It is worth mentioning that the ref gives access to state and other elements of the component.

I've added the `hide` method to `<Popup \>` which makes it hidden forcibly (example for the sake of example). The following test looks like this:

```jsx
it('closes via method call.', () => {
  // arrange
  let popup = React.createRef()
  cy.window().then((win) => {
    // initial state - popup is visible
    ReactDOM.render(
      <win.Popup showed={true} ref={popup} />,
      win.document.querySelector(rootToMountSelector)
    )
  })

  // act
  cy.then(() => {
    popup.current.hide()
  })

  // assert
  cy.get(selectors.popupWindow).should('not.be.visible')
})
```

## To sum it up: the roles of each participant

Storybook:

- Hosts Storybook Stories that contain bundled react components for test purposes.
- Provides a real non-synthetic environment to run tests.
- Each Story exposes one component in the global variable (to retrieve it in Cypress later).
- Each Story exposes a component mount point (to mount a component in test).
- Able to open each component in isolation in new tab.

> Pro-Tip: Please, run another instance of Storybook for your component library or pages.

Cypress:

- Contains and runs tests and Javascript.
- Visits isolated component Stories, retrieves component references from the global variable.
- Renders component according to testing needs (with any data or test conditions such as mobile resolution).
- Gives you super handy UI so you can see how your tests are going.

## Conclusion

Here I'd like to express my personal opinion and my colleagues' position about possible questions that may appear during the reading. Written below doesn't pretend to be true, may differ from reality and contain nuts.

### My test utils use js-dom under the hood. Do I limit myself?

- Js-dom is a synthetic environment. The separated DOM is not a real browser.
- It doesn't really work out to act with js-dom as it user does. Especially when it comes to simulating input events.
- How much confidence can you get from a written unit test if a component can be broken in CSS due to one incorrect z-index? If the component is tested by Cypress, you will see an error.
- You write unit tests blindly. But why?

### Should I choose the approach suggested?

- If you use tests as a development environment - definitely, Yes!
- If you look at tests as at **live** documentation - Yes.
- If you really write unit-tests to cover things that too close to implementation and React-lifecycle - ... I don't know. I haven't been writing such a test for a long time. Are you sure that the covered logic is component responsibility? Maybe that logic should be extracted and tested accordingly?

### Why not use cypress-react-unit-test then? Why do we need Storybook?

Probably, it is our future to test components. There will be no need to maintain a separate instance of the Storybook, all tests will be entirely under the responsibility of Cypress, the configuration will be simplified, etc.
But now the tool has [some](https://github.com/bahmutov/cypress-react-unit-test/issues/34) [problems](https://github.com/bahmutov/cypress-react-unit-test/issues/52) that make the environment provided incomplete for running tests. Hope that Gleb Bahmutov and the Cypress team will make it worked ğŸ¤

_Crossposted by [daedalius](https://github.com/daedalius) on [Medium](https://itnext.io/cypress-storybook-keeping-test-scenario-data-and-component-rendering-in-one-place-c57b23cc1640) and on [habr.com (in Russian)](https://habr.com/ru/post/497544/)._



================================================
FILE: sections/tools/cypress-and-storybook-exposing-component-from-story.zh.md
================================================
[Binary file]


================================================
FILE: sections/tools/cypress-and-storybook.md
================================================
# [OBSOLETE] Testing a component with Cypress and Storybook

*This section is now marked as obsolete because it refers to a very old version of Cypress and Storybook (either of them now fully support component tests).*

---

_**UPDATE**: After this experimental approach, take a look at the â€œ[Unit Testing React components with Cypress](./cypress-react-component-test.md)â€ chapter, things got simplified and more effective with Cypress 4.5.0 release!_

_**UPDATE 2**: [Cypress 7 is out with a brand-new Component Test](https://docs.cypress.io/guides/component-testing/introduction#What-is-Component-Testing) support, check it out! And other exciting news is on the way thanks to [Storybook 6.2 release](https://twitter.com/NoriSte/status/1378204109841571840)!_

### Why testing components in isolation?

Components are the building blocks of your app, Storybook allows you to build them in isolation, **checking** that they work properly and that they are aligned with the graphic layouts, sharing with the rest of the team, etc. There are essentially two kinds of component checks performed with Storybook:

- visual tests: run with [Percy](https://percy.io/) or [Applitools](https://applitools.com/), both easily integrable with Storybook to automate this checks

- functional tests: performed manually on the component stories, why do not automate them too? This chapter speaks about that

### The components testing tools

The current front-end testing trends have two winners: **[DOM Testing Library](https://testing-library.com)** and **[Cypress](https://www.cypress.io/)**. They are two completely different tools but **they overlap** in some terms. DOM Testing Library bornt explicitly to test components (through a third-party test runner like [Jest](https://jestjs.io/)) the right and the fast way and it is great for that. Cypress is made to automate the browser in an easy and reliable way.

Why do they overlap? Well because technically, you could test a whole app through DOM Testing Library or you could test a single component with Cypress.

Using **DOM Testing Library** to test an entire app:

- pro: it is blazing **fast**

- con: it renders the HTML but the HTML is not rendered by a real browser so **the CSS part does not work**

- con: reading a giant HTML instead of consuming the result in the browser is cumbersome

- con: third-party components could not fully be fully compatible with the [jsdom](https://github.com/jsdom/jsdom) environment or could not work as expected while rendered by DOM Testing Library

Using **Cypress** to test components:

- pro: it automates a **real browser**, the components are tested in the same environment they will be used

- pro: you can test the component the same way the users are going to see/consume it

- pro: you can check that your **Storybook works well** too. The code of your stories could be bugged, so having some working components does not guarantee you a having a working Storybook. And the rest of the team could count on Storybook as the component library of the team/company.

- con: **it needs a running host**/website that allows you to interact with the components themselves (like Storybook)

- con: it could be slow to test hundreds of components

Please note: for Cypress, there is the [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro) plugin that allows you to leverage the same _findByText_, _findByPlaceholderText_, _findByTestId_, etc. APIs of DOM Testing Library. I love it and I always use it but they work inside Cypress, not in other test runners

## A real example: a Virtual List

Recently, I developed a VirtualList component and I used it to check how Storybook and Cypress could work together. A VirtualList is a list that renders only the visible items to guarantee the highest possible performance. Take a look at [React Virtualized](https://bvaughn.github.io/react-virtualized/#/components/List) to understand how it works. Apart from virtualizing, my VirtualList manages items clicks and items multi-selection.

Apart from a lot of unit tests, I would like to run some Component Tests but, as said above, third-party libraries (like the one we use: [React Smooth Scrollbar](https://www.npmjs.com/package/react-smooth-scrollbar)) could not work well with [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) (the React version of DOM Testing Library) so Cypress is the only tool of choice.

## Testing challenges

What are the biggest challenges of using Cypress to test a component in Storybook instead of running a standard E2E test? And what are the challenges compared to a standard Component Test with [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) (the React version of DOM Testing Library)?

### Data source control

With Cypress, we are used to loading an entire application, controlling the data through static fixtures (in case of [UI Integration Tests](../testing-strategy/component-vs-integration-vs-e2e-testing.md)) or reading/intercepting the back-end data (in case of [E2E Tests](../testing-strategy/component-vs-integration-vs-e2e-testing.md)) and using this data to assert that the UI is working properly. So we can control, or at least know, the data the UI is going to consume. **Not knowing data would mean no assertions**.
But in a (stateless) component story, the data is passed directly to the component by the component that represents the story and renders the component. In order to know the data and do the proper assertions about the contents shown by the component of the story, **the data needs to be exposed by the story and read by Cypress**.

Please note: if the Cypress tests are in the same repository of the components of the stories, you can import the data from the story file, but the examples shown below come from tests that are not in the same repository of the stories.

### Hidden contents

**A Virtual List removes the invisible components** from the DOM. What does it mean for the tests? That we cannot count on the fact that all the elements exist in the HTML. Neither React Testing Library nor Cypress could be fully leveraged to understand how the Virtual List is working because, as soon as you need to assert about the existence of an item outside the visible area, you cannot leverage the usual _cy.contains_ / _findByText, etc._ utilities: because the items do not exist at all.

The VirtualList is a controlled component so it notifies the parent component about which are the rendered items and which are the selected ones. In a standard [Component Test](../testing-strategy/component-vs-integration-vs-e2e-testing.md) we could assert about the props passed up and down to the VirtualList component, the Story has direct control of these props but, again, Cypress needs to read this data and so the story must expose it.

### Are we testing the story or the component?

The difference could be subtle. Since the VirtualList is a controlled component, the storyâ€™ component controls it. The controlling logic inside the storyâ€™ component is part of the things to be tested? Are the controlling component and the controlled one separable? Probably not.

A standard test has two actorsâ€”the test runner and the controlled componentâ€”while using Cypress with Storybook has **three actorsâ€”the test runner, the story, and the controlled component**â€”. So, if a Component Test controls the component and has direct access to the callback data, Cypress needs the storyâ€™ component to work properly.

### Scroll and rendered items control

The VirtualList component leverages an inertial scroll and, since the story adds thousands of items to be rendered to fully show the VirtualList potential, has a very little scrollbar handle. Scrolling the VirtualList could result in slightly different rendered items between a test and the next one. So I take for granted that we cannot know in advance which items are going to be rendered once the list is scrolled (ex. from the 100th to the 110th or from the 101st to the 111th).

Why? Because **I hate to have brittle tests based on fragile assumptions**. Tests should not be designed to resist every possible change but they must be enough robust to survive little changes. For the VirtualList tests, it means that once scrolled, the rendered items will be retrieved directly from the HTML ones. We are going to deepen it later.

## Code, please

The first test we are going to write needs to check that if the list received 10000 items, only a bunch of them are rendered. This is the base feature of a Virtual List.

First of all, the RenderItem component, it just alternates the color to visually identify the rows

```js
// every `item` is an { id: string, name: string}
const getItemText = (item) => `id: ${item.id} - ${item.name}`

const RenderItem = ({ item }) => {
  return (
    <div
      style={{
        height: '30px',
        backgroundColor: parseInt(item.id) % 2 ? '#FAFAFA' : '#EEE',
      }}
    >
      {getItemText(item)}
    </div>
  )
}
```

the original story we are going to work on is the following

```js
// `getStoryItems` allows to create a high amount of items, it's used by every story
export const With10000Items = () => {
  return (
    <>
      <h4>The scroll must be fluid</h4>
      <VirtualList
        items={getStoryItems({ amount: 10000 })}
        getItemHeights={() => 30}
        RenderItem={RenderItem}
        listHeight={300}
      />
    </>
  )
}
With10000Items.story = {
  name: 'With 10000 items',
}
```

We need to adapt the story to globally expose:

- the `items` array: the Cypress test needs to know the data used to fill the list

- the `getItemText` function: so the Cypress test avoids caring about how to get the rendered text from an item. Cypress needs the convert an item to text to retrieve the rendered items from their text, avoiding to use `data-test` attributes

- the number of visible items: the Cypress test needs to assert about which items are rendered and which not

Here is the story updated to expose the variables through a global `storyData` variable that will be collected and consumed by the Cypress test:

```js
export const With10000Items = () => {
  const itemHeight = 30
  const listHeight = 300
  const items = React.useMemo(() => getStoryItems({ amount: 10000 }), [])

  // exposing data for Cypress
  React.useEffect(() => {
    // global is `window`
    global.storyData = {
      items,
      visibleItemsAmount: Math.ceil(listHeight / itemHeight),
      getItemText,
    }
  }, [items])

  return (
    <>
      <h4>The scroll must be fluid</h4>
      <VirtualList
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={RenderItem}
        listHeight={listHeight}
      />
    </>
  )
}
With10000Items.story = {
  name: 'With 10000 items',
}
```

### The Cypress test

The test is going to:

- visit the Storybook page

- collect the exposed data

- check the rendered items

The code for the first two points

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(() => {
      // the test code
    })
})
```

Why asserting about the exposed `storyData`? Because a wrong `storyData` will make the test fail, and if a test fails it must drive us directly to the problem. If component rendering will fail because of a wrong `storyData`, our test should not run at all. This could be considered **a data-related smoke test**.

Now, the missing part of the test: checking which items are rendered and which are not

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // items visibility check
      const visibleItems = items.slice(0, visibleItemsAmount - 1)
      visibleItems.forEach((item) => {
        cy.findByText(getItemText(item)).should('be.visible')
      })

      // first not-rendered item check
      cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
    })
})
```

- We use the exposed `visibleItemsAmount` variable to retrieve just the rendered items

  const visibleItems = items.slice(0, visibleItemsAmount - 1)

- We retrieve every item from the page using the exposed `getItemText` function

  cy.findByText(getItemText(item))

- We assert all the items expected to be visible

  cy.findByText(getItemText(item)).should('be.visible')

- We assert that the next item does not exist in the page

```js
cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
```

Please note that the `cy.findByText` Cypress command comes fromâ€¦ [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro) ğŸ˜Š and it is my favorite way to retrieve elements from the page because acts as the user would: reading/retrieving elements from their textual content. I use it instead of `cy.contains` but they do the same thing.

This is the result:

![The Cypress controlled browser, all the assertion results on the left and the Storybook story on the right.](../../assets/images/cypress-storyboook/list-test.png 'The result of the first test: the loaded story and the result of all the assertions.')_The result of the first test: the loaded story and the result of all the assertions._

This test is enough to check that the Virtual List renders only the minimum number of items.

Initially, I tried to check that the browser runs at 60 FPS when the Virtual List was scrolling. Why? Because **a UI Test must check what the user sees, consuming the UI the same UI the user would**. And, from a user perspective, the sole Virtual List goal is that it must run fluidly, regardless of the number of items that are part of the list. But measuring reliably the FPS is hard because the measurement would be impacted by:

- the Cypress commands you use: every Cypressâ€™ action slows down the browser

- the number of resources available to the machine (or Docker image) to run the tests

since having a reliable count is not possibleâ€”some initial values would be discarded, etc.â€”I moved to check the amount of rendered items and nothing more. If I am sure that just 10 of 10000 items are rendered, I am sure that the list runs fluidly. More in general: remember that **a brittle test is worse than a missing one**.

## Second test: scrolling

First of all: the VirtualList component leverages [Smooth Scrollbar](https://idiotwu.github.io/smooth-scrollbar/), Smooth Scrollbar has its own tests so we are going to check how our VirtualList component reacts to the scroll but we take for granted that Smooth Scrollbar works. When consuming **a third-party library**, you do not have to test that the library works. The library **should have its own tests**, if it has not, change the library! Never write tests for third-party libraries.

The scrolling test is going to:

- trigger the scroll

- wait until the scroll ends

- check the rendered items

So, the test code to trigger the scroll is the following

```js
// triggers the wheel event
cy.findByTestId('VirtualList').trigger('wheel', {
  deltaX: 0,
  deltaY: 1000,
})
```

note that the VirtusList component should render a DOM element with a `data-test="VirtualList"` attribute. The rest is managed by Cypress, trigger is a direct mapping for [jQuery trigger API](https://api.jquery.com/trigger/) (Cypress leverages jQuery to shorten as much as possible the test code). Again: the Cypressâ€™ native equivalent ofcy.findByTestId('VirtualList') iscy.get('[data-testid=VirtualList]').

For the â€œwait until the scroll endsâ€ part, we are going to leverage [Cypress waitUntil](https://github.com/NoriSte/cypress-wait-until) plugin. Why we should use the waitUntil plugin instead of waiting for a fixed amount of time is carefully explained in the [Await, do not make your E2E tests sleep](../generic-best-practices/await-dont-sleep.md) chapter.
The code of the custom waiting is

```js
// waits until the scrollbar handle stops
let scrollbarHandleY = Number.NEGATIVE_INFINITY
cy.get('.scrollbar-thumb-y').waitUntil(
  ($scrollbarHandle) => {
    const [newY, previousY] = [$scrollbarHandle.offset().top, scrollbarHandleY]
    scrollbarHandleY = newY
    return previousY === newY
  },
  {
    customMessage: 'The inertial scroll ends',
  }
)
```

So we are sure that the test waits the right amount of time.

### Checking the rendered items

What does it mean? It means:

- finding the first rendered item

- checking that the first rendered item is not the first one. The Virtual List started rendering the 0 to 10 items. Once scrolled, it must have rendered Xth to Xth+10 items. We do not know the value of X and we do not care about that, otherwise, we are going to tie the test to the exact items rendered. If the first rendered item is the 60th or the 61st one is not important. Checking the exact rendered items is out of the scope of this generic scrolling test. Test stability thanks us.

- Once retrieved the first rendered item, we check that the next ten are all rendered

We are going to go through every single step, the final code of the test is the following

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // triggers the wheel event
      cy.findByTestId('VirtualList').trigger('wheel', {
        deltaX: 0,
        deltaY: 1000,
      })

      // waits until the scrollbar handle stops
      let scrollbarHandleY = Number.NEGATIVE_INFINITY
      cy.get('.scrollbar-thumb-y')
        .waitUntil(
          ($scrollbarHandle) => {
            const [newY, previousY] = [$scrollbarHandle.offset().top, scrollbarHandleY]
            scrollbarHandleY = newY
            return previousY === newY
          },
          {
            customMessage: 'The inertial scroll ends',
          }
        )
        // (manually) looks for the first rendered element
        .then(() =>
          items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
        )
        // checks that the rendered items are not the initially rendered ones
        .should('be.greaterThan', 10)
        // checks the rendered items
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

Step by step: the code to retrieve the first rendered item is

```js
items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
```

Why not leveraging the `cy.findByText` command to retrieve it? Because in Cypress, every `cy.get` command (that is at the core of `cy.findByText` command) has built-in assertions, [check them](https://docs.cypress.io/api/commands/get.html#Assertions) in the official docs. Essentially, if the element does not exist on the page, `cy.get` makes the test fail. But since we need to go through over the non-rendered items until we find the first rendered one, we should go by hand. Cypress.\$ is a global instance of jQuery, a jQuery version of `cy.findByText("XXX")` is `Cypress.$(`\*:contains("XXX")`)` and, the jQuery version of

```js
cy.findByText('XXX').should('exist')
```

is

```js
!!Cypress.$(`*:contains("XXX")`).length
```

with the only difference that it does not fail if the element does not exist. As said before: I am used to leveraging `cy.getByText` but the native `cy.contains` does the same thing!

Once the index of the first rendered item is found, we only need to check the next rendered ones.

```js
.then(() =>
  items.findIndex(
    item => !!Cypress.$(`*:contains("${getItemText(item)}")`).length,
  )
)
// checks that the rendered items are not the initially rendered ones
.should('be.greaterThan', 10)
// checks the rendered items
.then(firstVisibleItemIndex => {
  const visibleItems = items.slice(
    firstVisibleItemIndex,
    firstVisibleItemIndex + visibleItemsAmount - 1,
  )
  visibleItems.forEach(item =>
    cy.findByText(getItemText(item)).should('be.visible'),
  )
})
```

[This is the recording of the test](https://www.youtube.com/watch?v=OEMkz_86bqY).

Please note that we do not care about the last half-visible item. The scope of the test is checking that the rendered items are not the first ones and that at least ten items are rendered, an 11th one does not need to be checked.

We can move the scrolling part of the test to a separated utility, something like

```js
const scrollVirtualList = ($list, deltaY = 1000) => {
  cy.wrap($list)
    .trigger('wheel', {
      deltaX: 0,
      deltaY,
    })
    .within(() => {
      // waits for the inertial scroll end
      let scrollbarY = Number.NEGATIVE_INFINITY
      getScrollbar().waitUntil(
        ($scrollbar) => {
          const newY = $scrollbar.offset().top
          const previousY = scrollbarY
          scrollbarY = newY
          return previousY === newY
        },
        {
          customMessage: 'The inertial scroll end',
        }
      )
    })
}
```

and we could do the same for finding the first rendered item

```js
const getFirstRenderedItemIndex = (items, getItemText) => {
  return items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
}
```

The readability of the test benefits from this separation, take a look

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      cy.findByTestId('VirtualList')
        // we leverage the new `scrollVirtualList` function
        .then(scrollVirtualList)
        .then(() => getFirstRenderedItemIndex(items, getItemText))
        .should('be.greaterThan', 10)
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

## Third test: selecting

The VirtualList component supports selection and **multi-item selection through key modifiers**. We only need to click items, click items with key modifiers, and check which are the selected items. What makes these operations hard?

- first of all: what â€œselectedâ€ means? From the user perspective, a selected item is a â€œhighlightedâ€ one but checking the style of an element is weak. We could add a `data-selected` attribute to the componentâ€¦

- â€¦ But there is a structural problem: the items could not be rendered at all! If we click on the first item (seeing from the 1st to the 10th items), then we scroll about twenty items (seeing the from the 21st to the 30th items) and we click on items in the middle (the 25th one) pressing SHIFT, the items selected should be from the 1st to the 25th but the first twenty are not rendered, so we cannot retrieve the selected items by the rendered ones. Again, **we are going to use the variables exposed by the story**

This is the code of the story

```js
export const WithSelectionManagement = () => {
  const items = getStoryItems({ amount: 10000 })

  const [selectedItems, setSelectedItems] = React.useState([])

  const handleSelect = React.useCallback(({ newSelectedIds }) => setSelectedItems(newSelectedIds), [
    setSelectedItems,
  ])

  // exposing data for Cypress
  React.useEffect(() => {
    global.storyData = {
      items,
      getItemText,
      selectedItems,
    }
  }, [items, selectedItems])

  return (
    <>
      <h4>The buttons must be clickable, the CTRL/CMD, ALT, SHIFT keyboard modifiers must work</h4>
      <VirtualList
        items={items}
        selectedItemIds={selectedItems}
        getItemHeights={() => 30}
        RenderItem={createSelectableRenderItem({ height: 30 })}
        listHeight={300}
        onSelect={handleSelect}
      />
    </>
  )
}
```

Since the VirtualList component is controlled, it passes up the list of selected itemsâ€”the `selectedItems` arrayâ€”. The parent componentâ€”the storyâ€”exposes the array for Cypress to allow asserting about the selected items.
Please note: the component creation, with click management, has been moved to a dedicated higher-order function: `createSelectableRenderdItem`.

The test for selecting a single item is the following

```js
it('When the items are clicked, then they are selected', () => {
  cy.visit('/iframe.html?id=virtuallist--with-selection-management')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length.of.at.least(3)
      expect(storyData.getItemText).to.be.a('function')
      expect(storyData.selectedItems).to.be.an('array')
    })
    .then(({ getItemText, items }) => {
      cy.findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[0].id])

      cy.findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id])
    })
})
```

All the assertions are on the exposed `selectedItems` array itself. We do not check if the rendered items are highlighted or not (highlighting the item is in charge of the component created by the story) but only that the VirtualList component manages correctly the items click.

The `selectedItems` array is not read at the beginning but it is read after every click because we need to check always the updated one, not the reference to the initial one (`selectedItems` is returned by `React.useState` so it is new after every selection update).

### Multi-selection assertions

The next step is checking that the VirtualList component manages correctly the usage of the Meta key. Clicking another item while the meta key is pressed should result in two selected items.

How could we keep the Meta key pressed with Cypress? It is just

```js
cy.get('body')
  // keeping pressed the meta (CMD) key
  .type('{meta}', { release: false })

// ...your test code...

cy.get('body')
  // releasing the meta (CMD) key
  .type('{meta}', { release: true })
```

Adding the item click would result in

```js
cy.get('body')
  // keeping pressed the meta (CMD) key
  .type('{meta}', { release: false })
  .findByText(getItemText(items[2]))
  .click()
  .window()
  .its('storyData.selectedItems')
  .should('eql', [items[1].id, items[2].id])
  .get('body')
  // releasing the meta (CMD) key
  .type('{meta}', { release: true })

  cy.get('body')
    .type('{shift}', { release: false })
    .findByText(getItemText(firstRenderedItem))
    .click()
    .window()
    .its('storyData.selectedItems')
    .should('eql', expectedSelectedItemIds)
    .get('body')
    .type('{shift}', { release: true })
  })
```

Here a screenshot of the result

![The controlled browser, all the assertion results on the left and the Storybook story with selected items on the right.](../../assets/images/cypress-storyboook/selection-test-result.png 'The first result of the test: the loaded story and the result of all the assertions.')_The first result of the test: the loaded story and the result of all the assertions._

### Scrolling and selecting

Scrolling the list is easy thanks to the `scrollVirtualList` utility, finding the first rendered item is done by the `getFirstRenderedItemIndex` one, we know how to keep a key pressedâ€¦ So, testing the scrolling and clicking with the Shift modifier (which means selecting everything from the previous clicked element and the last one) should be just a matter of calculating all the (expected to be) selected items. The next code does only that, go on for the full code of the test

```js
cy.findAllByTestId('VirtualList')
  // scrolls the list
  .then(scrollVirtualList)
  .then(() => {
    // identifies the first rendered item (unknown in advance)
    const firstRenderedItemIndex = getFirstRenderedItemIndex(items, getItemText)
    const firstRenderedItem = items[firstRenderedItemIndex]

    // the tests is going to click on the first rendered item
    // keeping the SHIFT key pressed. All the items up to the first
    // rendered one should be selected
    const expectedSelectedItemIds = items
      .slice(0, firstRenderedItemIndex + 1)
      .map((item) => item.id)

    cy.get('body')
      .type('{shift}', { release: false })
      .findByText(getItemText(firstRenderedItem))
      .click()
      .window()
      .its('storyData.selectedItems')
      .should('eql', expectedSelectedItemIds)
      .get('body')
      .type('{shift}', { release: true })
  })
```

the full code of the test, checking for every key modifier, is long but quite repetitive

```js
it('When the items are clicked, then they are selected', () => {
  cy.visit('/iframe.html?id=virtuallist--with-selection-management')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length.of.at.least(3)
      expect(storyData.getItemText).to.be.a('function')
      expect(storyData.selectedItems).to.be.an('array')
    })
    .then(({ getItemText, items }) => {
      // first item click
      cy.findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[0].id])

      // second item click
      cy.findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id])

      // third item click with Meta modifier
      cy.get('body')
        .type('{meta}', { release: false })
        .findByText(getItemText(items[2]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id, items[2].id])
        .get('body')
        .type('{meta}', { release: true })

      // first item click with Shift modifier
      cy.get('body')
        .type('{shift}', { release: false })
        .findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[2].id, items[1].id, items[0].id])
        .get('body')
        .type('{shift}', { release: true })

      // second item click with Alt modifier
      cy.get('body')
        .type('{alt}', { release: false })
        .findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[2].id, items[0].id])
        .get('body')
        .type('{alt}', { release: true })

      // scrolling
      cy.findAllByTestId('VirtualList')
        .then(scrollVirtualList)
        .then(() => {
          const firstRenderedItemIndex = getFirstRenderedItemIndex(items, getItemText)
          const firstRenderedItem = items[firstRenderedItemIndex]
          const expectedSelectedItemIds = items
            .slice(0, firstRenderedItemIndex + 1)
            .map((item) => item.id)

          // x-th item click with Shift modifier
          cy.get('body')
            .type('{shift}', { release: false })
            .findByText(getItemText(firstRenderedItem))
            .click()
            .window()
            .its('storyData.selectedItems')
            .should('eql', expectedSelectedItemIds)
            .get('body')
            .type('{shift}', { release: true })
        })
    })
})
```

[The test result is the following](https://www.youtube.com/watch?v=0DGHRJnWbHw).

As you can see, the Command Log on the left does not tell clearly what is happening. We could improve the speaking level of the test by adding some cy.log calls or, better, leveraging [Filipâ€™s solution](https://medium.com/slido-dev-blog/cypress-tips-3-improve-your-error-screenshots-in-cypress-b3675968a190) to get the best out of Cypress logging.

## Optimizations

The faster the tests are, the better. My original test suite took almost 16 seconds to completely run. [Here is the recording](https://www.youtube.com/watch?v=EwBz844FuxE) (please note that it was the first test suite, with the 60 FPS test).

There are two main improvements areas:

- switching faster between stories (instead of reloading the page between the tests)

- speeding up the scrolling forcing the browser clock with Cypress

### Switching faster between stories

Kudos to Nicholas Boll and his [cypress-storybook](https://github.com/NicholasBoll/cypress-storybook) plugin that leverages the storybook APIs to load the desired story without reloading the whole page.

At the time of writing, all we need to do is:

- adding `import 'cypress-storybook/react'` to the Storybook configuration

- adding import `'cypress-storybook/cypress'` to the Cypressâ€™ support/index.js file

- adding a `before` hook to the test file

```js
before(() => {
  // Visit the storybook iframe page once per file
  cy.visitStorybook()
})
```

- loading stories through `cy.loadStory('VirtualList', 'With 10000 items')` instead of using `cy.visit`

- updating the exposed variables, explained after the video

Doing so, the page is not reloaded for every test and the whole suite saves 3 seconds, take a look at [this video](https://www.youtube.com/watch?v=UJhPTJhDEFM).

Why do we need to update the variables by the stories? Well, if the page is not reloaded, we cannot be sure that the exposed variables are the desired ones, especially because almost every story exposes an `items` variable but the contents of the variable vary.

How could we distinguish the variables exposed by the stories? Well, exposing the name of the story too!

```js
React.useEffect(() => {
  global.storyData = {
    // the name of the story is exposed too
    storyName: 'With 10000 items',
    items,
    visibleItemsAmount: Math.ceil(listHeight / itemHeight),
    getItemText,
  }
}, [items])
```

Doing so, every test could check for the awaited name

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  const story = 'With 10000 items'
  cy.loadStory('VirtualList', story)

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // caring about the story name
      expect(storyData.storyName).to.eq(story)

      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // ... test code...
    })
})
```

leveraging the [Cypress retry-ability](https://docs.cypress.io/guides/core-concepts/retry-ability.html) to wait until all the assertions pass. This way we are sure the exposed variables are the correct ones.

13 seconds compared to the initial 16 seconds could not sound like a huge improvementâ€¦ But it is! Because if we were testing a component without the inertial scroll (a form, for example) the gain would not have been from 16" to 13" but probably from 9" to 6" seconds! Trust me, **never underestimate test speed**â€¦

### Speeding up the scroll by controlling the clock

The videos highlight that most of the test duration is spent waiting for the inertial scroll completion. There is nothing wrong about that but some test runners allow you to control time ticking, Cypress is one of those. Pushing time forward is fundamental when you need to test `setTimeout` or `setInterval` related stuff or animations like the inertial scroll.

The [official documentation](https://docs.cypress.io/api/commands/clock.html) has a lot of examples, but basic usage is enough for our needs. We need to call `cy.clock()` and then ticking time with `cy.tick(<milliseconds>`).

The first test commented with the new clock control

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  const story = 'With 10000 items'
  cy.loadStory('VirtualList', story)

  // take control of the browser clock
  cy.clock()

  cy.window()
    .its('storyData')
    .should((storyData) => {
      expect(storyData.storyName).to.eq(story)
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // this test does not need the `scrollVirtualList` utility anymore
      cy.findByTestId('VirtualList')
        .trigger('wheel', {
          deltaX: 0,
          deltaY: 1000,
        })

        // ticking the clock by one second.
        // It jumps to the inertial scroll end.
        .tick(1000)

        .then(() => getFirstRenderedItemIndex(items, getItemText))
        .should('be.greaterThan', 10)
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

[Thatâ€™s the result](https://www.youtube.com/watch?v=m6u0H8_jQuc).

As you can see, we jump at the end of the inertial scroll without waiting for its completion. Please note: the whole test duration is falsified by the screen recording, the test run without recording takes less time.

Remember that, if you use `cy.clock`, using `cy.tick` is not optional! If you do not tick the time manually, the list does not scroll at all because the clock is frozen! Take a look at what happens if you do not tick the clock

![The list stuck at the initial position and the failed test.](../../assets/images/cypress-storyboook/clock-without-tick.png 'The list is stuck at the initial scroll level, it did not scroll because we did not tick the clock.')_The list is stuck at the initial scroll level, it did not scroll because we did not tick the clock._

The `.should('be.greaterThan', 10)` assertion is not satisfied because the list does not scroll at all.

Clock control applied to almost all the tests dropped their duration 9 seconds. The final result in the next video

https://www.youtube.com/watch?v=Otf3J7qFAtI

The end result: **from the initial 16 seconds to 9 seconds**, great! The faster the tests are the more you are going to leverage them!

### â€œNo previewâ€ error

If you encounter this error

![The No Preview error of Storybook, shown into the Cypress test.](../../assets/images/cypress-storyboook/no-preview-error.png)

relaunching Cypress should be enough. Otherwise, relaunch Storybook. It happened to me just twice in some hours, so I have not deepened it too much yet.

## Conclusions

As a recap, the solutions listed above are:

- Leverage [cypress-storybook](https://github.com/NicholasBoll/cypress-storybook) to allow Cypress switching between stories quickly

- The stories should expose some global variables allowing Cypress to assert about data

- Speed up the test as much as you can, the inertial scroll in the example will not be awaited thanks to Cypressâ€™ clock control

- Think if you want to test the rendered component, the story code, or both

- The tools are going to be more integrated, Component Testing is a hot topic currently

<!-- TODO: in the end, decide if you want to move all the resources to a common chapter too -->

<br /><br />

_Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/testing-a-virtual-list-component-with-cypress-and-storybook-3lam) and [Medium](https://medium.com/@NoriSte/testing-a-virtual-list-component-with-cypress-and-storybook-494dc2d1d26b)._



================================================
FILE: sections/tools/cypress-and-storybook.zh.md
================================================
# [è¿‡æ—¶] ä½¿ç”¨ Cypress å’Œ Storybook è¿›è¡Œç»„ä»¶æµ‹è¯•

*æ­¤éƒ¨åˆ†å·²è¢«æ ‡è®°ä¸ºè¿‡æ—¶ï¼Œå› ä¸ºå®ƒæ¶‰åŠåˆ° Cypress å’Œ Storybook çš„éå¸¸æ—§ç‰ˆæœ¬ï¼ˆå®ƒä»¬ç°åœ¨éƒ½å·²å®Œå…¨æ”¯æŒç»„ä»¶æµ‹è¯•ï¼‰*

---

_*æ›´æ–°ï¼šåœ¨è¿™ä¸ªå®éªŒæ€§æ–¹æ³•ä¹‹åï¼Œè¯·æŸ¥çœ‹â€œ[ä½¿ç”¨ Cypress è¿›è¡Œ React ç»„ä»¶å•å…ƒæµ‹è¯•](./cypress-react-component-test.zh.md)â€ç« èŠ‚ï¼Œéšç€ Cypress 4.5.0 çš„å‘å¸ƒï¼Œä¸€åˆ‡éƒ½å˜å¾—æ›´åŠ ç®€åŒ–å’Œæœ‰æ•ˆï¼*_

_*æ›´æ–° 2ï¼š[Cypress 7 æ¨å‡ºäº†å…¨æ–°çš„ç»„ä»¶æµ‹è¯•](https://docs.cypress.io/guides/component-testing/introduction#What-is-Component-Testing)æ”¯æŒï¼Œä¸è¦é”™è¿‡ï¼è¿˜æœ‰å…¶ä»–ä»¤äººæŒ¯å¥‹çš„æ¶ˆæ¯ï¼Œè¦æ„Ÿè°¢ Storybook 6.2 ç‰ˆæœ¬çš„å‘å¸ƒï¼*_

## ä¸ºä»€ä¹ˆè¦å­¤ç«‹åœ°æµ‹è¯•ç»„ä»¶ï¼Ÿ

ç»„ä»¶æ˜¯ä½ åº”ç”¨ç¨‹åºçš„æ„å»ºæ¨¡å—ï¼ŒStorybook å…è®¸ä½ åœ¨å­¤ç«‹çš„ç¯å¢ƒä¸­æ„å»ºå®ƒä»¬ï¼Œ**æ£€æŸ¥**å®ƒä»¬æ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œå¹¶ä¸”æ˜¯å¦ä¸å›¾å½¢å¸ƒå±€å¯¹é½ï¼Œä¸å›¢é˜Ÿå…±äº«ç­‰ã€‚åŸºæœ¬ä¸Šï¼ŒStorybook æ‰§è¡Œä¸¤ç§ç±»å‹çš„ç»„ä»¶æ£€æŸ¥ï¼š

- è§†è§‰æµ‹è¯•ï¼šä½¿ç”¨[Percy](https://percy.io/)æˆ–[Applitools](https://applitools.com/)è¿è¡Œï¼Œä¸¤è€…éƒ½å¯ä»¥è½»æ¾é›†æˆåˆ° Storybook ä¸­ä»¥è‡ªåŠ¨æ‰§è¡Œè¿™äº›æ£€æŸ¥

- åŠŸèƒ½æµ‹è¯•ï¼šåœ¨ç»„ä»¶æ•…äº‹ä¸­æ‰‹åŠ¨æ‰§è¡Œï¼Œä¸ºä»€ä¹ˆä¸ä¹Ÿè‡ªåŠ¨åŒ–å‘¢ï¼Ÿæœ¬ç« è®¨è®ºäº†è¿™ä¸ªé—®é¢˜

## ç»„ä»¶æµ‹è¯•å·¥å…·

å½“å‰å‰ç«¯æµ‹è¯•è¶‹åŠ¿æœ‰ä¸¤ä¸ªèµ¢å®¶ï¼š**[DOM æµ‹è¯•åº“](https://testing-library.com)** å’Œ **[Cypress](https://www.cypress.io/)**ã€‚å®ƒä»¬æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„å·¥å…·ï¼Œä½†åœ¨æŸäº›æ–¹é¢å®ƒä»¬**é‡å **ã€‚DOM æµ‹è¯•åº“æ˜ç¡®ç”¨äºé€šè¿‡ç¬¬ä¸‰æ–¹æµ‹è¯•è¿è¡Œå™¨ï¼ˆå¦‚[Jest](https://jestjs.io/)ï¼‰æ­£ç¡®ä¸”å¿«é€Ÿåœ°æµ‹è¯•ç»„ä»¶ï¼Œéå¸¸é€‚åˆè¿™æ ·çš„åœºæ™¯ã€‚Cypress åˆ™æ—¨åœ¨ä»¥ç®€å•å¯é çš„æ–¹å¼è‡ªåŠ¨åŒ–æµè§ˆå™¨ã€‚

ä¸ºä»€ä¹ˆå®ƒä»¬ä¼šæœ‰äº¤é›†å‘¢ï¼Ÿå› ä¸ºä»æŠ€æœ¯ä¸Šè®²ï¼Œä½ å¯ä»¥ä½¿ç”¨ DOM æµ‹è¯•åº“æµ‹è¯•æ•´ä¸ªåº”ç”¨ç¨‹åºï¼Œæˆ–è€…å¯ä»¥ä½¿ç”¨ Cypress æµ‹è¯•å•ä¸ªç»„ä»¶ã€‚

ä½¿ç”¨ **DOM æµ‹è¯•åº“** æµ‹è¯•æ•´ä¸ªåº”ç”¨ç¨‹åºï¼š

- ä¼˜ç‚¹ï¼šé€Ÿåº¦**éå¸¸å¿«**

- ç¼ºç‚¹ï¼šå®ƒæ¸²æŸ“ HTMLï¼Œä½† HTML ä¸æ˜¯ç”±çœŸå®æµè§ˆå™¨æ¸²æŸ“çš„ï¼Œå› æ­¤**CSS éƒ¨åˆ†ä¸èµ·ä½œç”¨**

- ç¼ºç‚¹ï¼šè¯»å–å·¨å¤§çš„ HTML è€Œä¸æ˜¯åœ¨æµè§ˆå™¨ä¸­æ¶ˆè€—ç»“æœå¾ˆéº»çƒ¦

- ç¼ºç‚¹ï¼šç¬¬ä¸‰æ–¹ç»„ä»¶å¯èƒ½æ— æ³•ä¸ [jsdom](https://github.com/jsdom/jsdom) ç¯å¢ƒå®Œå…¨å…¼å®¹ï¼Œæˆ–è€…åœ¨ç”± DOM æµ‹è¯•åº“æ¸²æŸ“æ—¶æ— æ³•æŒ‰é¢„æœŸå·¥ä½œ

ä½¿ç”¨ **Cypress** æµ‹è¯•ç»„ä»¶ï¼š

- ä¼˜ç‚¹ï¼šå®ƒè‡ªåŠ¨åŒ–äº†ä¸€ä¸ª**çœŸå®çš„æµè§ˆå™¨**ï¼Œç»„ä»¶åœ¨å°†è¦ä½¿ç”¨çš„ç›¸åŒç¯å¢ƒä¸­è¿›è¡Œäº†æµ‹è¯•

- ä¼˜ç‚¹ï¼šä½ å¯ä»¥æµ‹è¯•ç”¨æˆ·å°†è¦çœ‹åˆ°/ä½¿ç”¨çš„ç»„ä»¶çš„æ–¹å¼

- ä¼˜ç‚¹ï¼šä½ å¯ä»¥æ£€æŸ¥ä½ çš„**Storybook æ˜¯å¦æ­£å¸¸å·¥ä½œ**ã€‚ä½ çš„æ•…äº‹å¯èƒ½å­˜åœ¨é”™è¯¯ï¼Œå› æ­¤æ‹¥æœ‰ä¸€äº›å·¥ä½œæ­£å¸¸çš„ç»„ä»¶å¹¶ä¸èƒ½ä¿è¯ Storybook æ­£å¸¸å·¥ä½œã€‚è€Œå›¢é˜Ÿçš„å…¶ä½™æˆå‘˜å¯èƒ½å°† Storybook è§†ä¸ºå›¢é˜Ÿ/å…¬å¸çš„ç»„ä»¶åº“ã€‚

- ç¼ºç‚¹ï¼š**å®ƒéœ€è¦ä¸€ä¸ªè¿è¡Œçš„ä¸»æœº**/ç½‘ç«™ï¼Œå…è®¸ä½ ä¸ç»„ä»¶æœ¬èº«è¿›è¡Œäº¤äº’ï¼ˆå¦‚ Storybookï¼‰

- ç¼ºç‚¹ï¼šæµ‹è¯•æ•°ç™¾ä¸ªç»„ä»¶å¯èƒ½ä¼šå¾ˆæ…¢

è¯·æ³¨æ„ï¼šå¯¹äº Cypressï¼Œæœ‰ [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro) æ’ä»¶ï¼Œå®ƒå…è®¸ä½ åˆ©ç”¨ DOM æµ‹è¯•åº“çš„ç›¸åŒçš„ _findByText_ã€_findByPlaceholderText_ã€_findByTestId_ ç­‰ APIã€‚æˆ‘å–œæ¬¢å®ƒï¼Œæˆ‘æ€»æ˜¯ä½¿ç”¨å®ƒï¼Œä½†å®ƒä»¬åœ¨ Cypress å†…éƒ¨å·¥ä½œï¼Œè€Œä¸æ˜¯åœ¨å…¶ä»–æµ‹è¯•è¿è¡Œå™¨ä¸­å·¥ä½œ

## ä¸€ä¸ªçœŸå®çš„ä¾‹å­ï¼šè™šæ‹Ÿåˆ—è¡¨

æœ€è¿‘ï¼Œæˆ‘å¼€å‘äº†ä¸€ä¸ª VirtualList ç»„ä»¶ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥æ£€æŸ¥ Storybook å’Œ Cypress å¦‚ä½•ä¸€èµ·å·¥ä½œã€‚VirtualList æ˜¯ä¸€ä¸ªåªæ¸²æŸ“å¯è§é¡¹ä»¥ç¡®ä¿æœ€é«˜æ€§èƒ½çš„åˆ—è¡¨ã€‚æŸ¥çœ‹ [React Virtualized](https://bvaughn.github.io/react-virtualized/#/components/List) ä»¥äº†è§£å…¶å·¥ä½œåŸç†ã€‚é™¤äº†è™šæ‹ŸåŒ–ä¹‹å¤–ï¼Œæˆ‘çš„ VirtualList è¿˜å¤„ç†é¡¹ç›®çš„ç‚¹å‡»å’Œé¡¹ç›®çš„å¤šé€‰ã€‚

é™¤äº†å¤§

é‡çš„å•å…ƒæµ‹è¯•å¤–ï¼Œæˆ‘æƒ³è¿è¡Œä¸€äº›ç»„ä»¶æµ‹è¯•ï¼Œä½†æ˜¯å¦‚ä¸Šæ‰€è¿°ï¼Œç¬¬ä¸‰æ–¹åº“ï¼ˆæ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨çš„ [React Smooth Scrollbar](https://www.npmjs.com/package/react-smooth-scrollbar)ï¼‰å¯èƒ½ä¸ [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)ï¼ˆDOM æµ‹è¯•åº“çš„ React ç‰ˆæœ¬ï¼‰ä¸å…¼å®¹ï¼Œå› æ­¤ Cypress æ˜¯å”¯ä¸€çš„é€‰æ‹©ã€‚

## æµ‹è¯•æŒ‘æˆ˜

ä½¿ç”¨ Cypress åœ¨ Storybook ä¸­æµ‹è¯•ç»„ä»¶è€Œä¸æ˜¯è¿è¡Œæ ‡å‡†çš„ E2E æµ‹è¯•æœ‰å“ªäº›æœ€å¤§çš„æŒ‘æˆ˜ï¼Ÿä¸ä½¿ç”¨ [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)ï¼ˆDOM æµ‹è¯•åº“çš„ React ç‰ˆæœ¬ï¼‰è¿›è¡Œæ ‡å‡†ç»„ä»¶æµ‹è¯•ç›¸æ¯”ï¼Œæœ‰ä»€ä¹ˆæŒ‘æˆ˜ï¼Ÿ

### æ•°æ®æºæ§åˆ¶

ä½¿ç”¨ Cypressï¼Œæˆ‘ä»¬ä¹ æƒ¯äºåŠ è½½æ•´ä¸ªåº”ç”¨ç¨‹åºï¼Œé€šè¿‡é™æ€å›ºä»¶ï¼ˆåœ¨ [UI é›†æˆæµ‹è¯•](../testing-strategy/component-vs-integration-vs-e2e-testing.zh.md) çš„æƒ…å†µä¸‹ï¼‰æˆ–è¯»å–/æ‹¦æˆªåç«¯æ•°æ®ï¼ˆåœ¨ [E2E æµ‹è¯•](../testing-strategy/component-vs-integration-vs-e2e-testing.zh.md) çš„æƒ…å†µä¸‹ï¼‰æ¥æ§åˆ¶æ•°æ®ï¼Œå¹¶ä½¿ç”¨æ­¤æ•°æ®æ¥æ–­è¨€ UI æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ§åˆ¶ï¼Œæˆ–è€…è‡³å°‘äº†è§£ï¼ŒUI å°†è¦ä½¿ç”¨çš„æ•°æ®ã€‚**ä¸äº†è§£æ•°æ®å°†æ„å‘³ç€æ²¡æœ‰æ–­è¨€**ã€‚
ä½†åœ¨ï¼ˆæ— çŠ¶æ€ï¼‰ç»„ä»¶æ•…äº‹ä¸­ï¼Œæ•°æ®ç›´æ¥ç”±ä»£è¡¨æ•…äº‹å¹¶æ¸²æŸ“ç»„ä»¶çš„ç»„ä»¶ä¼ é€’ç»™ç»„ä»¶ã€‚ä¸ºäº†äº†è§£æ•°æ®å¹¶å¯¹ç”±æ•…äº‹ç»„ä»¶æ˜¾ç¤ºçš„å†…å®¹è¿›è¡Œé€‚å½“çš„æ–­è¨€ï¼Œ**æ•°æ®éœ€è¦ç”±æ•…äº‹æš´éœ²å¹¶ç”± Cypress è¯»å–**ã€‚

è¯·æ³¨æ„ï¼šå¦‚æœ Cypress æµ‹è¯•ä¸æ•…äº‹çš„ç»„ä»¶ä½äºåŒä¸€ä¸ªå­˜å‚¨åº“ä¸­ï¼Œä½ å¯ä»¥ä»æ•…äº‹æ–‡ä»¶ä¸­å¯¼å…¥æ•°æ®ï¼Œä½†ä¸‹é¢æ˜¾ç¤ºçš„ç¤ºä¾‹æ¥è‡ªä¸åœ¨æ•…äº‹å­˜å‚¨åº“ä¸­çš„æµ‹è¯•ã€‚

### éšè—å†…å®¹

**è™šæ‹Ÿåˆ—è¡¨ä¼šä» DOM ä¸­åˆ é™¤ä¸å¯è§çš„ç»„ä»¶**ã€‚è¿™å¯¹æµ‹è¯•æ„å‘³ç€ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¸èƒ½æŒ‡æœ›æ‰€æœ‰å…ƒç´ éƒ½å­˜åœ¨äº HTML ä¸­çš„äº‹å®ä¸Šã€‚æ— è®ºæ˜¯ React Testing Library è¿˜æ˜¯ Cypress éƒ½ä¸èƒ½å®Œå…¨åˆ©ç”¨å®ƒä»¬æ¥ç†è§£è™šæ‹Ÿåˆ—è¡¨çš„å·¥ä½œæ–¹å¼ï¼Œå› ä¸ºä¸€æ—¦éœ€è¦æ–­è¨€ä¸€ä¸ªåœ¨å¯è§åŒºåŸŸä¹‹å¤–çš„é¡¹çš„å­˜åœ¨ï¼Œå°±æ— æ³•åˆ©ç”¨é€šå¸¸çš„ _cy.contains_ / _findByText ç­‰_ å®ç”¨å·¥å…·ï¼šå› ä¸ºè¿™äº›é¡¹æ ¹æœ¬ä¸å­˜åœ¨ã€‚

VirtualList æ˜¯ä¸€ä¸ªå—æ§ç»„ä»¶ï¼Œå› æ­¤å®ƒä¼šé€šçŸ¥çˆ¶ç»„ä»¶æœ‰å“ªäº›è¢«æ¸²æŸ“çš„é¡¹ä»¥åŠå“ªäº›æ˜¯é€‰ä¸­çš„é¡¹ã€‚åœ¨æ ‡å‡†çš„ [ç»„ä»¶æµ‹è¯•](../testing-strategy/component-vs-integration-vs-e2e-testing.zh.md) ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ–­è¨€ä¼ é€’ç»™ VirtualList ç»„ä»¶çš„ä¸Šä¸‹æ–‡å’Œä¸‹è¡Œçš„ propsï¼Œæ•…äº‹ç›´æ¥æ§åˆ¶è¿™äº› propsï¼Œä½†æ˜¯å†æ¬¡ï¼ŒCypress éœ€è¦è¯»å–è¿™äº›æ•°æ®ï¼Œå› æ­¤æ•…äº‹å¿…é¡»å°†å…¶æš´éœ²å‡ºæ¥ã€‚

### æˆ‘ä»¬æ˜¯åœ¨æµ‹è¯•æ•…äº‹è¿˜æ˜¯ç»„ä»¶ï¼Ÿ

åŒºåˆ«å¯èƒ½å¾®å¦™ã€‚ç”±äº VirtualList æ˜¯ä¸€ä¸ªå—æ§ç»„ä»¶ï¼Œæ•…äº‹çš„ç»„ä»¶å¯¹å…¶è¿›è¡Œæ§åˆ¶ã€‚æ•…äº‹ç»„ä»¶å†…éƒ¨çš„æ§åˆ¶é€»è¾‘æ˜¯éœ€è¦æµ‹è¯•çš„å—ï¼Ÿæ§åˆ¶ç»„ä»¶å’Œè¢«æ§åˆ¶ç»„ä»¶æ˜¯å¦å¯åˆ†ç¦»ï¼Ÿå¯èƒ½ä¸å¤ªå¯èƒ½ã€‚

æ ‡å‡†æµ‹è¯•æœ‰ä¸¤ä¸ªè§’è‰²â€”â€”æµ‹è¯•è¿è¡Œå™¨å’Œå—æ§ç»„ä»¶â€”â€”è€Œä½¿ç”¨ Cypress ä¸ Storybook æ—¶æœ‰**ä¸‰ä¸ªè§’è‰²â€”â€”æµ‹è¯•è¿è¡Œå™¨ã€æ•…äº‹å’Œå—æ§ç»„ä»¶**â€”â€”ã€‚å› æ­¤ï¼Œå¦‚æœç»„ä»¶æµ‹è¯•æ§åˆ¶ç»„ä»¶å¹¶ç›´æ¥è®¿é—®å›è°ƒæ•°æ®ï¼ŒCypress éœ€è¦æ•…äº‹ç»„ä»¶æ­£å¸¸å·¥ä½œã€‚

### æ»šåŠ¨å’Œæ¸²æŸ“é¡¹æ§åˆ¶

VirtualList ç»„ä»¶åˆ©ç”¨æƒ¯æ€§æ»šåŠ¨ï¼Œå¹¶ä¸”ç”±äºæ•…äº‹æ·»åŠ äº†æˆåƒä¸Šä¸‡ä¸ªè¦æ¸²æŸ“çš„é¡¹ä»¥å®Œå…¨æ˜¾ç¤º VirtualList çš„æ½œåŠ›ï¼Œæ‰€ä»¥æ»šåŠ¨ VirtualList å¯èƒ½ä¼šå¯¼è‡´æµ‹è¯•å’Œä¸‹ä¸€ä¸ªæµ‹è¯•ä¹‹é—´çš„æ¸²æŸ“é¡¹ç•¥æœ‰ä¸åŒã€‚å› æ­¤ï¼Œæˆ‘è®¤ä¸ºæˆ‘ä»¬ä¸èƒ½æå‰çŸ¥é“åœ¨æ»šåŠ¨åˆ—è¡¨åå°†æ¸²æŸ“å“ªäº›é¡¹ï¼ˆä¾‹å¦‚ä»ç¬¬ 100 ä¸ªåˆ°ç¬¬ 110 ä¸ªï¼Œæˆ–ä»ç¬¬ 101 ä¸ªåˆ°ç¬¬ 111 ä¸ªï¼‰ã€‚

ä¸ºä»€ä¹ˆï¼Ÿå› ä¸º**æˆ‘è®¨åŒåŸºäºè„†å¼±å‡è®¾çš„æ˜“ç¢æµ‹è¯•**ã€‚æµ‹è¯•ä¸åº”è¯¥è®¾è®¡æˆå¯ä»¥æŠµå¾¡æ¯ä¸€ç§å¯èƒ½çš„å˜åŒ–ï¼Œè€Œæ˜¯å¿…é¡»è¶³å¤Ÿå¥å£®ï¼Œèƒ½å¤Ÿç»å—å°çš„å˜åŒ–ã€‚å¯¹äº VirtualList æµ‹è¯•æ¥è¯´ï¼Œè¿™æ„å‘³ç€ä¸€æ—¦æ»šåŠ¨ï¼Œå°†ç›´æ¥ä» HTML ä¸­æ£€ç´¢æ¸²æŸ“çš„é¡¹ã€‚æˆ‘ä»¬å°†åœ¨åé¢æ·±å…¥æ¢è®¨ã€‚

## è¯·ç»™å‡ºä»£ç 

æˆ‘ä»¬è¦ç¼–å†™çš„ç¬¬ä¸€ä¸ªæµ‹è¯•éœ€è¦æ£€æŸ¥ï¼Œå¦‚æœåˆ—è¡¨æ”¶åˆ°äº† 10000 ä¸ªé¡¹ç›®ï¼Œåªæ¸²æŸ“å…¶ä¸­çš„ä¸€å°éƒ¨åˆ†ã€‚è¿™æ˜¯ Virtual List çš„åŸºæœ¬åŠŸèƒ½ã€‚

é¦–å…ˆæ˜¯ RenderItem ç»„ä»¶ï¼Œå®ƒåªæ˜¯äº¤æ›¿æ›´æ”¹é¢œè‰²ä»¥ç›´è§‚æ ‡è¯†è¡Œ

```js
// every `item` is an { id: string, name: string}
const getItemText = (item) => `id: ${item.id} - ${item.name}`

const RenderItem = ({ item }) => {
  return (
    <div
      style={{
        height: '30px',
        backgroundColor: parseInt(item.id) % 2 ? '#FAFAFA' : '#EEE',
      }}
    >
      {getItemText(item)}
    </div>
  )
}
```

æˆ‘ä»¬å°†å¤„ç†çš„åŸå§‹æ•…äº‹å¦‚ä¸‹

```js
// `getStoryItems` allows to create a high amount of items, it's used by every story
export const With10000Items = () => {
  return (
    <>
      <h4>The scroll must be fluid</h4>
      <VirtualList
        items={getStoryItems({ amount: 10000 })}
        getItemHeights={() => 30}
        RenderItem={RenderItem}
        listHeight={300}
      />
    </>
  )
}
With10000Items.story = {
  name: 'With 10000 items',
}
```

æˆ‘ä»¬éœ€è¦è°ƒæ•´æ•…äº‹ä»¥å…¨å±€å…¬å¼€ä»¥ä¸‹å†…å®¹ï¼š

- `items` æ•°ç»„ï¼šCypress æµ‹è¯•éœ€è¦çŸ¥é“ç”¨äºå¡«å……åˆ—è¡¨çš„æ•°æ®

- `getItemText` å‡½æ•°ï¼šè¿™æ · Cypress æµ‹è¯•å°±æ— éœ€å…³å¿ƒå¦‚ä½•ä»é¡¹ç›®è·å–æ¸²æŸ“çš„æ–‡æœ¬ã€‚Cypress éœ€è¦å°†é¡¹ç›®è½¬æ¢ä¸ºæ–‡æœ¬ï¼Œä»¥ä»å…¶æ–‡æœ¬ä¸­æ£€ç´¢æ¸²æŸ“çš„é¡¹ç›®ï¼Œé¿å…ä½¿ç”¨ `data-test` å±æ€§

- å¯è§é¡¹ç›®çš„æ•°é‡ï¼šCypress æµ‹è¯•éœ€è¦æ–­è¨€å“ªäº›é¡¹ç›®è¢«æ¸²æŸ“ï¼Œå“ªäº›æ²¡æœ‰

ä»¥ä¸‹æ˜¯ç»è¿‡æ›´æ–°ä»¥é€šè¿‡å…¨å±€ `storyData` å˜é‡å…¬å¼€å˜é‡çš„æ•…äº‹ï¼š

```js
export const With10000Items = () => {
  const itemHeight = 30
  const listHeight = 300
  const items = React.useMemo(() => getStoryItems({ amount: 10000 }), [])

  // exposing data for Cypress
  React.useEffect(() => {
    // global is `window`
    global.storyData = {
      items,
      visibleItemsAmount: Math.ceil(listHeight / itemHeight),
      getItemText,
    }
  }, [items])

  return (
    <>
      <h4>The scroll must be fluid</h4>
      <VirtualList
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={RenderItem}
        listHeight={listHeight}
      />
    </>
  )
}
With10000Items.story = {
  name: 'With 10000 items',
}
```

### Cypress çš„æµ‹è¯•

æµ‹è¯•å°†æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- è®¿é—® Storybook é¡µé¢

- æ”¶é›†å…¬å¼€çš„æ•°æ®

- æ£€æŸ¥æ¸²æŸ“çš„é¡¹ç›®

ç¬¬ä¸€å’Œç¬¬äºŒç‚¹çš„ä»£ç å¦‚ä¸‹ï¼š

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(() => {
      // the test code
    })
})
```

ä¸ºä»€ä¹ˆè¦æ–­è¨€å…¬å¼€çš„ `storyData`ï¼Ÿå› ä¸ºé”™è¯¯çš„ `storyData` ä¼šå¯¼è‡´æµ‹è¯•å¤±è´¥ï¼Œå¦‚æœæµ‹è¯•å¤±è´¥ï¼Œå®ƒå¿…é¡»ç›´æ¥å¼•å¯¼æˆ‘ä»¬æ‰¾åˆ°é—®é¢˜ã€‚å¦‚æœç»„ä»¶æ¸²æŸ“å› ä¸ºé”™è¯¯çš„ `storyData` è€Œå¤±è´¥ï¼Œæˆ‘ä»¬çš„æµ‹è¯•æ ¹æœ¬ä¸åº”è¯¥è¿è¡Œã€‚è¿™å¯ä»¥è¢«è§†ä¸º**ä¸æ•°æ®ç›¸å…³çš„å†’çƒŸæµ‹è¯•**ã€‚

ç°åœ¨ï¼Œæµ‹è¯•çš„ç¼ºå¤±éƒ¨åˆ†ï¼šæ£€æŸ¥å“ªäº›é¡¹ç›®è¢«æ¸²æŸ“ï¼Œå“ªäº›æ²¡æœ‰è¢«æ¸²æŸ“ã€‚

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // items visibility check
      const visibleItems = items.slice(0, visibleItemsAmount - 1)
      visibleItems.forEach((item) => {
        cy.findByText(getItemText(item)).should('be.visible')
      })

      // first not-rendered item check
      cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
    })
})
```

- æˆ‘ä»¬ä½¿ç”¨å…¬å¼€çš„ `visibleItemsAmount` å˜é‡æ¥ä»…æ£€ç´¢å·²æ¸²æŸ“çš„é¡¹ç›®

  const visibleItems = items.slice(0, visibleItemsAmount - 1)

- æˆ‘ä»¬ä½¿ç”¨å…¬å¼€çš„ `getItemText` å‡½æ•°ä»é¡µé¢ä¸­æ£€ç´¢æ¯ä¸ªé¡¹ç›®

  cy.findByText(getItemText(item))

- æˆ‘ä»¬æ–­è¨€æ‰€æœ‰é¢„æœŸå¯è§çš„é¡¹ç›®

  cy.findByText(getItemText(item)).should('be.visible')

- æˆ‘ä»¬æ–­è¨€ä¸‹ä¸€ä¸ªé¡¹ç›®åœ¨é¡µé¢ä¸­ä¸å­˜åœ¨

```js
cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
```

è¯·æ³¨æ„ï¼Œ`cy.findByText` Cypress å‘½ä»¤æ¥æºäºâ€¦ [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro) ğŸ˜Šï¼Œè¿™æ˜¯æˆ‘æœ€å–œæ¬¢çš„æ£€ç´¢é¡µé¢å…ƒç´ çš„æ–¹å¼ï¼Œå› ä¸ºå®ƒçš„è¡Œä¸ºå°±åƒç”¨æˆ·ä¸€æ ·ï¼šé€šè¿‡æ–‡æœ¬å†…å®¹è¯»å–/æ£€ç´¢å…ƒç´ ã€‚æˆ‘ä½¿ç”¨å®ƒè€Œä¸æ˜¯ `cy.contains`ï¼Œä½†å®ƒä»¬æ‰§è¡Œç›¸åŒçš„åŠŸèƒ½ã€‚

è¿™å°±æ˜¯ç»“æœï¼š

![Cypress å—æ§æµè§ˆå™¨ï¼Œå·¦ä¾§æ˜¯æ‰€æœ‰æ–­è¨€ç»“æœï¼Œå³ä¾§æ˜¯ Storybook æ•…äº‹ã€‚](../../assets/images/cypress-storyboook/list-test.png 'ç¬¬ä¸€ä¸ªæµ‹è¯•çš„ç»“æœï¼šåŠ è½½çš„æ•…äº‹å’Œæ‰€æœ‰æ–­è¨€çš„ç»“æœã€‚')_ç¬¬ä¸€ä¸ªæµ‹è¯•çš„ç»“æœï¼šåŠ è½½çš„æ•…äº‹å’Œæ‰€æœ‰æ–­è¨€çš„ç»“æœã€‚_

è¿™ä¸ªæµ‹è¯•è¶³ä»¥æ£€æŸ¥è™šæ‹Ÿåˆ—è¡¨æ˜¯å¦åªæ¸²æŸ“äº†æœ€å°æ•°é‡çš„é¡¹ç›®ã€‚

æœ€åˆï¼Œæˆ‘è¯•å›¾æ£€æŸ¥åœ¨è™šæ‹Ÿåˆ—è¡¨æ»šåŠ¨æ—¶æµè§ˆå™¨æ˜¯å¦ä»¥ 60 FPS è¿è¡Œã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸º**UI æµ‹è¯•å¿…é¡»æ£€æŸ¥ç”¨æˆ·æ‰€è§çš„å†…å®¹ï¼Œä»¥ä¸ç”¨æˆ·ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ UI**ã€‚ä»ç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œè™šæ‹Ÿåˆ—è¡¨çš„å”¯ä¸€ç›®æ ‡æ˜¯å¿…é¡»æµç•…è¿è¡Œï¼Œæ— è®ºåˆ—è¡¨ä¸­åŒ…å«å¤šå°‘é¡¹ç›®ã€‚ä½†æ˜¯å¯é åœ°æµ‹é‡ FPS éš¾åº¦å¾ˆå¤§ï¼Œå› ä¸ºæµ‹é‡ç»“æœä¼šå—åˆ°ä»¥ä¸‹å½±å“ï¼š

- æ‚¨ä½¿ç”¨çš„ Cypress å‘½ä»¤ï¼šæ¯ä¸ª Cypress åŠ¨ä½œéƒ½ä¼šå‡æ…¢æµè§ˆå™¨çš„é€Ÿåº¦

- ç”¨äºè¿è¡Œæµ‹è¯•çš„æœºå™¨ï¼ˆæˆ– Docker é•œåƒï¼‰çš„èµ„æºæ•°é‡

ç”±äºä¸å¯èƒ½è·å¾—å¯é çš„è®¡æ•° â€” ä¸€äº›åˆå§‹å€¼å°†è¢«ä¸¢å¼ƒç­‰ç­‰ â€” æˆ‘å†³å®šä»…æ£€æŸ¥æ¸²æŸ“çš„é¡¹ç›®æ•°é‡ã€‚å¦‚æœæˆ‘ç¡®ä¿¡åªæœ‰ 10000 é¡¹ä¸­çš„ 10 é¡¹è¢«æ¸²æŸ“ï¼Œé‚£ä¹ˆæˆ‘ç¡®ä¿¡åˆ—è¡¨è¿è¡Œæµç•…ã€‚æ€»çš„æ¥è¯´ï¼šè®°ä½**è„†å¼±çš„æµ‹è¯•æ¯”ç¼ºå¤±çš„æµ‹è¯•æ›´ç³Ÿç³•**ã€‚

## ç¬¬äºŒä¸ªæµ‹è¯•ï¼šæ»šåŠ¨

é¦–å…ˆè¦è¯´æ˜ï¼šVirtualList ç»„ä»¶ä½¿ç”¨ [Smooth Scrollbar](https://idiotwu.github.io/smooth-scrollbar/)ï¼ŒSmooth Scrollbar å·²ç»æœ‰äº†è‡ªå·±çš„æµ‹è¯•ï¼Œå› æ­¤æˆ‘ä»¬ä¸»è¦å…³æ³¨çš„æ˜¯ VirtualList ç»„ä»¶å¦‚ä½•å“åº”æ»šåŠ¨ã€‚åœ¨ä½¿ç”¨**ç¬¬ä¸‰æ–¹åº“**æ—¶ï¼Œä½ ä¸éœ€è¦æµ‹è¯•è¯¥åº“æ˜¯å¦æœ‰æ•ˆã€‚è¯¥åº“**åº”è¯¥æœ‰è‡ªå·±çš„æµ‹è¯•**ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±æ¢ä¸ªåº“å§ï¼åƒä¸‡åˆ«ä¸ºç¬¬ä¸‰æ–¹åº“ç¼–å†™æµ‹è¯•ã€‚

æ»šåŠ¨æµ‹è¯•çš„æ­¥éª¤åŒ…æ‹¬ï¼š

- è§¦å‘æ»šåŠ¨

- ç­‰å¾…æ»šåŠ¨ç»“æŸ

- æ£€æŸ¥æ¸²æŸ“çš„é¡¹

å› æ­¤ï¼Œè§¦å‘æ»šåŠ¨çš„æµ‹è¯•ä»£ç å¦‚ä¸‹

```js
// triggers the wheel event
cy.findByTestId('VirtualList').trigger('wheel', {
  deltaX: 0,
  deltaY: 1000,
})
```

è¯·æ³¨æ„ï¼Œ`VirtusList` ç»„ä»¶åº”è¯¥åœ¨æ¸²æŸ“æ—¶ç”Ÿæˆä¸€ä¸ªå¸¦æœ‰ `data-test="VirtualList"` å±æ€§çš„ DOM å…ƒç´ ã€‚å…¶ä½™çš„ç”± Cypress å¤„ç†ï¼Œ`trigger` ç›´æ¥æ˜ å°„äº† [jQuery trigger API](https://api.jquery.com/trigger/)ï¼ˆCypress åˆ©ç”¨ jQuery æ¥å°½é‡ç¼©çŸ­æµ‹è¯•ä»£ç ï¼‰ã€‚å†æ¬¡å¼ºè°ƒä¸€ä¸‹ï¼šCypress çš„æœ¬åœ°ç­‰ä»·äº `cy.findByTestId('VirtualList')` æ˜¯ `cy.get('[data-testid=VirtualList]')`ã€‚

è‡³äºâ€œç­‰å¾…æ»šåŠ¨ç»“æŸâ€çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ [Cypress waitUntil](https://github.com/NoriSte/cypress-wait-until) æ’ä»¶ã€‚ä¸ºä»€ä¹ˆæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ waitUntil æ’ä»¶è€Œä¸æ˜¯ç­‰å¾…å›ºå®šæ—¶é—´çš„åŸå› åœ¨ [ç­‰å¾…ï¼Œä¸è¦è®©ä½ çš„ E2E æµ‹è¯•ä¼‘çœ ](../generic-best-practices/await-dont-sleep.zh.md) ç« èŠ‚ä¸­æœ‰è¯¦ç»†çš„è§£é‡Šã€‚
è‡ªå®šä¹‰ç­‰å¾…çš„ä»£ç å¦‚ä¸‹ï¼š

```js
// waits until the scrollbar handle stops
let scrollbarHandleY = Number.NEGATIVE_INFINITY
cy.get('.scrollbar-thumb-y').waitUntil(
  ($scrollbarHandle) => {
    const [newY, previousY] = [$scrollbarHandle.offset().top, scrollbarHandleY]
    scrollbarHandleY = newY
    return previousY === newY
  },
  {
    customMessage: 'The inertial scroll ends',
  }
)
```

å› æ­¤ï¼Œæˆ‘ä»¬ç¡®ä¿æµ‹è¯•ç­‰å¾…äº†æ­£ç¡®çš„æ—¶é—´ã€‚

### æ£€æŸ¥æ¸²æŸ“çš„é¡¹ç›®

è¿™æ„å‘³ç€ï¼š

- æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“çš„é¡¹ç›®

- æ£€æŸ¥ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“çš„é¡¹ç›®æ˜¯å¦ä¸æ˜¯ç¬¬ä¸€ä¸ªé¡¹ç›®ã€‚è™šæ‹Ÿåˆ—è¡¨å¼€å§‹æ¸²æŸ“ä»ç¬¬ 0 åˆ° 10 ä¸ªé¡¹ç›®ã€‚ä¸€æ—¦æ»šåŠ¨ï¼Œå®ƒå¿…é¡»å·²æ¸²æŸ“ç¬¬ X åˆ° X+10 ä¸ªé¡¹ç›®ã€‚æˆ‘ä»¬å¹¶ä¸çŸ¥é“ X çš„å…·ä½“å€¼ï¼Œä¹Ÿå¹¶ä¸å…³å¿ƒï¼Œå¦åˆ™æµ‹è¯•å°†ä¸ç¡®åˆ‡çš„å·²æ¸²æŸ“é¡¹ç›®ç»‘å®šåœ¨ä¸€èµ·ã€‚ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“çš„é¡¹ç›®æ˜¯ç¬¬ 60 æˆ–ç¬¬ 61 ä¸ªå¹¶ä¸é‡è¦ã€‚æ£€æŸ¥ç¡®åˆ‡çš„å·²æ¸²æŸ“é¡¹ç›®è¶…å‡ºäº†è¿™ä¸ªé€šç”¨æ»šåŠ¨æµ‹è¯•çš„èŒƒå›´ã€‚æµ‹è¯•çš„ç¨³å®šæ€§å¯¹æˆ‘ä»¬æœ‰åˆ©ã€‚

- ä¸€æ—¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“çš„é¡¹ç›®ï¼Œæˆ‘ä»¬æ£€æŸ¥æ¥ä¸‹æ¥çš„åä¸ªé¡¹ç›®æ˜¯å¦éƒ½å·²æ¸²æŸ“

æˆ‘ä»¬å°†é€æ­¥è¿›è¡Œæ¯ä¸ªæ­¥éª¤ï¼Œæµ‹è¯•çš„æœ€ç»ˆä»£ç å¦‚ä¸‹ï¼š

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // triggers the wheel event
      cy.findByTestId('VirtualList').trigger('wheel', {
        deltaX: 0,
        deltaY: 1000,
      })

      // waits until the scrollbar handle stops
      let scrollbarHandleY = Number.NEGATIVE_INFINITY
      cy.get('.scrollbar-thumb-y')
        .waitUntil(
          ($scrollbarHandle) => {
            const [newY, previousY] = [$scrollbarHandle.offset().top, scrollbarHandleY]
            scrollbarHandleY = newY
            return previousY === newY
          },
          {
            customMessage: 'The inertial scroll ends',
          }
        )
        // (manually) looks for the first rendered element
        .then(() =>
          items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
        )
        // checks that the rendered items are not the initially rendered ones
        .should('be.greaterThan', 10)
        // checks the rendered items
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

é€æ­¥è¿›è¡Œï¼šæ£€ç´¢ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“é¡¹ç›®çš„ä»£ç å¦‚ä¸‹ï¼š

```js
items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
```

ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ `cy.findByText` å‘½ä»¤æ¥æ£€ç´¢å‘¢ï¼Ÿå› ä¸ºåœ¨ Cypress ä¸­ï¼Œæ¯ä¸ª `cy.get` å‘½ä»¤ï¼ˆä¹Ÿæ˜¯ `cy.findByText` å‘½ä»¤æ ¸å¿ƒçš„ä¸€éƒ¨åˆ†ï¼‰éƒ½å†…ç½®äº†æ–­è¨€ï¼Œ[åœ¨å®˜æ–¹æ–‡æ¡£ä¸­æŸ¥çœ‹](https://docs.cypress.io/api/commands/get.html#Assertions)ã€‚åŸºæœ¬ä¸Šï¼Œå¦‚æœé¡µé¢ä¸Šä¸å­˜åœ¨è¯¥å…ƒç´ ï¼Œ`cy.get` å°†å¯¼è‡´æµ‹è¯•å¤±è´¥ã€‚ä½†ç”±äºæˆ‘ä»¬éœ€è¦æµè§ˆæœªæ¸²æŸ“çš„é¡¹ç›®ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“çš„é¡¹ç›®ï¼Œæˆ‘ä»¬åº”è¯¥æ‰‹åŠ¨è¿›è¡Œã€‚Cypress.\$ æ˜¯ jQuery çš„å…¨å±€å®ä¾‹ï¼Œ`cy.findByText("XXX")` çš„ jQuery ç‰ˆæœ¬æ˜¯ `Cypress.$(`\*:contains("XXX")`)`ï¼Œè€Œä¸” jQuery ç‰ˆæœ¬å¦‚ä¸‹ï¼š

```js
cy.findByText('XXX').should('exist')
```

æ˜¯

```js
!!Cypress.$(`*:contains("XXX")`).length
```

å”¯ä¸€çš„åŒºåˆ«æ˜¯å¦‚æœå…ƒç´ ä¸å­˜åœ¨ï¼Œå®ƒä¸ä¼šå¯¼è‡´å¤±è´¥ã€‚æ­£å¦‚å‰é¢æ‰€è¯´ï¼šæˆ‘ä¹ æƒ¯ä½¿ç”¨ `cy.getByText`ï¼Œä½†æœ¬åœ°çš„ `cy.contains` ä¹Ÿèƒ½è¾¾åˆ°åŒæ ·çš„æ•ˆæœï¼

ä¸€æ—¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“é¡¹ç›®çš„ç´¢å¼•ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥æ¥ä¸‹æ¥çš„å·²æ¸²æŸ“é¡¹ç›®ã€‚

```js
.then(() =>
  items.findIndex(
    item => !!Cypress.$(`*:contains("${getItemText(item)}")`).length,
  )
)
// checks that the rendered items are not the initially rendered ones
.should('be.greaterThan', 10)
// checks the rendered items
.then(firstVisibleItemIndex => {
  const visibleItems = items.slice(
    firstVisibleItemIndex,
    firstVisibleItemIndex + visibleItemsAmount - 1,
  )
  visibleItems.forEach(item =>
    cy.findByText(getItemText(item)).should('be.visible'),
  )
})
```

[è¿™æ˜¯æµ‹è¯•çš„å½•åƒè§†é¢‘](https://www.youtube.com/watch?v=OEMkz_86bqY)ã€‚

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒæœ€ååŠä¸ªå¯è§çš„é¡¹ç›®ã€‚æµ‹è¯•çš„èŒƒå›´æ˜¯æ£€æŸ¥å·²æ¸²æŸ“çš„é¡¹ç›®æ˜¯å¦ä¸æ˜¯ç¬¬ä¸€ä¸ªï¼Œå¹¶ä¸”è‡³å°‘æœ‰åä¸ªé¡¹ç›®å·²è¢«æ¸²æŸ“ï¼Œä¸éœ€è¦æ£€æŸ¥ç¬¬ 11 ä¸ªé¡¹ç›®ã€‚

æˆ‘ä»¬å¯ä»¥å°†æµ‹è¯•çš„æ»šåŠ¨éƒ¨åˆ†ç§»åˆ°ä¸€ä¸ªç‹¬ç«‹çš„å®ç”¨ç¨‹åºï¼Œç±»ä¼¼äºï¼š

```js
const scrollVirtualList = ($list, deltaY = 1000) => {
  cy.wrap($list)
    .trigger('wheel', {
      deltaX: 0,
      deltaY,
    })
    .within(() => {
      // waits for the inertial scroll end
      let scrollbarY = Number.NEGATIVE_INFINITY
      getScrollbar().waitUntil(
        ($scrollbar) => {
          const newY = $scrollbar.offset().top
          const previousY = scrollbarY
          scrollbarY = newY
          return previousY === newY
        },
        {
          customMessage: 'The inertial scroll end',
        }
      )
    })
}
```

è€Œä¸”æˆ‘ä»¬å¯ä»¥å¯¹æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“é¡¹ç›®çš„è¿‡ç¨‹é‡‡ç”¨ç›¸åŒçš„æ–¹æ³•ã€‚

```js
const getFirstRenderedItemIndex = (items, getItemText) => {
  return items.findIndex((item) => !!Cypress.$(`*:contains("${getItemText(item)}")`).length)
}
```

è¿™ç§åˆ†ç¦»çš„æ–¹å¼æœ‰åŠ©äºæµ‹è¯•çš„å¯è¯»æ€§ï¼Œçœ‹ä¸€ä¸‹ï¼š

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  cy.visit('/iframe.html?id=virtuallist--with-10000-items')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      cy.findByTestId('VirtualList')
        // we leverage the new `scrollVirtualList` function
        .then(scrollVirtualList)
        .then(() => getFirstRenderedItemIndex(items, getItemText))
        .should('be.greaterThan', 10)
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

## ç¬¬ä¸‰ä¸ªæµ‹è¯•ï¼šé€‰æ‹©

VirtualList ç»„ä»¶é€šè¿‡é”®ç›˜ä¿®é¥°é”®æ”¯æŒé€‰æ‹©å’Œ**å¤šé¡¹é€‰æ‹©**ã€‚æˆ‘ä»¬åªéœ€ç‚¹å‡»é¡¹ç›®ï¼Œç”¨é”®ç›˜ä¿®é¥°é”®ç‚¹å‡»é¡¹ç›®ï¼Œå¹¶æ£€æŸ¥å“ªäº›é¡¹ç›®è¢«é€‰ä¸­ã€‚è¿™äº›æ“ä½œæœ‰ä»€ä¹ˆéš¾ç‚¹å‘¢ï¼Ÿ

- é¦–å…ˆï¼šä»€ä¹ˆæ˜¯â€œå·²é€‰æ‹©â€ï¼Ÿä»ç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œå·²é€‰æ‹©çš„é¡¹ç›®æ˜¯â€œçªå‡ºæ˜¾ç¤ºâ€çš„é¡¹ç›®ï¼Œä½†æ£€æŸ¥å…ƒç´ çš„æ ·å¼å¹¶ä¸å¯é ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºç»„ä»¶æ·»åŠ ä¸€ä¸ª `data-selected` å±æ€§â€¦

- â€¦ ä½†å­˜åœ¨ä¸€ä¸ªç»“æ„æ€§çš„é—®é¢˜ï¼šé¡¹ç›®å¯èƒ½æ ¹æœ¬æ²¡æœ‰è¢«æ¸²æŸ“ï¼å¦‚æœæˆ‘ä»¬ç‚¹å‡»ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼ˆä»ç¬¬ 1 ä¸ªåˆ°ç¬¬ 10 ä¸ªé¡¹ç›®å¯è§ï¼‰ï¼Œç„¶åæ»šåŠ¨å¤§çº¦ 20 ä¸ªé¡¹ç›®ï¼ˆä»ç¬¬ 21 ä¸ªåˆ°ç¬¬ 30 ä¸ªé¡¹ç›®å¯è§ï¼‰ï¼Œå¹¶æŒ‰ä½ SHIFT é”®ç‚¹å‡»ä¸­é—´çš„é¡¹ç›®ï¼ˆç¬¬ 25 ä¸ªé¡¹ç›®ï¼‰ï¼Œåˆ™æ‰€é€‰é¡¹ç›®åº”è¯¥æ˜¯ä»ç¬¬ 1 ä¸ªåˆ°ç¬¬ 25 ä¸ªï¼Œä½†å‰ 20 ä¸ªé¡¹ç›®æ²¡æœ‰è¢«æ¸²æŸ“ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•é€šè¿‡å·²æ¸²æŸ“çš„é¡¹ç›®æ¥æ£€ç´¢å·²é€‰æ‹©çš„é¡¹ç›®ã€‚åŒæ ·ï¼Œ**æˆ‘ä»¬å°†ä½¿ç”¨æ•…äº‹ä¸­å…¬å¼€çš„å˜é‡**

è¿™æ˜¯æ•…äº‹çš„ä»£ç ï¼š

```js
export const WithSelectionManagement = () => {
  const items = getStoryItems({ amount: 10000 })

  const [selectedItems, setSelectedItems] = React.useState([])

  const handleSelect = React.useCallback(({ newSelectedIds }) => setSelectedItems(newSelectedIds), [
    setSelectedItems,
  ])

  // exposing data for Cypress
  React.useEffect(() => {
    global.storyData = {
      items,
      getItemText,
      selectedItems,
    }
  }, [items, selectedItems])

  return (
    <>
      <h4>The buttons must be clickable, the CTRL/CMD, ALT, SHIFT keyboard modifiers must work</h4>
      <VirtualList
        items={items}
        selectedItemIds={selectedItems}
        getItemHeights={() => 30}
        RenderItem={createSelectableRenderItem({ height: 30 })}
        listHeight={300}
        onSelect={handleSelect}
      />
    </>
  )
}
```

ç”±äº VirtualList ç»„ä»¶æ˜¯å—æ§ç»„ä»¶ï¼Œå®ƒä¼šå°†æ‰€é€‰é¡¹ç›®çš„åˆ—è¡¨â€”â€”`selectedItems` æ•°ç»„â€”â€”ä¼ é€’ç»™ä¸Šå±‚ã€‚çˆ¶ç»„ä»¶â€”â€”å³æ•…äº‹â€”â€”å‘ Cypress å…¬å¼€äº†è¯¥æ•°ç»„ï¼Œä»¥ä¾¿è¿›è¡Œæ‰€é€‰é¡¹ç›®çš„æ–­è¨€ã€‚
è¯·æ³¨æ„ï¼šç»„ä»¶çš„åˆ›å»ºï¼ŒåŒ…æ‹¬ç‚¹å‡»ç®¡ç†ï¼Œå·²ç»ç§»åˆ°äº†ä¸€ä¸ªä¸“ç”¨çš„é«˜é˜¶å‡½æ•°ä¸­ï¼š`createSelectableRenderdItem`ã€‚

é€‰æ‹©å•ä¸ªé¡¹ç›®çš„æµ‹è¯•å¦‚ä¸‹ï¼š

```js
it('When the items are clicked, then they are selected', () => {
  cy.visit('/iframe.html?id=virtuallist--with-selection-management')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length.of.at.least(3)
      expect(storyData.getItemText).to.be.a('function')
      expect(storyData.selectedItems).to.be.an('array')
    })
    .then(({ getItemText, items }) => {
      cy.findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[0].id])

      cy.findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id])
    })
})
```

æ‰€æœ‰çš„æ–­è¨€éƒ½åœ¨å…¬å¼€çš„ `selectedItems` æ•°ç»„æœ¬èº«ä¸Šã€‚æˆ‘ä»¬ä¸æ£€æŸ¥å·²æ¸²æŸ“çš„é¡¹ç›®æ˜¯å¦è¢«çªå‡ºæ˜¾ç¤ºï¼ˆçªå‡ºæ˜¾ç¤ºé¡¹ç›®çš„è´£ä»»å±äºæ•…äº‹åˆ›å»ºçš„ç»„ä»¶ï¼‰ï¼Œè€Œæ˜¯ä»…ä»…æ£€æŸ¥ VirtualList ç»„ä»¶æ˜¯å¦æ­£ç¡®å¤„ç†äº†é¡¹ç›®çš„ç‚¹å‡»ã€‚

`selectedItems` æ•°ç»„ä¸æ˜¯åœ¨å¼€å§‹æ—¶è¯»å–çš„ï¼Œè€Œæ˜¯åœ¨æ¯æ¬¡ç‚¹å‡»åè¯»å–ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å§‹ç»ˆæ£€æŸ¥æ›´æ–°åçš„æ•°ç»„ï¼Œè€Œä¸æ˜¯å¯¹åˆå§‹æ•°ç»„çš„å¼•ç”¨ï¼ˆ`selectedItems` ç”± `React.useState` è¿”å›ï¼Œå› æ­¤åœ¨æ¯æ¬¡é€‰æ‹©æ›´æ–°åéƒ½æ˜¯æ–°çš„ï¼‰ã€‚

### å¤šé¡¹é€‰æ‹©çš„æ–­è¨€

æ¥ä¸‹æ¥çš„æ­¥éª¤æ˜¯æ£€æŸ¥ VirtualList ç»„ä»¶æ˜¯å¦æ­£ç¡®å¤„ç†äº†ä½¿ç”¨ Meta é”®ã€‚åœ¨æŒ‰ä½ Meta é”®çš„æƒ…å†µä¸‹å•å‡»å¦ä¸€ä¸ªé¡¹ç›®åº”è¯¥å¯¼è‡´ä¸¤ä¸ªé¡¹ç›®è¢«é€‰ä¸­ã€‚

æˆ‘ä»¬å¦‚ä½•åœ¨ Cypress ä¸­ä¿æŒæŒ‰ä½ Meta é”®å‘¢ï¼Ÿåªéœ€ï¼š

```js
cy.get('body')
  // keeping pressed the meta (CMD) key
  .type('{meta}', { release: false })

// ...your test code...

cy.get('body')
  // releasing the meta (CMD) key
  .type('{meta}', { release: true })
```

æ·»åŠ é¡¹ç›®ç‚¹å‡»å°†å¯¼è‡´ï¼š

```js
cy.get('body')
  // keeping pressed the meta (CMD) key
  .type('{meta}', { release: false })
  .findByText(getItemText(items[2]))
  .click()
  .window()
  .its('storyData.selectedItems')
  .should('eql', [items[1].id, items[2].id])
  .get('body')
  // releasing the meta (CMD) key
  .type('{meta}', { release: true })

  cy.get('body')
    .type('{shift}', { release: false })
    .findByText(getItemText(firstRenderedItem))
    .click()
    .window()
    .its('storyData.selectedItems')
    .should('eql', expectedSelectedItemIds)
    .get('body')
    .type('{shift}', { release: true })
  })
```

è¿™æ˜¯æµ‹è¯•ç»“æœçš„å±å¹•æˆªå›¾

![å—æ§æµè§ˆå™¨ï¼Œå·¦ä¾§æ˜¯æ‰€æœ‰æ–­è¨€ç»“æœï¼Œå³ä¾§æ˜¯ Storybook æ•…äº‹å’Œé€‰å®šçš„é¡¹ç›®ã€‚](../../assets/images/cypress-storyboook/selection-test-result.png 'æµ‹è¯•çš„ç¬¬ä¸€ä¸ªç»“æœï¼šåŠ è½½çš„æ•…äº‹å’Œæ‰€æœ‰æ–­è¨€çš„ç»“æœã€‚')_æµ‹è¯•çš„ç¬¬ä¸€ä¸ªç»“æœï¼šåŠ è½½çš„æ•…äº‹å’Œæ‰€æœ‰æ–­è¨€çš„ç»“æœã€‚_

### æ»šåŠ¨å’Œé€‰æ‹©

é€šè¿‡ `scrollVirtualList` å®ç”¨ç¨‹åºè½»æ¾æ»šåŠ¨åˆ—è¡¨ï¼Œé€šè¿‡ `getFirstRenderedItemIndex` å®ŒæˆæŸ¥æ‰¾ç¬¬ä¸€ä¸ªå·²æ¸²æŸ“é¡¹ç›®ï¼Œæˆ‘ä»¬çŸ¥é“å¦‚ä½•ä¿æŒæŒ‰é”®æŒ‰ä¸‹... å› æ­¤ï¼Œæµ‹è¯•æ»šåŠ¨å¹¶å¸¦æœ‰ Shift ä¿®é¥°é”®çš„ç‚¹å‡»ï¼ˆè¿™æ„å‘³ç€é€‰æ‹©ä»å…ˆå‰ç‚¹å‡»çš„å…ƒç´ åˆ°æœ€åä¸€ä¸ªå…ƒç´ çš„æ‰€æœ‰å†…å®¹ï¼‰åº”è¯¥åªæ˜¯è®¡ç®—æ‰€æœ‰ï¼ˆé¢„è®¡çš„ï¼‰å·²é€‰æ‹©é¡¹ç›®çš„é—®é¢˜ã€‚ä¸‹é¢çš„ä»£ç æ­£æ˜¯è¿™æ ·ï¼Œç»§ç»­æŸ¥çœ‹å®Œæ•´çš„æµ‹è¯•ä»£ç ã€‚

```js
cy.findAllByTestId('VirtualList')
  // scrolls the list
  .then(scrollVirtualList)
  .then(() => {
    // identifies the first rendered item (unknown in advance)
    const firstRenderedItemIndex = getFirstRenderedItemIndex(items, getItemText)
    const firstRenderedItem = items[firstRenderedItemIndex]

    // the tests is going to click on the first rendered item
    // keeping the SHIFT key pressed. All the items up to the first
    // rendered one should be selected
    const expectedSelectedItemIds = items
      .slice(0, firstRenderedItemIndex + 1)
      .map((item) => item.id)

    cy.get('body')
      .type('{shift}', { release: false })
      .findByText(getItemText(firstRenderedItem))
      .click()
      .window()
      .its('storyData.selectedItems')
      .should('eql', expectedSelectedItemIds)
      .get('body')
      .type('{shift}', { release: true })
  })
```

æµ‹è¯•çš„å®Œæ•´ä»£ç ï¼Œå¯¹æ¯ä¸ªé”®ç›˜ä¿®é¥°é”®è¿›è¡Œæ£€æŸ¥ï¼Œå¯èƒ½ä¼šæ¯”è¾ƒå†—é•¿ä½†ç›¸å½“é‡å¤ã€‚

```js
it('When the items are clicked, then they are selected', () => {
  cy.visit('/iframe.html?id=virtuallist--with-selection-management')

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // the story must expose some variables
      expect(storyData.items).to.be.to.have.length.of.at.least(3)
      expect(storyData.getItemText).to.be.a('function')
      expect(storyData.selectedItems).to.be.an('array')
    })
    .then(({ getItemText, items }) => {
      // first item click
      cy.findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[0].id])

      // second item click
      cy.findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id])

      // third item click with Meta modifier
      cy.get('body')
        .type('{meta}', { release: false })
        .findByText(getItemText(items[2]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[1].id, items[2].id])
        .get('body')
        .type('{meta}', { release: true })

      // first item click with Shift modifier
      cy.get('body')
        .type('{shift}', { release: false })
        .findByText(getItemText(items[0]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[2].id, items[1].id, items[0].id])
        .get('body')
        .type('{shift}', { release: true })

      // second item click with Alt modifier
      cy.get('body')
        .type('{alt}', { release: false })
        .findByText(getItemText(items[1]))
        .click()
        .window()
        .its('storyData.selectedItems')
        .should('eql', [items[2].id, items[0].id])
        .get('body')
        .type('{alt}', { release: true })

      // scrolling
      cy.findAllByTestId('VirtualList')
        .then(scrollVirtualList)
        .then(() => {
          const firstRenderedItemIndex = getFirstRenderedItemIndex(items, getItemText)
          const firstRenderedItem = items[firstRenderedItemIndex]
          const expectedSelectedItemIds = items
            .slice(0, firstRenderedItemIndex + 1)
            .map((item) => item.id)

          // x-th item click with Shift modifier
          cy.get('body')
            .type('{shift}', { release: false })
            .findByText(getItemText(firstRenderedItem))
            .click()
            .window()
            .its('storyData.selectedItems')
            .should('eql', expectedSelectedItemIds)
            .get('body')
            .type('{shift}', { release: true })
        })
    })
})
```

[æµ‹è¯•ç»“æœå¦‚ä¸‹](https://www.youtube.com/watch?v=0DGHRJnWbHw)ã€‚

æ­£å¦‚æ‚¨æ‰€çœ‹åˆ°çš„ï¼Œå·¦ä¾§çš„ Command Log æ²¡æœ‰æ¸…æ¥šåœ°æ˜¾ç¤ºå‘ç”Ÿäº†ä»€ä¹ˆã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ ä¸€äº› `cy.log` è°ƒç”¨æ¥æé«˜æµ‹è¯•çš„å¯è¯»æ€§ï¼Œæˆ–è€…æ›´å¥½åœ°åˆ©ç”¨ [Filip çš„è§£å†³æ–¹æ¡ˆ](https://medium.com/slido-dev-blog/cypress-tips-3-improve-your-error-screenshots-in-cypress-b3675968a190) æ¥å……åˆ†åˆ©ç”¨ Cypress çš„æ—¥å¿—è®°å½•ã€‚

## ä¼˜åŒ–

æµ‹è¯•è¿è¡Œå¾—è¶Šå¿«è¶Šå¥½ã€‚æˆ‘çš„åŸå§‹æµ‹è¯•å¥—ä»¶èŠ±äº†å°†è¿‘ 16 ç§’æ‰èƒ½å®Œå…¨è¿è¡Œã€‚[è¿™é‡Œæ˜¯è§†é¢‘å½•åƒ](https://www.youtube.com/watch?v=EwBz844FuxE)ï¼ˆè¯·æ³¨æ„ï¼Œè¿™æ˜¯ç¬¬ä¸€ä¸ªæµ‹è¯•å¥—ä»¶ï¼Œå¸¦æœ‰ 60 FPS æµ‹è¯•ï¼‰ã€‚

æœ‰ä¸¤ä¸ªä¸»è¦çš„ä¼˜åŒ–æ–¹å‘ï¼š

- åœ¨æ•…äº‹ä¹‹é—´æ›´å¿«åœ°åˆ‡æ¢ï¼ˆè€Œä¸æ˜¯åœ¨æµ‹è¯•ä¹‹é—´é‡æ–°åŠ è½½é¡µé¢ï¼‰

- é€šè¿‡ Cypress å¼ºåˆ¶æµè§ˆå™¨æ—¶é’Ÿæ¥åŠ é€Ÿæ»šåŠ¨

### åœ¨æ•…äº‹ä¹‹é—´æ›´å¿«åœ°åˆ‡æ¢

æ„Ÿè°¢ Nicholas Boll å’Œä»–çš„ [cypress-storybook](https://github.com/NicholasBoll/cypress-storybook) æ’ä»¶ï¼Œè¯¥æ’ä»¶åˆ©ç”¨ storybook APIs åœ¨ä¸é‡æ–°åŠ è½½æ•´ä¸ªé¡µé¢çš„æƒ…å†µä¸‹åŠ è½½æ‰€éœ€çš„æ•…äº‹ã€‚

æˆªè‡³æ’°å†™æœ¬æ–‡æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- åœ¨ Storybook é…ç½®ä¸­æ·»åŠ  `import 'cypress-storybook/react'`

- åœ¨ Cypress çš„ support/index.js æ–‡ä»¶ä¸­æ·»åŠ  `import 'cypress-storybook/cypress'`

- åœ¨æµ‹è¯•æ–‡ä»¶ä¸­æ·»åŠ ä¸€ä¸ª `before` é’©å­

```js
before(() => {
  // Visit the storybook iframe page once per file
  cy.visitStorybook()
})
```

- é€šè¿‡ `cy.loadStory('VirtualList', 'With 10000 items')` åŠ è½½æ•…äº‹ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ `cy.visit`

- åœ¨è§†é¢‘ä¹‹åè§£é‡Šçš„å…¬å¼€å˜é‡ä¸Šè¿›è¡Œæ›´æ–°

è¿™æ ·åšçš„è¯ï¼Œé¡µé¢åœ¨æ¯ä¸ªæµ‹è¯•ä¸­éƒ½ä¸ä¼šé‡æ–°åŠ è½½ï¼Œæ•´ä¸ªæµ‹è¯•å¥—ä»¶èŠ‚çœäº† 3 ç§’ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™ä¸ªè§†é¢‘](https://www.youtube.com/watch?v=UJhPTJhDEFM)ã€‚

æˆ‘ä»¬ä¸ºä»€ä¹ˆéœ€è¦æ ¹æ®æ•…äº‹æ›´æ–°å˜é‡å‘¢ï¼Ÿå—¯ï¼Œå¦‚æœé¡µé¢æ²¡æœ‰é‡æ–°åŠ è½½ï¼Œæˆ‘ä»¬æ— æ³•ç¡®ä¿å…¬å¼€çš„å˜é‡æ˜¯æ‰€éœ€çš„å˜é‡ï¼Œç‰¹åˆ«æ˜¯å› ä¸ºå‡ ä¹æ¯ä¸ªæ•…äº‹éƒ½ä¼šå…¬å¼€ä¸€ä¸ª `items` å˜é‡ï¼Œä½†å˜é‡çš„å†…å®¹ä¼šæœ‰æ‰€ä¸åŒã€‚

æˆ‘ä»¬å¦‚ä½•åŒºåˆ†æ•…äº‹å…¬å¼€çš„å˜é‡å‘¢ï¼Ÿå—¯ï¼Œå…¬å¼€æ•…äº‹åç§°å°±å¯ä»¥äº†ï¼

```js
React.useEffect(() => {
  global.storyData = {
    // the name of the story is exposed too
    storyName: 'With 10000 items',
    items,
    visibleItemsAmount: Math.ceil(listHeight / itemHeight),
    getItemText,
  }
}, [items])
```

è¿™æ ·ä¸€æ¥ï¼Œæ¯ä¸ªæµ‹è¯•éƒ½å¯ä»¥æ£€æŸ¥æœŸæœ›çš„åç§°ã€‚

```js
it('When the component receives 10000 items, then only the minimum number of items are rendered', () => {
  const story = 'With 10000 items'
  cy.loadStory('VirtualList', story)

  cy.window()
    .its('storyData')
    .should((storyData) => {
      // caring about the story name
      expect(storyData.storyName).to.eq(story)

      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // ... test code...
    })
})
```

åˆ©ç”¨ [Cypress é‡è¯•æ€§](https://docs.cypress.io/guides/core-concepts/retry-ability.html) æ¥ç­‰å¾…æ‰€æœ‰æ–­è¨€é€šè¿‡ã€‚è¿™æ ·æˆ‘ä»¬ç¡®ä¿å…¬å¼€çš„å˜é‡æ˜¯æ­£ç¡®çš„ã€‚

13 ç§’ä¸æœ€åˆçš„ 16 ç§’ç›¸æ¯”å¯èƒ½å¬èµ·æ¥å¹¶ä¸æ˜¯å·¨å¤§çš„æ”¹è¿›â€¦ ä½†å®ƒæ˜¯ï¼å› ä¸ºå¦‚æœæˆ‘ä»¬åœ¨æµ‹è¯•æ²¡æœ‰æƒ¯æ€§æ»šåŠ¨çš„ç»„ä»¶ï¼ˆä¾‹å¦‚è¡¨å•ï¼‰çš„æƒ…å†µä¸‹ï¼Œæ”¶ç›Šå¯èƒ½ä¸æ˜¯ä» 16 ç§’åˆ° 13 ç§’ï¼Œè€Œæ›´æœ‰å¯èƒ½æ˜¯ä» 9 ç§’åˆ° 6 ç§’ï¼ç›¸ä¿¡æˆ‘ï¼Œ**æ°¸è¿œä¸è¦ä½ä¼°æµ‹è¯•é€Ÿåº¦**â€¦

### é€šè¿‡æ§åˆ¶æ—¶é’ŸåŠ é€Ÿæ»šåŠ¨

è§†é¢‘çªæ˜¾äº†å¤§éƒ¨åˆ†æµ‹è¯•æŒç»­æ—¶é—´éƒ½èŠ±åœ¨ç­‰å¾…æƒ¯æ€§æ»šåŠ¨å®Œæˆä¸Šã€‚è¿™å¹¶æ²¡æœ‰é”™ï¼Œä½†ä¸€äº›æµ‹è¯•è¿è¡Œå™¨å…è®¸æ‚¨æ§åˆ¶æ—¶é—´æµé€ï¼ŒCypress å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚åœ¨éœ€è¦æµ‹è¯• `setTimeout` æˆ– `setInterval` ç›¸å…³å†…å®¹æˆ–æƒ¯æ€§æ»šåŠ¨ä¹‹ç±»çš„åŠ¨ç”»æ—¶ï¼Œæ¨åŠ¨æ—¶é—´å‰è¿›æ˜¯è‡³å…³é‡è¦çš„ã€‚

[å®˜æ–¹æ–‡æ¡£](https://docs.cypress.io/api/commands/clock.html)ä¸­æœ‰å¾ˆå¤šç¤ºä¾‹ï¼Œä½†å¯¹æˆ‘ä»¬çš„éœ€æ±‚æ¥è¯´ï¼ŒåŸºæœ¬ç”¨æ³•å°±è¶³å¤Ÿäº†ã€‚æˆ‘ä»¬éœ€è¦è°ƒç”¨ `cy.clock()`ï¼Œç„¶åä½¿ç”¨ `cy.tick(<æ¯«ç§’>)` æ¨åŠ¨æ—¶é—´ã€‚

ç¬¬ä¸€ä¸ªä½¿ç”¨æ–°æ—¶é’Ÿæ§åˆ¶çš„æµ‹è¯•å·²æ³¨é‡Šã€‚

```js
it('When the component is scrolled, then the rendered items are not the first ones', () => {
  const story = 'With 10000 items'
  cy.loadStory('VirtualList', story)

  // take control of the browser clock
  cy.clock()

  cy.window()
    .its('storyData')
    .should((storyData) => {
      expect(storyData.storyName).to.eq(story)
      expect(storyData.items).to.be.to.have.length(10000)
      expect(storyData.visibleItemsAmount).to.be.greaterThan(0)
      expect(storyData.getItemText).to.be.a('function')
    })
    .then(({ visibleItemsAmount, getItemText, items }) => {
      // this test does not need the `scrollVirtualList` utility anymore
      cy.findByTestId('VirtualList')
        .trigger('wheel', {
          deltaX: 0,
          deltaY: 1000,
        })

        // ticking the clock by one second.
        // It jumps to the inertial scroll end.
        .tick(1000)

        .then(() => getFirstRenderedItemIndex(items, getItemText))
        .should('be.greaterThan', 10)
        .then((firstVisibleItemIndex) => {
          const visibleItems = items.slice(
            firstVisibleItemIndex,
            firstVisibleItemIndex + visibleItemsAmount - 1
          )
          visibleItems.forEach((item) => cy.findByText(getItemText(item)).should('be.visible'))
        })
    })
})
```

[è¿™æ˜¯æµ‹è¯•ç»“æœ](https://www.youtube.com/watch?v=m6u0H8_jQuc)ã€‚

æ­£å¦‚æ‚¨æ‰€çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬åœ¨æƒ¯æ€§æ»šåŠ¨ç»“æŸæ—¶ç«‹å³è·³è¿‡ã€‚è¯·æ³¨æ„ï¼šæ•´ä¸ªæµ‹è¯•æŒç»­æ—¶é—´è¢«å±å¹•å½•åˆ¶æ‰€è™šæ„ï¼Œæ²¡æœ‰å½•åˆ¶æ—¶æµ‹è¯•æ‰€éœ€çš„æ—¶é—´æ›´çŸ­ã€‚

è¯·è®°ä½ï¼Œå¦‚æœæ‚¨ä½¿ç”¨äº† `cy.clock`ï¼Œä½¿ç”¨ `cy.tick` æ˜¯å¼ºåˆ¶çš„ï¼å¦‚æœæ‚¨ä¸æ‰‹åŠ¨è¿›è¡Œæ—¶é—´æ¨è¿›ï¼Œåˆ—è¡¨æ ¹æœ¬ä¸ä¼šæ»šåŠ¨ï¼Œå› ä¸ºæ—¶é’Ÿè¢«å†»ç»“äº†ï¼çœ‹çœ‹å¦‚æœä¸æ¨è¿›æ—¶é’Ÿä¼šå‘ç”Ÿä»€ä¹ˆ

![åˆ—è¡¨åœç•™åœ¨åˆå§‹ä½ç½®å’Œå¤±è´¥çš„æµ‹è¯•ã€‚](../../assets/images/cypress-storyboook/clock-without-tick.png '_åˆ—è¡¨åœç•™åœ¨åˆå§‹æ»šåŠ¨æ°´å¹³ä½ç½®ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æ¨è¿›æ—¶é’Ÿã€‚')_åˆ—è¡¨åœç•™åœ¨åˆå§‹æ»šåŠ¨æ°´å¹³ä½ç½®ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æ¨è¿›æ—¶é’Ÿ._

`.should('be.greaterThan', 10)` çš„æ–­è¨€æœªæ»¡è¶³ï¼Œå› ä¸ºåˆ—è¡¨æ ¹æœ¬æ²¡æœ‰æ»šåŠ¨ã€‚

å¯¹å‡ ä¹æ‰€æœ‰æµ‹è¯•åº”ç”¨æ—¶é’Ÿæ§åˆ¶ï¼Œå…¶æŒç»­æ—¶é—´å‡å°‘äº† 9 ç§’ã€‚æœ€ç»ˆç»“æœåœ¨ä¸‹ä¸€ä¸ªè§†é¢‘ä¸­

https://www.youtube.com/watch?v=Otf3J7qFAtI

æœ€ç»ˆç»“æœï¼š**ä»æœ€åˆçš„ 16 ç§’åˆ° 9 ç§’**ï¼Œå¾ˆæ£’ï¼æµ‹è¯•è¿è¡Œå¾—è¶Šå¿«ï¼Œä½ å°±èƒ½æ›´å¥½åœ°åˆ©ç”¨å®ƒä»¬ï¼

### â€œNo previewâ€é”™è¯¯

å¦‚æœé‡åˆ°æ­¤é”™è¯¯

![Storybook çš„â€œæ— é¢„è§ˆâ€é”™è¯¯ï¼Œæ˜¾ç¤ºåœ¨ Cypress æµ‹è¯•ä¸­ã€‚](../../assets/images/cypress-storyboook/no-preview-error.png)

é‡æ–°å¯åŠ¨ Cypress åº”è¯¥è¶³å¤Ÿäº†ã€‚å¦åˆ™ï¼Œè¯·é‡æ–°å¯åŠ¨ Storybookã€‚è¿™åœ¨å‡ å°æ—¶å†…ä»…å‘ç”Ÿäº†ä¸¤æ¬¡ï¼Œæ‰€ä»¥æˆ‘è¿˜æ²¡æœ‰æ·±å…¥ç ”ç©¶å®ƒã€‚

## ç»“è®º

ç®€è€Œè¨€ä¹‹ï¼Œä¸Šè¿°åˆ—å‡ºçš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼š

- åˆ©ç”¨ [cypress-storybook](https://github.com/NicholasBoll/cypress-storybook) å…è®¸ Cypress å¿«é€Ÿåˆ‡æ¢æ•…äº‹

- æ•…äº‹åº”è¯¥å…¬å¼€ä¸€äº›å…¨å±€å˜é‡ï¼Œå…è®¸ Cypress è¿›è¡Œæ•°æ®æ–­è¨€

- å°½å¯èƒ½åŠ é€Ÿæµ‹è¯•ï¼Œä¾‹å¦‚åœ¨ç¤ºä¾‹ä¸­ï¼Œç”±äº Cypress çš„æ—¶é’Ÿæ§åˆ¶ï¼Œæƒ¯æ€§æ»šåŠ¨ä¸ä¼šç­‰å¾…

- è€ƒè™‘æ˜¯å¦è¦æµ‹è¯•æ¸²æŸ“çš„ç»„ä»¶ã€æ•…äº‹ä»£ç æˆ–ä¸¤è€…å…¼è€Œæœ‰ä¹‹

- å·¥å…·å°†æ›´åŠ é›†æˆï¼Œç»„ä»¶æµ‹è¯•æ˜¯ç›®å‰çš„çƒ­é—¨è¯é¢˜

<!-- TODO: æœ€åå†³å®šæ˜¯å¦å°†æ‰€æœ‰èµ„æºç§»åŠ¨åˆ°å…±åŒç« èŠ‚ -->

<br /><br />

_ç”± [NoriSte](https://github.com/NoriSte) åœ¨ [dev.to](https://dev.to/noriste/testing-a-virtual-list-component-with-cypress-and-storybook-3lam) å’Œ [Medium](https://medium.com/@NoriSte/testing-a-virtual-list-component-with-cypress-and-storybook-494dc2d1d26b)ä¸Šè¿›è¡Œè”åˆå‘è¡¨._



================================================
FILE: sections/tools/cypress-react-component-test.md
================================================
# [OBSOLETE] Unit Testing React components with Cypress

*This section is now marked as obsolete because it refers to a very old version of Cypress (that now fully supports component tests).*

---

_**UPDATE**: [Cypress 10 is out with Component Testing integrated with E2E testing](https://www.cypress.io/blog/2022/06/01/cypress-10-release/), please check it out and ignore all the configuration steps reported below since they are outdated!_

---

_**UPDATE**: [Cypress 7 is out with a brand-new Component Test](https://docs.cypress.io/guides/component-testing/introduction#What-is-Component-Testing) support, check it out! And other exciting news is on the way thanks to [Storybook 6.2 release](https://twitter.com/NoriSte/status/1378204109841571840)!_

---

Now that unit testing React component is possible with Cypress, this is an extending chapter of the [Testing a component with Cypress and Storybook](./cypress-and-storybook.md) one.

The goal of the previous chapter was to run some experiments in the **React Component Testing world**, a really important topic nowadays.

The motivations were pretty simple:

- you probably already have [Storybook](https://storybook.js.org/) in action in your team (if not, consider adding it!)

- you could be not familiar with testing components with [Testing Library](https://testing-library.com/) or you could be biased about JSDom or you could want to test your UI components in a real browser, not in a simulated DOM environment

- you could be familiar with [Cypress](https://www.cypress.io/) or [TestCafÃ©](https://devexpress.github.io/testcafe/) (if not, consider them for your UI tests) and you could want to use just a single tool for your tests

And the approach was simple too:

- exposing the storyâ€™ props to the testing tool, used to control the rendered component

- pick up them from Cypress/TestCafÃ©, automating user actions and asserting about the contents of the props

But there were **some caveats**â€¦

- performance: in the [chapter](https://github.com/NoriSte/all-my-contributions), I put some extra-efforts to minimize the impact of story switching slowness

- **testing and stories coupling**: since Storybook is consumed even by Cypress, stories are going to be accountable not only for sharing the design system across the team but for the component tests too

- **callback testing got tough**: checking the params and the calls of the callback props is difficult

Some of the problems of my experiment could be mitigated by [daedalius approach](./cypress-and-storybook-exposing-component-from-story.md) but the solution is not optimal yet, but thenâ€¦

## Cypress 4.5.0 has been released

On April, 28th, Cypress 4.5.0 has been released, the only released feature is the following

> Cypress now supports the execution of component tests using framework-specific adaptors when setting the experimentalComponentTesting configuration option to true. For more details see the [cypress-react-unit-test](https://github.com/bahmutov/cypress-react-unit-test) and [cypress-vue-unit-test](https://github.com/bahmutov/cypress-vue-unit-test) repos.

What does it mean? That Cypress can now directly mount a React component giving the **[cypress-react-unit-test](https://github.com/bahmutov/cypress-react-unit-test)** a new birth! Before Cypress 4.5.0 release, the plugin was pretty limited but now it has first-class support! In fact, the cypress-react-unit-test is now rock-solid and a meaningful plugin.

## Testing the VirtualList component: second episode

The component is always the same, the VirtualList, read more about it in [the previous chapter](./cypress-and-storybook.md). We need to set up both the [cypress-react-unit-test](https://github.com/bahmutov/cypress-react-unit-test) and the TypeScript conversion (the component is written in TypeScript, it is part of a [Lerna](https://github.com/lerna/lerna) monorepo, and it is compiled with Webpack). Both the steps are straightforward but if the plugin has an [installation-dedicated section in its documentation](https://github.com/bahmutov/cypress-react-unit-test#install), the TypeScript compilation could not be obvious because there are, outdated or partial, a lot of different approaches and resources.
The most concise yet effective solution is [AndrÃ© Penaâ€™s one](https://stackoverflow.com/a/60017105/700707), so all I had to do is:

- adding a _cypress/webpack.config.js_ file

```js
module.exports = {
  mode: 'development',
  devtool: false,
  resolve: {
    extensions: ['.ts', '.tsx', '.js'],
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        exclude: [/node_modules/],
        use: [
          {
            loader: 'ts-loader',
            options: {
              // skip typechecking for speed
              transpileOnly: true,
            },
          },
        ],
      },
    ],
  },
}
```

- adding a _cypress/tsconfig.json_ file

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "types": ["cypress", "cypress-wait-until"]
  }
}
```

please note that:

- the ../tsconfig.json file is the same used by the React app

- [cypress-wait-until](https://github.com/NoriSte/cypress-wait-until) is not mandatory but I use it a lot and it is one of the most installed plugins for Cypress

The above transpiling-related files, along with the following cypress.json file

```json
{
  "experimentalComponentTesting": true,
  "componentFolder": "cypress/component"
}
```

are enough to start playing with a _cypress/component/VirtualList.spec.tsx_ test! From the previous chapter, the first test was the standard rendering, the _â€œWhen the component receives 10000 items, then only the minimum number of items are renderedâ€_ test, et voilÃ :

```typescript
/// <reference types="Cypress" />
/// <reference types="cypress-wait-until" />

import React from 'react'
import { mount } from 'cypress-react-unit-test'
import '[@testing](http://twitter.com/testing)-library/cypress/add-commands'

import { VirtualList } from '../../src/atoms/VirtualList'
import { getStoryItems } from '../../stories/atoms/VirtualList/utils'

describe('VirtualList', () => {
  it('When the list receives 10000 items, then only the minimum number of them are rendered', () => {
    // Arrange
    const itemsAmount = 10000
    const itemHeight = 30
    const listHeight = 300
    const items = getStoryItems({ amount: itemsAmount })
    const visibleItemsAmount = listHeight / itemHeight

    // Act
    mount(
      <VirtualList
        items={items}
        getItemHeights={() => itemHeight}
        RenderItem={createRenderItem({ height: itemHeight })}
        listHeight={listHeight}
      />
    )

    // Assert
    const visibleItems = items.slice(0, visibleItemsAmount - 1)
    itemsShouldBeVisible(visibleItems)

    // first not-rendered item check
    cy.findByText(getItemText(items[visibleItemsAmount])).should('not.exist')
  })
})
```

Compared to the Storybook-related chapter:

- the

```js
/// <reference types="Cypress" />
/// <reference types="cypress-wait-until" />
```

at the beginning are needed to let VSCode correctly leverage TypeScript suggestions and error reporting

- we use cypress-react-unit-testâ€™ mount API to mount the component, nothing especially new if you are used to the [Testing Library APIs](https://testing-library.com/docs/react-testing-library/api)

Nothing more, the Cypress test continues the same as the Storybook-related one ğŸ˜Š

### Callback Testing

Porting all the tests from the [previous chapter](./cypress-and-storybook.md) is quite easy, what was missing is the callback testing part of the â€œselection testâ€.

Creating a _WithSelectionManagement_ wrapper component that renders the _VirtualList_ one and manages items selection is quite easy and we can pass it our stub and assert about it

```typescript
it('When the items are clicked, then they are selected', () => {
  const itemHeight = 30
  const listHeight = 300
  let testItems

  const WithSelectionManagement: React.FC<{
    testHandleSelect: (newSelectedIds: ItemId[]) => {}
  }> = (props) => {
    const { testHandleSelect } = props
    const items = getStoryItems({ amount: 10000 })

    const [selectedItems, setSelectedItems] = React.useState<(string | number)[]>([])

    const handleSelect = React.useCallback<(params: OnSelectCallbackParams<StoryItem>) => void>(
      ({ newSelectedIds }) => {
        setSelectedItems(newSelectedIds)
        testHandleSelect(newSelectedIds)
      },
      [setSelectedItems, testHandleSelect]
    )

    React.useEffect(() => {
      testItems = items
    }, [items])

    return (
      <VirtualList
        items={items}
        getItemHeights={() => itemHeight}
        listHeight={listHeight}
        RenderItem={createSelectableRenderItem({ height: itemHeight })}
        selectedItemIds={selectedItems}
        onSelect={handleSelect}
      />
    )
  }
  WithSelectionManagement.displayName = 'WithSelectionManagement'

  mount(<WithSelectionManagement testHandleSelect={cy.stub().as('handleSelect')} />)

  cy.then(() => expect(testItems).to.have.length.greaterThan(0))
  cy.wrap(testItems).then(() => {
    cy.findByText(getItemText(testItems[0])).click()
    cy.get('[@handleSelect](http://twitter.com/handleSelect)').should((stub) => {
      expect(stub).to.have.been.calledOnce
      expect(stub).to.have.been.calledWith([testItems[0].id])
    })
  })
})
```

Please refer to the full SinonJS (wrapped and used by Cypress) [Stub](https://sinonjs.org/releases/v9.0.2/stubs/)/[Spy](https://sinonjs.org/releases/v9.0.2/spies/) documentation for the full APIs.

## Conclusions

Take a look at the result in [this video](https://youtu.be/yVL-yRT5hFQ). The test lasts now less than seven seconds, without depending nor loading Storybook, leveraging first-class Cypress support.

Whatâ€™s next? The [cypress-react-unit-test](https://github.com/bahmutov/cypress-react-unit-test) plugin is quite stable and useful now, a whole new world of experiments is open and a lot of small-to-medium projects could choose to leverage Cypress as a single testing tool.

<!-- TODO: in the end, decide if you want to move all the resources to a common chapter too -->

<br /><br />

_Crossposted by [NoriSte](https://github.com/NoriSte) on [dev.to](https://dev.to/noriste/unit-testing-react-components-with-cypress-5fk2) and [Medium](https://medium.com/@NoriSte/unit-testing-react-components-with-cypress-4d4cf8cd59a0)._



================================================
FILE: sections/tools/cypress-react-component-test.zh.md
================================================
[Binary file]


================================================
FILE: sections/tools/ui-testing-problems-cypress.md
================================================
> [!NOTE]
> All the modern front-end testing tools (Playwright, Storybook, Cypress, TestCafÃ©) all have the similar functionalities and UI tools, so this same contents applies to all of them, not just Cypress.


# Some UI testing problems and the Cypress way

_Call for contributors: are you a TestCafÃ© expert? I would like to split the "problems" section from the "how Cypress solves them" one, and add a section dedicated to how TestCafÃ© solves them!_

Testing a front-end application brings some challenges that the â€œclassicâ€ tests have not: you need to **orchestrate a real browser**. Browsers are heavy applications by definition, and you need to launch them, manage them through a made on purpose library, leverage some APIs to automate the same kind of interactions the user would do, and then check if the state of front-end application (essentially what it shows) is the same you expect it to have.

This process and the involved steps are what make UI testing hard. The main problems are:

- **Everything** is asynchronous: the user-simulated interactions are asynchronous, the UI reacts asynchronously, the browser reacts asynchronously, the tool you use to orchestrate and communicate with the browser is asynchronous

```js
await page.goto(url);
await page.click('[data-test="contact-us-button"]');
await expect(page).toMatch("Contact Us");
```

And, as soon as you need something more complicated, await-ing everything leads you to deeply manage promises and recursive promises.

- **You automate user flows**: so you need to reproduce user flows, inspect automatic user flows, debug failing (and automatic, and super fast) user flows.
  Imagine being side by side with a colleague of yours that has a problem, you ask him to make something so you can inspect the issue directly with his browser DevTools but he **does not stop to click/type when you need to inspect the problem**. This is the kind of situation you need to face when something does not go as expected with a UI test. Pausing/stopping a running flow is hard and you need to relaunch the same tests a lot of times

- There are a lot of cases, in a web application, that can interfere with an elementâ€™ interactivity: its internal state, its markup properties, its visual appearance, the appearance of other elements, etc. Some of them are easy to be discovered (a â€œdisabledâ€ attribute for example) but some are not (another element with a higher z-index value). More in general, **it is hard to debug the causes**, because you need to double-check the element itself, the whole page, the tool that automates the interactions, etc.

Automating and testing a front-end application is hard but there are some tools that do not alleviate the pain and some other that give you superpowers, go on!

### Common tools

To automate and test a front-end application you need two different tools:

- A test runner: the one that takes care of executing the test itself

- A browser automation tool: something that exposes some APIs to interact with a launched on purpose browser

The tools are independent and while the test runner of your choice (Jest, for example) runs in the terminal (and gives you all the test feedback), the second one (Selenium or Puppeteer) opens a browser, executes the commands written in the test, and gives back the result.

![There is two-way communication between the terminal-based test runner and the browser automation tool.](../../assets/images/ui-testing-problems-cypress/terminal-and-browser.jpg)_There is two-way communication between the terminal-based test runner and the browser automation tool._

**The two tools are detached** and this complicates a lot of things! The actions that run in the browser are really fast! You can slow down them but you cannot pause or stop them! Or, better, I mean not interactivelyâ€¦ Because you obviously can **jump back and forth** from the code editor, change the test commenting everything after the step you want to inspect, re-launching the test and checking what happened. But this is not an ideal flow. And since the test is a little program, you know that you need to repeat this step a lot of timesâ€¦

Another problem arises while running a test in an above-described way: you typically log in to the terminal (where the test runner works) while the actions happen in the browser. **How could you connect them?** Do you add timestamp logging both in the terminal and in the browser console? Do you add a fixed-div above your front-end application that shows you the name of the running test? Connecting what happens in the browser with what you do (or log) through the terminal is hard, too.

Last but not least: when you debug the test in the terminal, you are not debugging real DOM elements, but serialized/referenced ones. There is not any kind of two-way interactivity between the terminal and the browser and so you cannot leverage the browser DevTools the way you are used to doing.

Trust me, understanding why a test is failing or why the browser does not what you expect it to do is really hard this way. But you must face that in all the three different phases of the test-consuming process:

- 1: while you initially write the test

- 2: while the test fails and you cannot send anything to production

- 3: while you need to update them because the specifications changed

Step #1 and #3 are pretty similar, #3 could be faster but #1 could be exhausting. #2 will make you hate UI testing literally if the tools you are using do not help youâ€¦

## Test runner purposes

Stop for a moment and think about what the mentioned tools try to accomplish, starting from the test runners.

Test runners are made for managing unit tests. You can use/plug them the way you want, obviously, but they are made essentially for super-fast (and parallelized) small-function invocations. They do not have browser-like DevTools but **the main problem is test timeouts**. Every test has a timeout and it is completely reasonable. Thanks to the timeout, if a test takes too long, the test runner kills it.

But what happens when you combine the test timeout with the UI-testing needs? As you know, a user flow could last really long. For a lot of reasons:

- The interaction themselves could be really long and involve tens of clicking, typing, calculations, waitings, etc.

- There is a lot of stuff that **cannot be controlled (from a duration perspective)** at all: XHR requests above all! You cannot know how much the Docker container (or the staging server) could take to respond. And if the back-end is not dockerized you have to face network slowness too

These examples show you how unpredictable could be a UI test. The solution could seem handy: incrementing the test timeout! But this is the worst solution, it does not work because:

- Test timeouts are the guillotine that could save you a lot of time when something goes wrong. If you set the timeout to one minute you are going to **wait one more minute** (60 seconds!!!!) if a single test does not work as expected. Test excessive durations are one of the main reasons developers hate tests because pipelines last forever. Nonetheless: in some particular scenarios, you cannot be sure 60 seconds are enoughâ€¦ Think about AWS lambdas wake-up time in case of slow servers, mixed with network problemsâ€¦

- What about the debugging process? Remember that when the test is killed because of the timeout, the automated browser is closed automatically...

Last but not least, remember that you need to have DOM-related assertions. In a UI test, you do not treat objects, arrays, and primitives, but you manage essentially DOM elements. Assertions like â€œI expect the element is equal toâ€¦â€ does not work, while it works for unit testing, obviously. This problem is usually solved with external plugins.

## Browser automation tool purposes

Selenium and Puppeteer aim for an easy, magics-free, UI automation experience. They are not meant to test the UI, but only to automate the user interactions. **Automating and testing overlap** in some ways but they are not the same. Both try to understand if a button is clickable and try to click it, but while the former fail, the latter tries to tell you why it failed. While the former tells you that an element is not on the page, the latter tells you that it is not on the page because the previous XHR request failed.

We were used to putting together a test runner with a browser automation tool and try to get the best of them, but suffering from what two non-integrated and different tools could not offer.

Speaking again about the test (and the app under test) debuggability: in order to slow down/debug/pause/stop/make-them-working, etc. you need to â€œsleepâ€ the tests a lot of times. It is a common practice, both because it solves problems in the short term, and sometimes because you do not have alternatives (read the [Await, don't sleep](../generic-best-practices/await-dont-sleep.md) section). Unfortunately, add some **â€œsleepâ€ steps makes the tests worse and worse**, slower and slower. As I wrote previously: test slowness is one of the most common flaws that brings developers to hate UI tests.

More: **what happens when a test fails?** What you can do to understand the problem before understanding how to fix the bug? If you are lucky enough to discover the broken test locally, your pains are limited. But if the test fails in a pipeline, how could you know what happened if you do not have a UI? Have you added some parachute automate screenshot? Is there anything that speaks better than a screenshot? Unfortunately notâ€¦

You need even to leverage third-party debugging tools (React DevTools, Vue DevTools, etc.) but their installation process onto the controlled browser is not the handiest in the world.

Last but not least: stubbing the server and asserting about the XHR requests could be considered testing implementation detailsâ€¦ But I do not think so, for two reasons:

- While speaking about blackbox testing, we refer to the (good) practice of avoiding to test how something works, concentrating only on what it does. Applied to a front-end application, it means testing just the functionalities that the app exposes to the user, not how the app exposes it (it does not matter if it works with React or Vue.js, if it saves data into localStorage or sessionStorage). The same could be applied to the client/server communication but understanding that something did not happen because of a wrong XHR request could be hard (especially when you run the automated browser in headless mode). While the help you get from asserting about the request payload, the response payload, the response status, etc., is priceless (**always care about how much a test drives you to identify the problem in case of failures**).

- You do not need to do that if you test the client/server contract with Pact or a similar tool, but do you have these kinds of tests in your workflow?

- If you are a front-end developer, you know that you cannot always work after the back-enders completed their work. But if they provide you the whole JSON responses, stubbing the back-end allows you to complete all the front-end coding jobs, leaving the last mile of work to check that everything works as expected when you integrate the front-end with the back-end. It is a matter of productivity.

## Implicit testing challenges

The above considerations create another problem: **the test code should be as simple as possible**. Tests allow you to check that everything works as expected but they are little programs after all. And so, you need to maintain them, over time. And since you need to understand them in a while (it is unfeasible if you need hours to understand why and how a test works, tests must help you, not complicate your life like bad code could do), their code should not be complicated (read the [Software tests as a documentation tool](../testing-perks/tests-as-documentation.md) section).

But, tools that are not created for a difficult task like UI testing, do not help you writing simple tests code. And your testing life gets harder, againâ€¦ Hence you are condemned to spend a lot of time debugging a failing test instead of understanding what did not work in your front-end application (assuming that something brokeâ€¦). **The result is fewer test trustability**â€¦

## Cypress to the rescue

Do not worry, I have not reported this dramatic situation for the sake of your sadness ğŸ˜‰ but just to get you aware that you do not need generic tools mixed together, you need something made on purpose! Two tools come to my mind: [Cypress](https://www.cypress.io/) and [TestCafÃ©](https://devexpress.github.io/testcafe/). Both are super valid since they have just one goal in mind: reinventing (or fixing?) the UI testing world.

I concentrate on Cypress and I compare them later.
How does Cypress solve all the above problems? First of allâ€¦

## Cypress has a UI

Yes, you start Cypress through the terminal, but you consume it [through its UI](https://docs.cypress.io/guides/core-concepts/test-runner.html)! And the UI is side-by-side with your application! Take a look at this preview

![The [Command Log UI](https://docs.cypress.io/guides/core-concepts/test-runner.html) (on the left) runs alongside your front-end application (on the right).](../../assets/images/ui-testing-problems-cypress/cypress-preview.png)_The [Command Log UI](https://docs.cypress.io/guides/core-concepts/test-runner.html) (on the left) runs alongside your front-end application (on the right)._

What does it mean? What are the main [Command Log UI](https://docs.cypress.io/guides/core-concepts/test-runner.html) features?

- **You have direct feedback for what Cypress is doing**. Every time you ask Cypress to interact with the page through its commands (cy.click , cy.type, etc.), Cypress adds a log to the Test Runner. This verbose automatic logging is really helpful both while writing your test and while debugging it. It seriously improves your productivity, both because it is automatic and because it is side-by-side with your application.

But, as I told you, the lack of retroactive debuggability is a big missing while writing UI testsâ€¦ Let me introduce youâ€¦

- **Interactive time-traveling**: not sure how the app reached a particular command or how the test failed? Would you take a look at the UI at a previous step? That is why the Command Log is interactive! You can hover the various logged steps and see how the app looks at a particular step! Or, obviously, you can pin a step and inspect the DOM, check how the app looks before/after the step, etc. This is another life-saver feature, both at the first approach (debugging a test when you do not know the testing tool could be a nightmare) and in the day-by-day testing work. It makes test inspection so handy that you completely forget how was testing without it. Watch it in action [in this video](https://www.youtube.com/watch?v=C62rYlmKLho&feature=youtu.be).

Others Command Log utilities are:

- Commandâ€™ rich log: clicking on command shows a more detailed log into the browser DevTools

- Assertion inspection: clicking on an assertion shows both the expected value and the result in the browser DevTools. You do not need to relaunch the test with more verbose logging

- If you spy XHR calls the Command Log shows a resume of the spied/stubbed calls and how many times they have been called

â€¦ and more, take a look at [its capabilities in the official Cypress docs](https://docs.cypress.io/guides/core-concepts/test-runner.html#Command-Log).

## Cypress commands

**Commands are asynchronous** by default, take a look at the next snippet

```js
cy.visit(url);
cy.click('[data-test="contact-us-button"]');
cy.contains("Contact Us").should("be.visible");
```

Do you notice any await? No and the reason is straightforward: why should you manage awaits while everything in the UI needs to be awaited? Cypress â€œwaitsâ€ for you, which means that if a DOM element is not ready when you try to interact with it, no problem! Cypress retries (by default for 4 seconds) until it can interact with the element (the user way, so only if the element is visible, is not disabled, is not covered, etc.). So you can **avoid facing the front-end intrinsic asynchronicity** at all!

The above feature has one more effect: do you remember the not-so-good test timeout? Well, forget about it! In Cypress, **tests do not have timeouts**! You avoid to guess (and continuously adapt based on the needs) test duration, every command has its own timeout! If something goes wrong, the test fails soon! And if the test goes well, it does not risk to face the test timeout guillotine!

Last but not least: DOM-related commands report **DOM-related errors** the way you need. Take a look at the following example:

![Cypress reports clearly the problem from a user/DOM perspective.](../../assets/images/ui-testing-problems-cypress/dom-error.png)_Cypress reports clearly the problem from a user/DOM perspective._

It is pretty clear the reason why the user could not type into the input element. Cypress is not the only tool that has commands that act as the user would do, but its speaking errors are quite uncommon.

## Test quality

There are a lot of common mistakes that developers do while testing. Some mistakes are negligible but some are not. Cypress enforces you avoiding some mistakes, how?

- With **AAA-quality [documentation](https://docs.cypress.io/guides/overview/why-cypress.html)**: take a look at it, it contains a lot of [best practices and anti-patterns too](https://docs.cypress.io/guides/references/best-practices.html). Everyone agrees about the quality of the documentation

- **Resetting the state**: the tests do not share the state because cookies, localStorage, etc. are all reset before every test. You obviously can create smart commands that allow you to keep the tests independent (the real problem sharing the state is the independence of the tests, take a look at an [example from one of my courses](https://noriste.github.io/reactjsday-2019-testing-course/book/sharing-authentication-state.html)) but you cannot skip the reset. It is a pro, trust me ğŸ˜‰

- Removing the possibility of restoring a test, is an assertion fails, you cannot go ahead. You do need to make your test more stable, even if sometimes it could seem hard. This is a winning choice, otherwise, you would have been allowed to write bad tests

- **With a lot of awaiting helpers**: [retry-ability](https://docs.cypress.io/guides/core-concepts/retry-ability.html#Commands-vs-assertions) and [automatic waitings](https://docs.cypress.io/api/commands/wait.html#Syntax) are life-savers that allow you to care about your app and your test, not about waiting elements and stuff. Cypress allows you to wait for DOM elements, XHR requests, page loads, and it **adapts the timeout** based on the need (an XHR request or a page-load could last longer than an input element appearing) without the need for fixed-time sleep (again, read the [Await, don't sleep](../generic-best-practices/await-dont-sleep.md) section).
  And if you need to write a custom waiting, my [cy.waitUntil plugin](https://github.com/NoriSte/cypress-wait-until) is what you need ğŸ˜‰

## Productivity

Cypress wins on another, really important, topic: productivity. Read how in the dedicated section: [Use your testing tool as your primary development tool](../generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.md).

## Debugging

I explained above why debugging a test could be a nightmare without some dedicated features. There are two kinds of failing test debugging:

- While you are writing the tests

- While the tests fail in a CI/CD pipeline

Cypress has two amazing solutions:

- [Play/pause](https://docs.cypress.io/api/commands/pause.html) functionality\*\*: both programmatically and through the UI, you can pause the test and resume it. And yes, it offers even step-by-step navigation, the same way you are used to placing a breakpoint in your code and process one step at a time. Use play/pause twice and you cannot write a test without it anymore ğŸ˜Š
  Play/pause and time-traveling offer an amazing experience and get you to forget at all about the common time-consuming debugging pains

- **Automatic screenshots and videos**: if a test fails, Cypress saves a screenshot of the last step of the test. Sometimes, the last step allows you to understand what happened (especially if you added a lot of speaking assertions, [here you can read](https://noriste.github.io/reactjsday-2019-testing-course/book/utility-in-case-of-failure.html) what you risk without good step-by-step assertions) but if a screenshot does not help you so muchâ€¦ Cypress records a video of the whole test, including the Test Runner UI. Sometimes, automatic recordings allowed me to discover CI-related issues in the easiest possible way.

## FAQ

I presented Cypress as a perfect tool, now I anticipate some common questions they ask me:

- Is Cypress free?
  Yes, free, open-source, MIT-licensed. You have to pay only if you want to leverage its [Dashboard service](https://www.cypress.io/dashboard/). In one sentence: do you want Cypress to host the videos of your tests? You have to pay, otherwise, everything is free

- Does Cypress support browser apart from Chrome-like ones?
  At the time of writing (Jan 21st, 2020), Firefox and Edge support are in beta.

- I cited TestCafÃ©, what are the main differences?

* **TestCafÃ© has not something like the Test Runner UI**, a big missing IMHO
* TestCafÃ© waits until the DOM element timeouts expire while Cypress waits up to the same timeouts. So, with TestCafÃ©, you have to manually calibrate waitings to avoid long-running tests, with Cypress you can forget about it
* TestCafÃ© has not full XHR requests inspection, it is arguable but I think it is an important feature to have highly reliable tests and useful error reporting
* **TestCafÃ© supports all the existing browsers**! This is a unique feature, Cypress does not support all the browsers and will not support mobile ones. Note that cross-browser needs are pretty overestimated but if you really need it, TestCafÃ© is the perfect tool for you

- Has Cypress flaws? Obviously! It has a [historical issue with window.fetch](https://github.com/cypress-io/cypress/issues/95#issuecomment-343214638) that forces you to use Axios or to [add a workaround](https://dev.to/matsilva/fetch-api-gotcha-in-cypress-io-and-how-to-fix-it-7ah) and you could need some extra-step for managing OAuth since your app runs in an iframe. But it is nonetheless one of the most loved tools for UI Testing

- More in general: remember that we are speaking about UI testing and Cypress is particularly good at doing it. If you just need to automate a browser (for data scraping or whatever) do not use it!

## Conclusions

As a recap, the problems and the solutions listed above are:

- Everything is asynchronous in the front-end testing, Cypress manages it almost transparently

- Step-by-step debugging: Cypressâ€™ time-traveling and play/pause functionalities are your best friends

- Cypress gives clear errors in case of failures

- Debug made handy, identifying flaws is not a nightmare thanks to the side-by-side test/app running

- Auto-screenshot and videos in case of failures

- Cypress tests have not timeouts, Cypress commands have

- Cypress allows you to work completely without a back-end the easiest possible way

- Cypress has a lot of features that improve your productivity

- Cypress is made wit one goal in mind: making UI testing easy

### References

[Mastering UI Testing - conference video](https://www.youtube.com/watch?v=RwWz4hllDtg)

<!-- TODO: in the end, decide if you want to move all the resources to a common chapter too -->



================================================
FILE: sections/tools/ui-testing-problems-cypress.zh.md
================================================
[Binary file]


================================================
FILE: sections/tools/visual-regression-testing.md
================================================
# Visual Regression Testing

<br/><br/>

### One Paragraph Explainer

A visual regression test checks what the user will see after any code changes have been executed by comparing screenshots taken before and after code changes. It is the primary way to validate regressions in CSS, but it is also useful for covering viewport & cross browser/device combinations, as well as localization. Think of Jest Snapshots, but instead of comparing the DOM as text, it is an actual screen shot comparison.

A visual regression process looks like the following:

1. Record the base snapshot (initial execution).
2. Execute the visual test again, compare to the base snapshot (subsequent executions).

   - If the new snapshot matches the base snapshot, accept.
   - Else, set the new base snapshot, or it is a visual regression defect.

The visual regression tools will find any and every pixel diffs. This may get hectic the bigger the snapshot, and as the number of snapshots increase. **The big selling point of visual snapshot services is the AI; the AI is trainable over time and we can train it to ignore petty snapshot diffs we might not care for**. Be mindful that given a snapshot name, we can train the AI to be really bad by accepting any diff. Therefore we need to take care not to thumbs up valid failures. We can reset the training by changing the snapshot name, viewport, or any part of the code.

Without the AI, we would have to manually accept or reject every petty false negative. Without built-in cross browser & cross viewport tests, our test suite would multiply combinatorially, whether local or CI. Check out the talk [Writing Tests for CSS](https://www.youtube.com/watch?v=Dl_XMd_1F6E) by Gil Tayar.

**The second selling point of services is how they can address cross viewport and browser concerns with a single test, so that we do not have to repeat the same test with different variants in CI**.

### Example: Cypress examples with Percy and Applitools

> All the code samples can be found in [this repo](https://github.com/muratkeremozcan/react-hooks-in-action-with-cypress) where we have a ReactJS application with visual tests for Percy as well as their Applitool mirrors.

We will go through two popular services, Percy and Applitools, and showcase how services can save bandwidth with the maintenance of visual snapshots. We will also cover how they can be a force multiplier when we are concerned with cross browser and viewport combinations.

Visual regression testing with services has a common flow:

- Record a default snapshot and compare that default with the new, in subsequent test executions. We have to accept the initial snapshot once.
- From then on, new snapshots matching the default get auto-accepted.

- Non-matching new snapshots prompt a notification on the web interface; we either have to reject or accept this new baseline. If we reject, it is a defect. If we accept we have a new base line and the cycle continues.

Suppose we want to verify the user's avatar.

![user-avatar](../../assets/images/visual-testing/user-avatar.png)

#### Percy flow:

- Here is [a simple test](https://github.com/muratkeremozcan/react-hooks-in-action-with-cypress/blob/main/cypress/e2e/ui-integration/user-context-retainment.spec.js) that verifies the avatar.

```javascript
// cypress/e2e/ui-integration/user-context-retainment.spec.js
describe("User selection retainment between routes", () => {
  before(() => {
    cy.stubNetwork();
    cy.visit("/");
  });

  it("Should keep the user context between routes - full snapshot", () => {
    cy.fixture("users").then((users) => {
      cy.get(".user-picker").select(users[3].name);
      cy.contains("Users").click();

      cy.wait("@userStub");
      cy.url().should("contain", "/users");
      cy.get(".item-header").contains(users[3].name);

      // the visual test - full snapshot
      cy.percySnapshot("User selection retainment between routes"); // <--
    });
  });

  it("Should keep the user context between routes - css-focused snapshot", () => {
    cy.fixture("users").then((users) => {
      cy.get(".user-picker").select(users[3].name);
      cy.contains("Users").click();

      cy.wait("@userStub");
      cy.url().should("contain", "/users");
      cy.get(".item-header").contains(users[3].name);

      // the visual test - using custom command for css selector focus // <--
      cy.get('[data-cy="user-details"]').percySnapshotElement(
        "user details with custom selector"
      );
    });
  });
});
```

In the first test we see the first one-liner taking a full screen shot. In the subsequent test we see a snapshot of the `user-details` selector. Selector focused snapshots are not natively supported in Percy, therefore [a custom command](https://github.com/muratkeremozcan/react-hooks-in-action-with-cypress/blob/main/cypress/support/commands.js#L112) `percySnapshotElement` is used.

> To actually run a visual diff, we need a Percy account and token. Visual testing only runs when hooked up to this account and executed via `cy run`. The focus is the CI. Take a look at the [Sign up section](https://dev.to/muratkeremozcan/painlessly-setup-cypress-percy-with-github-actions-in-minutes-1aki#sign-up) for elaborate details.

Once we execute the test, the initial snapshot looks like so in the Percy interface. **We introduced one-liner tests, and the test ran against 4 browsers and 2 viewports; 8 combinations we did not have to worry about in CI**. Mind that every resolution x browser consumes quota; if we were testing 2 viewports and 4 browsers, the one-liner would consume 8 credits.

![Percy initial](../../assets/images/visual-testing/percy-initial.png)

In subsequent tests if there is a visual diff (for instance if we turn off the backend and cannot render the image) we will see a visual diff indicator in the Percy Interface. Here we can also verify the diff between browsers and viewports.

![Visual diff](../../assets/images/visual-testing/percy-visual-diff.png)

At this point we can train the AI to be not very good and auto-accept the broken avatar image in the future. However, you can imagine pesky pixel diffs that we do not care about. That is where **visual regression services save bandwidth; the maintenance of visual snapshots**.

> Percy has the perk of keeping things simple. However the CI setup is the extra we have to work with. Here is a GitHub Action CI [example](https://github.com/muratkeremozcan/react-hooks-in-action-with-cypress/blob/main/.github/workflows/main.yml#L113). For all details of setting up Percy, take a look at the [blog post guide](https://dev.to/muratkeremozcan/painlessly-setup-cypress-percy-with-github-actions-in-minutes-1aki#sign-up).

### Applitools flow

Here is [the same test written with Applitools](https://github.com/muratkeremozcan/react-hooks-in-action-with-cypress/blob/main/cypress/e2e/ui-integration/user-context-retainment-applitools.spec.js).

```javascript
// Applitools version of the visual test
// cypress/e2e/ui-integration/user-context-retainment-applitools.spec.js
describe("User selection retainment between routes", () => {
  before(() => {
    // Each test should open its own Eyes for its own snapshots
    cy.eyesOpen({
      appName: "hooks-in-action",
      testName: Cypress.currentTest.title,
    });

    cy.stubNetwork();
    cy.visit("/");
  });

  it("Should keep the user context between routes - full snapshot", () => {
    cy.fixture("users").then((users) => {
      cy.get(".user-picker").select(users[3].name);
      cy.contains("Users").click();

      cy.wait("@userStub");
      cy.url().should("contain", "/users");
      cy.get(".item-header").contains(users[3].name);

      // full page test // <--
      cy.eyesCheckWindow({
        tag: "User selection retainment between routes",
        target: "window",
        matchLevel: "Layout",
      });
    });
  });

  it("Should keep the user context between routes - css focused snapshot", () => {
    cy.fixture("users").then((users) => {
      cy.get(".user-picker").select(users[3].name);
      cy.contains("Users").click();

      cy.wait("@userStub");
      cy.url().should("contain", "/users");
      cy.get(".item-header").contains(users[3].name);

      // partial page test // <--
      cy.eyesCheckWindow({
        tag: "user details with custom selector",
        target: "region",
        selector: '[data-cy="user-details"]',

        // if fully is true (default) then the snapshot is of the entire page,
        // if fully is false then snapshot is of the viewport.
        fully: false,
      });
    });
  });

  afterEach(() => {
    cy.eyesClose();
  });
});
```

We realize the additional `cy.eyesOpen` and `cy.eyesClose` commands that need to execute in the beginning and end of the test. We also see ` cy.eyesCheckWindow` is very customizable, not needing a custom command as in Percy.

> For details about setting up Applitools, and comparisons to Percy, check out [this blog post](https://dev.to/muratkeremozcan/setup-cypress-applitools-with-github-actions-a-comparison-of-applitools-vs-percy-in-a-mid-size-app-43ij).

Similar to Percy, with Applitools our test executes cross browser & viewport, and records the base snapshot.

![applitools ui](../../assets/images/visual-testing/applitools-ui.png)

When / if there is a visual diff, there is a clear indicator in the web interface.

![applitools-failure](../../assets/images/visual-testing/applitools-failure.png)

Here is a side by side comparison of the Percy vs Applitools code.

![percy-vs-applitools](../../assets/images/visual-testing/percy-vs-applitools.png)

Overall Applitools is strong on configurability while Percy is strong on simplicity. The UX is leaner and easier to use on Percy side, while on Applitools the UX is busier in comparison, but it has improved much over the years. Percy certainly has less code, not having to "open" and "close" eyes and being able to fire off the main command is a big win. For local developer experience, Applitools is the winner; being able to execute the tests with Cypress open mode vs elaborate CLI commands is huge win. Failing an actual visual diff in the test runner, vs the visual failures being only on the web UI in Percy's case, is also a win for Applitools. For CI, not having to configure any yml makes Applitools the winner there as well. Another win is for being able to take snapshots of sub-sections of the UI via selectors; this feature is built-in to Applitools while with Percy it has to be custom command that is not sure to work everywhere in the real world.

|                           | Percy                                       | Applitools                        |
| ------------------------- | ------------------------------------------- | --------------------------------- |
| **Code**                  | Less code                                   | More configurable                 |
| **UX**                    | Lean                                        | Less lean, but got better         |
| **Local**                 | Only headless                               | Also works with Cypress Open Mode |
| **CI**                    | There is yml required                       | No yml                            |
| **Config**                | Mostly On web app, viewport config is local | Local file                        |
| **Sub-section-snapshots** | Custom Command, might not work everywhere   | Built-in                          |
| **Visual diff AI**        | need more time for an opinion               | need more time for an opinion     |

Visual testing does not come for free; performing it without a service consumes continuous engineer bandwidth. **With CI, services save us costs on viewport & browser combinations**, all services we testing fulfill this need equally. **The greatest distinction between visual services is how good the AI is in helping us not worry about visual test maintenance**. We believe that the most significant decision maker would be a long term trial (4-8 weeks) of both tools in an internal app, side by side. This would help evaluate which tool has the better AI allowing for less maintenance with visual testing, which is the biggest deterrent for technically savvy teams incorporating the test strategy into their portfolio.



================================================
FILE: sections/tools/visual-regression-testing.zh.md
================================================
[Binary file]

