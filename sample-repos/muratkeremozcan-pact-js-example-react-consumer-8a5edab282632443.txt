Directory structure:
└── muratkeremozcan-pact-js-example-react-consumer/
    ├── README.md
    ├── cypress.d.ts
    ├── index.html
    ├── jest-pact.config.ts
    ├── jest.config.ts
    ├── jest.setup.ts
    ├── package.json
    ├── playwright-ct.config.ts
    ├── renovate.json
    ├── tsconfig.json
    ├── vite-env.d.ts
    ├── vite.config.ts
    ├── vitest.browser.config.ts
    ├── vitest.config.ts
    ├── vitest.headless.config.ts
    ├── .env.example
    ├── .eslintignore
    ├── .eslintrc.cjs
    ├── .lintstagedrc
    ├── .npmrc
    ├── .nvmrc
    ├── .nycrc
    ├── .prettierignore
    ├── .prettierrc
    ├── cypress/
    │   ├── tsconfig.json
    │   ├── config/
    │   │   ├── base.config.ts
    │   │   └── local.config.ts
    │   ├── e2e/
    │   │   ├── movie-crud-e2e.cy.ts
    │   │   ├── movie-crud-stubbed.cy.ts
    │   │   └── movie-routes.cy.ts
    │   ├── fixtures/
    │   │   └── example.json
    │   └── support/
    │       ├── commands.ts
    │       ├── component-index.html
    │       ├── component.tsx
    │       ├── e2e.ts
    │       ├── esbuild-preprocessor.ts
    │       ├── factories.ts
    │       ├── get-token.ts
    │       ├── plugins.ts
    │       ├── retryable-before.ts
    │       ├── tasks.ts
    │       ├── helpers/
    │       │   ├── add-movie.ts
    │       │   └── edit-movie.ts
    │       └── tasks/
    │           ├── is-ci.ts
    │           └── log.ts
    ├── playwright/
    │   ├── index.html
    │   └── index.tsx
    ├── pw/
    │   ├── config/
    │   │   ├── base.config.ts
    │   │   └── playwright-local.config.ts
    │   ├── e2e/
    │   │   ├── movie-crud-e2e-helper-version.spec.ts
    │   │   ├── movie-crud-e2e.spec.ts
    │   │   ├── movie-crud-stubbed-helper-version.spec.ts
    │   │   ├── movie-crud-stubbed.spec.ts
    │   │   ├── movie-routes-helper-version.spec.ts
    │   │   └── movie-routes.spec.ts
    │   └── support/
    │       ├── fixtures.ts
    │       ├── fixture-helpers/
    │       │   └── plain-functions.ts
    │       ├── fixtures/
    │       │   ├── api-request-fixture.ts
    │       │   ├── base-fixtures.ts
    │       │   ├── crud-helper-fixture.ts
    │       │   ├── fail-on-js-error.ts
    │       │   └── network-fixture.ts
    │       ├── ui-helpers/
    │       │   ├── add-movie.ts
    │       │   └── edit-movie.ts
    │       └── utils/
    │           ├── network.ts
    │           ├── recurse-with-expect.ts
    │           ├── run-command.ts
    │           └── spy-stub-helper.ts
    ├── scripts/
    │   ├── can-i-deploy-consumer.sh
    │   ├── env-setup.sh
    │   ├── publish-pact.sh
    │   └── record-consumer-deployment.sh
    ├── src/
    │   ├── App-routes.tsx
    │   ├── App.tsx
    │   ├── consumer-contract.pacttest.ts
    │   ├── consumer.test.ts
    │   ├── consumer.ts
    │   ├── main.tsx
    │   ├── tsconfig.json
    │   ├── vite-env.d.ts
    │   ├── components/
    │   │   ├── error-component.cy.tsx
    │   │   ├── error-component.pw.tsx
    │   │   ├── error-component.tsx
    │   │   ├── error-component.vitest.tsx
    │   │   ├── loading-message.cy.tsx
    │   │   ├── loading-message.pw.tsx
    │   │   ├── loading-message.tsx
    │   │   ├── loading-message.vitest.tsx
    │   │   ├── movie-list.cy.tsx
    │   │   ├── movie-list.pw.tsx
    │   │   ├── movie-list.tsx
    │   │   ├── movie-list.vitest.tsx
    │   │   ├── validation-error-display.cy.tsx
    │   │   ├── validation-error-display.pw.tsx
    │   │   ├── validation-error-display.tsx
    │   │   ├── validation-error-display.vitest.tsx
    │   │   ├── movie-details/
    │   │   │   ├── index.ts
    │   │   │   ├── movie-details.cy.tsx
    │   │   │   ├── movie-details.pw.tsx
    │   │   │   ├── movie-details.tsx
    │   │   │   ├── movie-details.vitest.tsx
    │   │   │   ├── movie-edit-form.cy.tsx
    │   │   │   ├── movie-edit-form.pw.tsx
    │   │   │   ├── movie-edit-form.tsx
    │   │   │   ├── movie-edit-form.vitest.tsx
    │   │   │   ├── movie-manager.cy.tsx
    │   │   │   ├── movie-manager.pw.tsx
    │   │   │   ├── movie-manager.tsx
    │   │   │   └── movie-manager.vitest.tsx
    │   │   ├── movie-form/
    │   │   │   ├── index.ts
    │   │   │   ├── movie-form.cy.tsx
    │   │   │   ├── movie-form.pw.tsx
    │   │   │   ├── movie-form.tsx
    │   │   │   ├── movie-form.vitest.tsx
    │   │   │   ├── movie-input.cy.tsx
    │   │   │   ├── movie-input.pw.tsx
    │   │   │   ├── movie-input.tsx
    │   │   │   └── movie-input.vitest.tsx
    │   │   └── movie-item/
    │   │       ├── index.ts
    │   │       ├── movie-info.cy.tsx
    │   │       ├── movie-info.pw.tsx
    │   │       ├── movie-info.tsx
    │   │       ├── movie-info.vitest.tsx
    │   │       ├── movie-item.cy.tsx
    │   │       ├── movie-item.pw.tsx
    │   │       ├── movie-item.tsx
    │   │       └── movie-item.vitest.tsx
    │   ├── hooks/
    │   │   ├── use-movie-detail.ts
    │   │   ├── use-movie-edit-form.ts
    │   │   ├── use-movie-form.ts
    │   │   └── use-movies.ts
    │   ├── provider-schema/
    │   │   ├── movie-types.ts
    │   │   └── schema.ts
    │   ├── styles/
    │   │   └── styled-components.ts
    │   └── test-utils/
    │       ├── pact-utils/
    │       │   └── helpers.ts
    │       └── vitest-utils/
    │           ├── msw-setup.ts
    │           ├── utils.tsx
    │           └── vitest.setup.ts
    └── .github/
        └── workflows/
            ├── contract-test.yml
            ├── merge-gatekeeper.yml
            ├── pr-checks.yml
            ├── test-cy-ct.yml
            ├── test-cy-e2e.yml
            ├── test-pw-ct.yml
            ├── test-pw-e2e.yml
            └── test-vitest-ct.yml

================================================
FILE: README.md
================================================
# PactJS Bi-directional Contract Testing Example

- [PactJS Bi-directional Contract Testing Example](#pactjs-bi-directional-contract-testing-example) -
  [Consumer flow for Pact Bi-directional contract testing](#consumer-flow-for-pact-bi-directional-contract-testing)
  - [Provider flow for Pact Bi-directional contract testing](#provider-flow-for-pact-bi-directional-contract-testing)
  - [Bi-directional contract testing details](#bi-directional-contract-testing-details)

This repo is a mirror of
[pact-js-consumer / Consumer service](https://github.com/muratkeremozcan/pact-js-example-consumer),
but it includes a real react UI.

Provider service: https://github.com/muratkeremozcan/pact-js-example-provider

Consumer service: https://github.com/muratkeremozcan/pact-js-example-consumer

React consumer app for bi-directional contract testing (this repo):
https://github.com/muratkeremozcan/pact-js-example-react-consumer

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8qjfdsunkrdncqrcy3sw.png)

The Axios calls to the backend (`consumer.ts`) and the pact tests
`consumer-contract.pacttest.ts` are 99% similar.

This setup is intended to compare and contrast consumer driven contract testing,
versus bi-directional (provider driven) contract testing.

The Pact related setup from
[pact-js-react-consumer](https://github.com/muratkeremozcan/pact-js-example-consumer)
still applies here - but if you have done that setup at the Pact broker already,
the only setup here is the `.env` file and repo secrets. Use the sample
`.env.example` file to create a `.env` file of your own. These values will also
have to exist in your CI secrets.

```bash
# create a free pact broker at
# https://pactflow.io/try-for-free/
PACT_BROKER_TOKEN=***********
PACT_BROKER_BASE_URL=https://yourownorg.pactflow.io
PORT=3000
```

```bash
npm install --registry https://registry.npmjs.or # specify the registry in case you are using a proprietary registry

# parallel unit, typecheck, lint, format
npm run validate

# no need to have server running for these:
npm run cy:open-ct # for cypress component test runner
npm run cy:run-ct # headless version

# runs the ui and api servers, then opens e2e runner
npm run cy:open-e2e
npm run cy:run-e2e  # headless version

npm run test # run unit tests with jest

# PW scripts
npm run pw:open-local       # open mode (local config)
npm run pw:open-local-debug # open with debug (local config)

npm run pw:run-local        # run mode (local config)
npm run pw:run-local-debug  # run with debug (local config)

npm run pw:open-ct          # open mode (component tests)
npm run pw:open-ct-debug    # open with debug (component tests)

npm run pw:run-ct           # run mode (component tests)
npm run pw:run-ct-debug     # run with debug (component tests)

npm run pw:trace            # inspect a trace.zip file
npm run pw:clear            # remove all temporary PW files
```

#### Consumer flow for Pact Bi-directional contract testing

Unlike traditional consumer driven contract testing, there is no need for a
specific order of executions between the consumer and the provider. The provider
only has to publish their OpenAPI spec and at the Pact broker, consumer tests
are verified against the OpenAPI spec.

We only verify against what's published at dev of the provider; the provider can
make any changes to their OpenAPI spec, merge to main unimpeded, and we always
have to ensure we're aligned with that at the consumer. The provider's only
responsibility is ensuring that their OpenAPI spec is correct; and they can do
schema testing for that - which in our case is done during api e2e.

```bash
npm run test:consumer # (4)
npm run publish:pact # (5)
npm run can:i:deploy:consumer #(6)
# only on main
npm run record:consumer:deployment --env=dev # (7) change the env param as needed
```

### Provider flow for Pact Bi-directional contract testing

```bash
npm run generate:openapi # (1) generates an OpenAPI doc from Zod schemas
npm run publish:pact-openapi # (2) on main, publish the open api spec to Pact Broker for BDCT
npm run record:provider:bidirectional:deployment --env=dev # (3) on main record the bi-directional provider deployment
```

On the provider side, the generation of the OpenAPI spec happens automatically
with every PR and gets committed to the repo, if there are any changes in the
spec file.

All non-pact-bi-directional related testing happens in PRs (including schema
testing during api e2e), so we are 100% confident of the commit quality.

The merge to main happens on a passing PR.

Finally, on main. we have `contract-publish-openapi.yml` , which publishes the
OpenAPI spec to Pact broker with `npm run publish:pact-openapi` and records the
bi-directional provider deployment with
`npm run record:provider:bidirectional:deployment --env=dev`.

### Bi-directional contract testing details

In CDCT, the consumer tests are executed on the provider side, which mandates
that the provider server can be served locally. This might be a blocker for
CDCT. It might also happen that we want to contract-test against a provider
outside of the org.

BDCT offers an easier alternative to CDCT. All you need is the OpenAPI spec of
the provider, and the consumer side stays the same.

Here is how it goes:

1. **Generate the OpeAPI spec at the provider**

   Automate this step using tools like `zod-to-openapi`, `swagger-jsdoc`,
   [generating OpenAPI documentation directly from TypeScript types, or generating the OpenAPI spec from e2e tests (using Optic)](https://dev.to/muratkeremozcan/automating-api-documentation-a-journey-from-typescript-to-openapi-and-schema-governence-with-optic-ge4).
   Manual spec writing is the last resort.

2. **Ensure that the spec matches the real API**

   `cypress-ajv-schema-validator`: if you already have cy e2e and you want to
   easily chain on to the existing api calls.

   Optic: lint the schema and/or run the e2e suite against the OpenAPI spec
   through the Optic proxy.

   Dredd: executes its own tests (magic!) against your openapi spec (needs your
   local server, has hooks for things like auth.)

3. **Publish the OpenAPI spec to the pact broker at the provider**.

   ```bash
      npm run publish:pact-openapi
   ```

4. **Record the provider bi-directional deployment at the provider **.

   We still have to record the provider bi-directional, similar to how we do it
   in CDCT. Otherwise the consumers will have nothing to compare against.

   ```bash
   npm run record:provider:bidirectional:deployment --env=dev
   ```

5. **Execute the consumer contract tests at the consumer**

   Execution on the Consumer side works exactly the same as classic CDCT.

   ```bash
    npm run test:consumer
    npm run publish:pact
    npm run can:i:deploy:consumer
    # only on main
    npm run record:consumer:deployment --env=dev
   ```

As you can notice, there is nothing about running the consumer tests on the
provider side ( `test:provider`), can-i-deploy checks
(`can:i:deploy:provider`),. All you do is get the OpenAPI spec right, publish it
to Pact Broker, and record the deployment.

The
[api calls](https://github.com/muratkeremozcan/pact-js-example-react-consumer/blob/main/src/consumer.ts)
are the same as the plain, non-UI app used int CDCT.

We cannot have CDCT and BDCT in the same contract relationship. Although, we can
have the provider have consumer driven contracts with some consumers and
provider driven contracts with others

```bash
Consumer        -> CDCT  -> Provider

Consumer-React  <- BDCT  <- Provider
```



================================================
FILE: cypress.d.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import {MountOptions, MountReturn} from 'cypress/react'
import type {Movie} from './src/consumer'

export {}
declare global {
  namespace Cypress {
    interface Chainable {
      /** Yields elements with a data-cy attribute that matches a specified selector.
       * ```
       * cy.getByCy('search-toggle') // where the selector is [data-cy="search-toggle"]
       * ```
       */
      getByCy(qaSelector: string, args?: any): Chainable<JQuery<HTMLElement>>

      /** Yields elements with data-cy attribute that partially matches a specified selector.
       * ```
       * cy.getByCyLike('chat-button') // where the selector is [data-cy="chat-button-start-a-new-claim"]
       * ```
       */
      getByCyLike(
        qaSelector: string,
        args?: any,
      ): Chainable<JQuery<HTMLElement>>

      /** Mounts a React node
       * @param component React Node to mount
       * @param options Additional options to pass into mount
       */
      mount(
        component: React.ReactNode,
        options?: MountOptions,
      ): Cypress.Chainable<MountReturn>

      /** Mounts the component wrapped by all the providers:
       * QueryClientProvider, ErrorBoundary, Suspense, BrowserRouter
       * @param component React Node to mount
       * @param options Additional options to pass into mount
       */
      wrappedMount(
        component: React.ReactNode,
        options?: MountOptions,
      ): Cypress.Chainable<MountReturn>

      /** Mounts a React node with the specified route and path
       * @param component React Node to mount
       * @param route Route of the component
       * @param path Path of the component
       * @param options Additional options to pass into mount */
      routeWrappedMount(
        component: React.ReactNode,
        options?: {
          route?: string
          path?: string
          cypressOptions?: MountOptions
        },
      ): Cypress.Chainable<MountReturn>

      /** https://www.npmjs.com/package/@cypress/skip-test
       * `cy.skipOn('localhost')` */
      skipOn(
        nameOrFlag: string | boolean | (() => boolean),
        cb?: () => void,
      ): Chainable<Subject>

      /** https://www.npmjs.com/package/@cypress/skip-test
       * `cy.onlyOn('localhost')` */
      onlyOn(
        nameOrFlag: string | boolean | (() => boolean),
        cb?: () => void,
      ): Chainable<Subject>

      /** Creates a movie
       * ```js
       * cy.addMovie({name: 'The Great Gatsby', year: 1925  })
       * ```
       */
      addMovie(
        body: Omit<Movie, 'id'>,
        allowedToFail?: boolean,
      ): Chainable<Response<Omit<Movie, 'id'>>>

      /**
       * If the token exists, reuses it
       * If no token is exists, gets a token
       */
      maybeGetToken(sessionName: string): Chainable<string>
    }
  }
}



================================================
FILE: index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: jest-pact.config.ts
================================================
import type {JestConfigWithTsJest} from 'ts-jest'
import {transform} from './jest.config'

export const config: JestConfigWithTsJest = {
  clearMocks: true,
  testTimeout: 20000, // Can be longer due to pact tests
  collectCoverage: false, // You can disable coverage for pact tests if needed
  moduleDirectories: ['node_modules', 'src'],
  modulePathIgnorePatterns: ['dist'],
  transform: transform(),
  testMatch: ['**/*.pacttest.ts'], // Pact test file match
  testEnvironment: 'node',
}

export default config



================================================
FILE: jest.config.ts
================================================
import type {JestConfigWithTsJest} from 'ts-jest'

export const config: JestConfigWithTsJest = {
  clearMocks: true,
  testTimeout: 10000,
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.pacttest.ts', // Exclude pacttest files
    '!**/test-helpers/**', // Exclude test helpers
    '!**/*.json',
    '!?(**)/?(*.|*-)types.ts',
    '!**/models/*',
    '!**/__snapshots__/*',
    '!**/scripts/*',
  ],
  coverageDirectory: './coverage',
  coverageReporters: [
    'clover',
    'json',
    'lcov',
    ['text', {skipFull: true}],
    'json-summary',
  ],
  coverageThreshold: {
    global: {
      statements: 0,
      branches: 0,
      lines: 0,
      functions: 0,
    },
  },
  moduleDirectories: ['node_modules', 'src'],
  modulePathIgnorePatterns: ['dist'],
  transform: transform(),
  testMatch: ['**/*.test.ts*'],
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'], // runs before each test file
  // Mock static file imports (CSS, images, etc.)
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy', // Mock CSS files
    '\\.(jpg|jpeg|png|gif|webp|svg)$': '<rootDir>/__mocks__/fileMock.ts', // Mock image files
  },
}

export default config

export function transform(): JestConfigWithTsJest['transform'] {
  return {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        tsconfig: 'src/tsconfig.json',
        diagnostics: {
          ignoreCodes: [1343], // Ignore TypeScript error code for import.meta
        },
        astTransformers: {
          before: [
            {
              path: 'ts-jest-mock-import-meta',
              options: {
                metaObjectReplacement: {
                  env: {
                    VITE_API_URL: 'http://localhost:3001',
                    VITE_PORT: '3000',
                  },
                },
              },
            },
          ],
        },
      },
    ],
  }
}



================================================
FILE: jest.setup.ts
================================================
import '@testing-library/jest-dom'

import {configure} from '@testing-library/react'

configure({testIdAttribute: 'data-cy'})



================================================
FILE: package.json
================================================
{
  "name": "quick-vitejs-react-typescript-jest",
  "version": "1.0.0",
  "license": "MIT",
  "scripts": {
    "start": "vite",
    "build": "tsc && vite build",
    "serve": "vite preview",
    "test:coverage": "npm run test --watchAll=false --collectCoverageFrom=src/**/*.ts* --collectCoverageFrom=!src/**/*.*.ts* --coverage",
    "format": "prettier --ignore-path .gitignore --write \"**/*.+(js|json|css|md|mdx|html)\"",
    "lint": "eslint . --cache-location node_modules/.cache/eslint --fix",
    "typecheck": "tsc --noEmit",
    "validate": "npm-run-all --parallel format lint typecheck test build",
    "cy:open-local": "cypress open --e2e --browser chrome --config-file cypress/config/local.config.ts",
    "cy:run-local": "cypress run --e2e --browser chrome --config-file cypress/config/local.config.ts",
    "cy:open-ct": "cypress open --component --browser chrome --config-file cypress/config/local.config.ts",
    "cy:run-ct": "cypress run --component --browser chrome --config-file cypress/config/local.config.ts",
    "cy:run-ct-fast": "npm run cy:run-ct --config video=false screenshot=false cypress/config/local.config.ts",
    "test:consumer": "rm -rf ./pacts && jest --config jest-pact.config.ts",
    "publish:pact": ". ./scripts/publish-pact.sh",
    "can:i:deploy:consumer": ". ./scripts/can-i-deploy-consumer.sh",
    "record:consumer:deployment": ". ./scripts/record-consumer-deployment.sh",
    "pw:open-local": "npx playwright test --ui -c pw/config/playwright-local.config.ts",
    "pw:open-local-debug": "PWDEBUG=1 npx playwright test --ui -c pw/config/playwright-local.config.ts",
    "pw:run-local": "npx playwright test -c pw/config/playwright-local.config.ts",
    "pw:run-local-debug": "PW_HTML_REPORT=1 npx playwright test --trace on -c pw/config/playwright-local.config.ts ; npx playwright show-report",
    "pw:open-ct": "npx playwright test -c playwright-ct.config.ts --ui",
    "pw:open-ct-debug": "PWDEBUG=1 npx playwright test --ui -c playwright-ct.config.ts",
    "pw:run-ct": "npx playwright test -c playwright-ct.config.ts",
    "pw:run-ct-debug": "PW_HTML_REPORT=1 npx playwright test --trace on -c playwright-ct.config.ts ; npx playwright show-report",
    "pw:trace": "npx playwright show-trace",
    "pw:clear": "rm -rf test-results playwright-report playwright/.cache",
    "jest": "jest",
    "test": "jest",
    "vitest:run": "vitest run --config vitest.headless.config.ts",
    "vitest:open": "vitest --config vitest.browser.config.ts"
  },
  "dependencies": {
    "@asteasolutions/zod-to-openapi": "7.3.4",
    "@tanstack/react-query": "5.87.4",
    "axios": "1.12.2",
    "jsdom": "^27.0.0",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "react-error-boundary": "6.0.0",
    "react-router-dom": "7.9.1",
    "styled-components": "6.1.19",
    "zod": "3.25.76"
  },
  "devDependencies": {
    "@bahmutov/cy-api": "2.2.8",
    "@bahmutov/cypress-esbuild-preprocessor": "2.2.6",
    "@cypress/skip-test": "2.6.1",
    "@esbuild-plugins/node-globals-polyfill": "0.2.3",
    "@esbuild-plugins/node-modules-polyfill": "0.2.2",
    "@faker-js/faker": "10.0.0",
    "@pact-foundation/pact": "15.0.1",
    "@pact-foundation/pact-cli": "16.1.2",
    "@playwright/experimental-ct-react": "^1.49.1",
    "@playwright/test": "^1.49.1",
    "@testing-library/cypress": "10.1.0",
    "@testing-library/dom": "10.4.1",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "14.6.1",
    "@types/jest": "30.0.0",
    "@types/lodash": "4.17.20",
    "@types/node": "22.18.3",
    "@types/picomatch": "^4.0.0",
    "@types/react": "19.1.13",
    "@types/react-dom": "19.1.9",
    "@types/sinon": "^17.0.3",
    "@typescript-eslint/eslint-plugin": "8.43.0",
    "@typescript-eslint/parser": "8.43.0",
    "@vitejs/plugin-react": "^5.0.0",
    "@vitest/browser": "^3.0.0",
    "cy-spok": "1.6.3",
    "cypress": "13.17.0",
    "cypress-data-session": "2.8.7",
    "cypress-map": "1.51.0",
    "dotenv": "17.2.2",
    "eslint": "8.57.1",
    "eslint-config-prettier": "10.1.8",
    "eslint-import-resolver-typescript": "4.4.4",
    "eslint-plugin-cypress": "3.6.0",
    "eslint-plugin-filenames": "1.3.2",
    "eslint-plugin-implicit-dependencies": "1.1.1",
    "eslint-plugin-import": "2.32.0",
    "eslint-plugin-no-only-tests": "3.3.0",
    "eslint-plugin-prettier": "5.5.4",
    "happy-dom": "^18.0.0",
    "husky": "4.3.8",
    "identity-obj-proxy": "3.0.0",
    "is-ci": "4.1.0",
    "jest": "29.7.0",
    "jest-environment-jsdom": "29.7.0",
    "lint-staged": "16.1.6",
    "lodash": "4.17.21",
    "msw": "^2.7.0",
    "nock": "14.0.10",
    "npm-run-all2": "8.0.4",
    "picomatch": "^4.0.2",
    "prettier": "3.6.2",
    "sinon": "^21.0.0",
    "start-server-and-test": "2.1.0",
    "ts-jest": "29.2.5",
    "ts-jest-mock-import-meta": "1.3.1",
    "ts-node": "10.9.2",
    "typescript": "5.9.2",
    "vite": "^7.0.0",
    "vitest-browser-react": "^1.0.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run typecheck && npm run test --watchAll=false && lint-staged"
    }
  }
}



================================================
FILE: playwright-ct.config.ts
================================================
import {defineConfig, devices} from '@playwright/experimental-ct-react'
import {baseConfig} from './pw/config/base.config'
import viteConfig from './vite.config'
import merge from 'lodash/merge'
import path from 'node:path'

const pwViteConfig = merge(
  {},
  viteConfig({
    mode: process.env.NODE_ENV || 'development',
    command: 'serve',
  }),
  {
    resolve: {
      alias: {
        '@support': path.resolve(__dirname, 'pw', 'support'),
        '@fixtures': path.resolve(__dirname, 'pw', 'support', 'fixtures'),
      },
    },
  },
)

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig(
  // @ts-expect-error PW ct beta is not yet vite 6 compliant
  // - revisit removing this when PW updates
  merge({}, baseConfig, {
    testDir: './src',
    testMatch: '**/*.pw.tsx',
    use: {
      ...baseConfig.use,
      ctPort: 3100,
      ctViteConfig: pwViteConfig,
      testIdAttribute: 'data-cy',
    },
    /* We only need Chrome for component tests */
    projects: [
      {
        name: 'chromium',
        use: {...devices['Desktop Chrome']},
      },
      {
        name: 'default',
        testMatch: /.*\.pw\.tsx/,
        use: {
          ...baseConfig.use,
          ctPort: 3100,
          ctViteConfig: pwViteConfig,
          ctSetup: path.resolve(__dirname, './playwright/index.tsx'),
        },
      },
    ],
  }),
)



================================================
FILE: renovate.json
================================================
{
  "extends": ["config:base"],
  "automerge": true,
  "prHourlyLimit": 2,
  "updateNotScheduled": false,
  "timezone": "America/New_York",
  "schedule": ["after 10pm and before 5am on every weekday", "every weekend"],
  "masterIssue": true,
  "labels": ["type: dependencies", "renovate"],
  "dependencyDashboardApproval": false,
  "packageRules": [
    {
      "groupName": "All Minor and Patch Updates",
      "matchUpdateTypes": ["minor", "patch"]
    },
    {
      "packageNames": [
        "husky",
        "jest",
        "ts-jest",
        "jest-environment-jsdom",
        "eslint",
        "eslint-plugin-cypress",
        "cypress"
      ],
      "enabled": false
    }
  ]
}



================================================
FILE: tsconfig.json
================================================
{
  "include": [
    "src",
    "jest.config.ts",
    "jest.setup.ts",
    "jest-pact.config.ts",
    ".eslintrc.cjs",
    "vite.config.ts",
    "vite-env.d.ts",
    "cypress",
    "cypress.d.ts",
    "pw",
    "playwright-ct.config.ts",
    "playwright/index.tsx",
    "vitest.config.ts",
    "vitest.headless.config.ts",
    "vitest.browser.config.ts"
  ],
  "exclude": [
    "node_modules",
    "coverage",
    "dist",
    "**/*.*test.ts*",
    "playwright-report"
  ],
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ESNext" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "jsx": "react-jsx" /* Specify what JSX code is generated. */,
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "ESNext" /* Specify what module code is generated. */,
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "node" /* Specify how TypeScript looks up a file from a given module specifier. */,
    "baseUrl": "./" /* Specify the base directory to resolve non-relative module names. */,
    "paths": {
      "@components/*": ["./src/components/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@styles/*": ["./src/styles/*"],
      "@cypress/*": ["./cypress/*"],
      "@pw/*": ["./pw/*"],
      "@support/*": ["./cypress/support/*"],
      "@fixtures/*": ["./cypress/fixtures/*"],
      "@provider-schema/*": ["./src/provider-schema/*"],
      "@vitest-utils/*": ["./src/test-utils/vitest-utils/*"]
    } /* Specify a set of entries that re-map imports to additional lookup locations. */,
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    "types": [
      "vite/client"
    ] /* Specify type package names to be included without being referenced in a source file. */, // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    "resolveJsonModule": true /* Enable importing .json files. */,
    // "allowImportingTsExtensions": true                /* Allow importing .ts files even when they cannot be resolved. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */,
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    "noEmit": true /* Disable emitting files from a compilation. */,
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    "allowSyntheticDefaultImports": true /* Allow 'import x from y' when a module doesn't have a default export. */,
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,
    /* Type Checking */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true /* When type checking, take into account 'null' and 'undefined'. */,
    "strictFunctionTypes": true /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */,
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true /* Interpret optional property types as written, rather than adding 'undefined'. */,
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    "noUncheckedIndexedAccess": true /* Add 'undefined' to a type when accessed using an index. */,
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    "skipDefaultLibCheck": true /* Skip type checking .d.ts files that are included with TypeScript. */,
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}



================================================
FILE: vite-env.d.ts
================================================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_PORT: string
  readonly VITE_API_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}



================================================
FILE: vite.config.ts
================================================
import {defineConfig, loadEnv} from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig(({mode}) => {
  const env = loadEnv(mode, process.cwd(), '')

  return {
    server: {
      port: Number(env.VITE_PORT),
      host: true,
    },
    plugins: [react()],
    resolve: {
      alias: {
        '@components': path.resolve(__dirname, 'src', 'components'),
        '@hooks': path.resolve(__dirname, 'src', 'hooks'),
        '@cypress': path.resolve(__dirname, 'cypress'),
        '@pw': path.resolve(__dirname, 'pw'),
        '@styles': path.resolve(__dirname, 'src', 'styles'),
        '@provider-schema': path.resolve(__dirname, 'src', 'provider-schema'),
        '@vitest-utils': path.resolve(
          __dirname,
          'src',
          'test-utils',
          'vitest-utils',
        ),
      },
    },
    // Vite 6 changes the way environment variables are handled
    define: {
      'process.env': {},
    },
  }
})



================================================
FILE: vitest.browser.config.ts
================================================
import baseConfig from './vitest.config'
import type {UserConfigExport} from 'vitest/config'
import {defineConfig} from 'vitest/config'
import merge from 'lodash/merge'

const browserConfig: UserConfigExport = {
  test: {
    browser: {
      headless: false,
      name: 'chromium',
    },
  },
}

export default defineConfig(merge({}, baseConfig, browserConfig))



================================================
FILE: vitest.config.ts
================================================
import {defineConfig, mergeConfig} from 'vitest/config'
import viteConfig from './vite.config'

const viteConfigBase = viteConfig({
  mode: process.env.NODE_ENV || 'test',
  command: 'serve',
})

const config = mergeConfig(
  viteConfigBase,
  defineConfig({
    test: {
      retry: 3,
      browser: {
        enabled: true,
        name: 'chromium',
        provider: 'playwright',
      },
      environment: 'happy-dom',
      setupFiles: ['./src/test-utils/vitest-utils/vitest.setup.ts'],
      include: ['src/**/*.vitest.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
      exclude: [
        'node_modules/**',
        'pw/**',
        'cypress/**',
        'src/consumer.test.ts',
        'src/**/*.pacttest.ts',
        'src/**/*.pw.ts',
        'src/**/*.cy.ts',
      ],
    },
  }),
)

export default config



================================================
FILE: vitest.headless.config.ts
================================================
import baseConfig from './vitest.config'
import type {UserConfigExport} from 'vitest/config'
import {defineConfig} from 'vitest/config'
import merge from 'lodash/merge'

const browserConfig: UserConfigExport = {
  test: {
    browser: {
      headless: true,
      name: 'chromium',
    },
  },
}

export default defineConfig(merge({}, baseConfig, browserConfig))



================================================
FILE: .env.example
================================================
# create a free pact broker at 
# https://pactflow.io/try-for-free/
PACT_BROKER_TOKEN=***********
PACT_BROKER_BASE_URL=https://yourownorg.pactflow.io
VITE_PORT=3000
API_PORT=3001 # only for mockoon
VITE_API_URL=http://localhost:3001 # this will change per env


================================================
FILE: .eslintignore
================================================
.eslintrc.js
wallaby.js
playwright-report
test-results


================================================
FILE: .eslintrc.cjs
================================================
module.exports = {
  env: {
    es2021: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:import/typescript',
    'plugin:import/recommended',
    'plugin:cypress/recommended',
    'plugin:prettier/recommended',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    project: ['./tsconfig.json', './src/tsconfig.json'],
  },
  plugins: ['@typescript-eslint', 'implicit-dependencies', 'no-only-tests'],
  settings: {
    'import/resolver': {
      typescript: {
        alwaysTryTypes: true, // Always try to resolve types under `@types` directory even if it's not in `package.json`
      },
    },
  },
  ignorePatterns: ['dist', 'node_modules', 'scripts', '**/*.d.ts'],
  root: true,
  rules: {
    '@typescript-eslint/consistent-type-imports': 'error',
    '@typescript-eslint/consistent-type-exports': 'error',
    '@typescript-eslint/await-thenable': 'error',
    '@typescript-eslint/no-floating-promises': 'error',
    'no-only-tests/no-only-tests': 'error',
    '@typescript-eslint/no-unused-vars': ['error', {argsIgnorePattern: '^_'}],
    complexity: ['warn', 15],
    'linebreak-style': ['error', 'unix'],
    quotes: ['error', 'single'],
    semi: ['error', 'never'],
    'import/default': 'off',
    '@typescript-eslint/no-require-imports': 'off',
    'cypress/unsafe-to-chain-command': 'off',
    'import/no-named-as-default': 'off',
  },
}



================================================
FILE: .lintstagedrc
================================================
{
  "*.+(js|jsx|ts|tsx)": [
    "eslint"
  ],
  "**/*.+(ts|js|tsx|jsx|json)": [
    "prettier --write",
    "git add"
  ]
}



================================================
FILE: .npmrc
================================================
registry=https://registry.npmjs.org


================================================
FILE: .nvmrc
================================================
22


================================================
FILE: .nycrc
================================================
{
  "excludeAfterRemap": true,
  "report-dir": "coverage-cy",
  "reporter": ["text", "json", "html"],
  "extension": [".ts", ".tsx", "js", "jsx"],
  "include": ["src/**/*.tsx", "src/**/*.ts", "src/**/*.jsx", "src/**/*.js"],
  "exclude": [
    "src/**/*.test.tsx",
    "src/**/*.cy.ts",
    "src/**/*.cy.tsx",
    "src/**/*.d.ts",
    "src/reportWebVitals.ts"
  ]
}



================================================
FILE: .prettierignore
================================================
node_modules
build
coverage
public
.docz



================================================
FILE: .prettierrc
================================================
{
  "arrowParens": "avoid",
  "bracketSpacing": false,
  "endOfLine": "lf",
  "htmlWhitespaceSensitivity": "css",
  "insertPragma": false,
  "jsxBracketSameLine": false,
  "jsxSingleQuote": false,
  "printWidth": 80,
  "proseWrap": "always",
  "quoteProps": "as-needed",
  "requirePragma": false,
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false
}



================================================
FILE: cypress/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["esnext", "dom"],
    "types": ["cypress", "node", "@testing-library/cypress"],
    "baseUrl": "./",
    "paths": {
      "@components/*": ["../src/components/*"],
      "@support/*": ["support/*"],
      "@fixtures/*": ["fixtures/*"]
    },
    "allowJs": true,
    "resolveJsonModule": true,
    "esModuleInterop": true
  },
  "include": ["**/*.ts*", "../cypress.d.ts"],
  "extends": "../tsconfig.json"
}



================================================
FILE: cypress/config/base.config.ts
================================================
import plugins from '../support/plugins'
import tasks from '../support/tasks'
import esbuildPreprocessor from '../support/esbuild-preprocessor'

export const baseConfig: Cypress.ConfigOptions = {
  projectId: 'dg3xsf',
  retries: {
    runMode: 1,
    openMode: 0,
  },
  viewportHeight: 1280,
  viewportWidth: 1280,
  e2e: {
    env: {
      // map .env to Cypress.env
      ...process.env,
    },
    setupNodeEvents(on, config) {
      esbuildPreprocessor(on)
      tasks(on)
      return plugins(on, config)
    },
    specPattern: 'cypress/e2e/**/*.{cy,spec}.{js,jsx,ts,tsx}',
  },
}



================================================
FILE: cypress/config/local.config.ts
================================================
import merge from 'lodash/merge'
import path from 'node:path'
import {baseConfig} from './base.config'
// eslint-disable-next-line import/named
import {defineConfig} from 'cypress'
import {config as dotenvConfig} from 'dotenv'
import viteConfig from '../../vite.config'

dotenvConfig({
  path: path.resolve(__dirname, '../../.env'),
})

const PORT = process.env.VITE_PORT

const cyViteConfig = merge(
  {},
  viteConfig({
    mode: process.env.NODE_ENV || 'development',
    command: 'serve',
  }),
  {
    resolve: {
      alias: {
        '@support': path.resolve(__dirname, '..', 'support'),
        '@fixtures': path.resolve(__dirname, '..', 'fixtures'),
        '@cypress': path.resolve(__dirname, '..'),
      },
    },
  },
)

const config: Cypress.ConfigOptions = {
  e2e: {
    env: {
      ENVIRONMENT: 'local',
      // map .env to Cypress.env
      ...process.env,
    },
    baseUrl: `http://localhost:${PORT}`, // Cypress.config
  },
  component: {
    experimentalJustInTimeCompile: true,
    experimentalSingleTabRunMode: true,
    specPattern: 'src/**/*.cy.{js,jsx,ts,tsx}',
    devServer: {
      framework: 'react',
      bundler: 'vite',
      viteConfig: cyViteConfig,
    },
  },
}

export default defineConfig(merge({}, baseConfig, config))



================================================
FILE: cypress/e2e/movie-crud-e2e.cy.ts
================================================
import '@cypress/skip-test/support'
import {generateMovie} from '@support/factories'
import {addMovie} from '@support/helpers/add-movie'
import {editMovie} from '@support/helpers/edit-movie'
import spok from 'cy-spok'

describe('movie crud e2e', () => {
  before(() => {
    // skip in CI, for sure the server is not running
    cy.task('isCi').then(val => cy.skipOn(val === true))
    // when local, skip if the server is not running
    cy.exec(
      `curl -s -o /dev/null -w "%{http_code}" ${Cypress.env('VITE_API_URL')}`,
      {
        failOnNonZeroExit: false,
      },
    ).then(res => cy.skipOn(res.stdout !== '200'))
  })

  beforeEach(() => {
    cy.intercept('GET', '/movies').as('getMovies')
    cy.visit('/')
    cy.wait('@getMovies')
      .its('response.statusCode')
      .should('be.within', 200, 399)
  })

  it('should add and delete a movie from movie list', () => {
    cy.log('**add a movie**')
    const {name, year, rating, director} = generateMovie()
    addMovie(name, year, rating, director)

    cy.intercept('POST', '/movies').as('addMovie')
    cy.getByCy('add-movie-button').click()
    cy.wait('@addMovie')
      .its('response')
      .should(
        spok({
          statusCode: 200,
          body: {
            data: {
              id: spok.number,
              name,
              rating,
              director,
            },
          },
        }),
      )

    cy.log('**delete a movie**')
    cy.intercept('DELETE', '/movies/*').as('deleteMovieById')
    cy.getByCy(`delete-movie-${name}`).click()
    cy.wait('@deleteMovieById')
      .its('response.body')
      .should(
        spok({
          status: 200,
          message: spok.string,
        }),
      )
    cy.getByCy(`delete-movie-${name}`).should('not.exist')
  })

  it('should update and delete a movie at movie manager', () => {
    const {name, year, rating, director} = generateMovie()
    const {
      name: editedName,
      year: editedYear,
      rating: editedRating,
      director: editedDirector,
    } = generateMovie()

    cy.addMovie({name, year, rating, director})
      .its('body.data.id')
      .then(id => {
        cy.log('**direct-nav by id**')

        cy.visit(`/movies/${id}`)

        editMovie(editedName, editedYear, editedRating, editedDirector)

        cy.log('**check on the movie list**')
        cy.getByCy('back').click()
        cy.location('pathname').should('eq', '/movies')
        cy.contains(editedName)

        cy.visit(`/movies/${id}`)
        cy.getByCy('delete-movie').click()
        cy.location('pathname').should('eq', '/movies')
        cy.contains(editedName).should('not.exist')
      })
  })
})



================================================
FILE: cypress/e2e/movie-crud-stubbed.cy.ts
================================================
import {generateMovie} from '@support/factories'
import {addMovie} from '@support/helpers/add-movie'
import {editMovie} from '@support/helpers/edit-movie'

describe('movie crud e2e stubbed', () => {
  const {name, year, rating, director} = generateMovie()
  const id = 1
  const movie = {id, name, year, rating}
  const {
    name: editedName,
    year: editedYear,
    rating: editedRating,
    director: editedDirector,
  } = generateMovie()

  it('should add a movie', () => {
    cy.intercept('GET', '**/movies', {body: []}).as('noMovies')
    cy.visit('/')
    cy.wait('@noMovies')

    addMovie(name, year, rating, director)

    cy.intercept('POST', '/movies', {body: movie}).as('addMovie')
    cy.intercept('GET', '**/movies', {body: {data: [movie]}}).as('getMovies')
    cy.getByCy('add-movie-button').click()
    cy.wait('@addMovie')
    cy.wait('@getMovies')
  })

  it('should edit a movie', () => {
    cy.intercept('GET', '**/movies', {body: {data: [movie]}}).as('getMovies')
    cy.intercept('GET', '**/movies/*', {body: {data: movie}}).as('getMovieById')

    cy.visit('/')
    cy.wait('@getMovies')

    cy.getByCy(`link-${id}`).click()
    cy.location('pathname').should('eq', `/movies/${id}`)
    cy.wait('@getMovieById').its('response.body.data').should('deep.eq', movie)

    cy.intercept('PUT', `/movies/${id}`, {
      body: {
        id: movie.id,
        name: editedName,
        year: editedYear,
        rating: editedRating,
        director: editedDirector,
      },
    }).as('updateMovieById')

    editMovie(editedName, editedYear, editedRating, editedDirector)
    cy.getByCy('movie-input-comp-text').should('have.attr', 'value', editedName)

    cy.wait('@updateMovieById')
  })

  it('should delete movie', () => {
    cy.intercept('GET', '**/movies', {body: {data: [movie]}}).as('getMovies')
    cy.visit('/')
    cy.contains('Movie List')
    cy.wait('@getMovies')

    cy.intercept('DELETE', '/movies/*', {statusCode: 200}).as('deleteMovieById')
    cy.intercept('GET', '**/movies', {body: []}).as('getMoviesEmpty')

    cy.getByCy(`delete-movie-${name}`).click()
    cy.wait('@deleteMovieById')
    cy.wait('@getMoviesEmpty')
    cy.getByCy(`delete-movie-${name}`).should('not.exist')
  })
})



================================================
FILE: cypress/e2e/movie-routes.cy.ts
================================================
import {generateMovie} from '@support/factories'
import type {Movie} from '../../src/consumer'

describe('App routes', () => {
  const movies = [
    {id: 1, ...generateMovie()},
    {id: 2, ...generateMovie()},
    {id: 3, ...generateMovie()},
  ]
  const movie = movies[0]

  beforeEach(() => {
    cy.intercept('GET', '/movies', {body: {data: movies}}).as('getMovies')
  })

  it('should redirect to /movies', () => {
    cy.visit('/')

    cy.location('pathname').should('eq', '/movies')
    cy.wait('@getMovies').its('response.body.data').should('deep.eq', movies)

    cy.getByCy('movie-list-comp').should('be.visible')
    cy.getByCy('movie-form-comp').should('be.visible')
    cy.getByCy('movie-item-comp')
      .should('be.visible')
      .and('have.length', movies.length)
  })

  it('should direct nav to by query param', () => {
    const movieName = encodeURIComponent(movie?.name as Movie['name'])

    cy.visit(`/movies?name=${movieName}`)

    cy.intercept('GET', '/movies?*', {body: movie}).as('getMovieByName')

    cy.wait('@getMovieByName').its('response.body').should('deep.eq', movie)
    cy.location('search').should('eq', `?name=${movieName}`)
  })
})



================================================
FILE: cypress/fixtures/example.json
================================================
{
  "name": "Using fixtures to represent data",
  "email": "hello@cypress.io",
  "body": "Fixtures are a great way to mock data for responses to routes"
}



================================================
FILE: cypress/support/commands.ts
================================================
// put e2e + CT common commands here
import 'cypress-map'

Cypress.Commands.add('getByCy', (selector, ...args) =>
  cy.get(`[data-cy="${selector}"]`, ...args),
)

Cypress.Commands.add('getByCyLike', (selector, ...args) =>
  cy.get(`[data-cy*=${selector}]`, ...args),
)



================================================
FILE: cypress/support/component-index.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Components App</title>
    <script>
      if (window.parent !== window) {
        window['__REACT_DEVTOOLS_GLOBAL_HOOK__'] =
          window.parent['__REACT_DEVTOOLS_GLOBAL_HOOK__']
      }
    </script>
  </head>

  <body>
    <div data-cy-root></div>
  </body>
</html>



================================================
FILE: cypress/support/component.tsx
================================================
// put CT-only commands here

import ErrorComponent from '@components/error-component'
import LoadingMessage from '@components/loading-message'
import {QueryClient, QueryClientProvider} from '@tanstack/react-query'
import type {MountOptions} from 'cypress/react18'
import {mount} from 'cypress/react18'
import {Suspense} from 'react'
import {ErrorBoundary} from 'react-error-boundary'
import {MemoryRouter, Routes, Route} from 'react-router-dom'
import './commands'

Cypress.Commands.add('mount', mount)

const wrappedMount = (WrappedComponent: React.ReactNode, options = {}) => {
  const wrapped = (
    <QueryClientProvider client={new QueryClient()}>
      <ErrorBoundary fallback={<ErrorComponent />}>
        <Suspense fallback={<LoadingMessage />}>{WrappedComponent}</Suspense>
      </ErrorBoundary>
    </QueryClientProvider>
  )
  return mount(wrapped, options)
}
Cypress.Commands.add('wrappedMount', wrappedMount)

const routeWrappedMount = (
  WrappedComponent: React.ReactNode,
  options?: {
    route?: string
    path?: string
    cypressOptions?: MountOptions
  },
) => {
  const {route = '/', path = '/', cypressOptions = {}} = options || {}
  window.history.pushState({}, 'Test Page', route)

  const routerWrappedComp = (
    <MemoryRouter initialEntries={[route]}>
      <Routes>
        <Route element={WrappedComponent} path={path} />
      </Routes>
    </MemoryRouter>
  )
  // compose into wrappedMount
  return wrappedMount(routerWrappedComp, cypressOptions)
}
Cypress.Commands.add('routeWrappedMount', routeWrappedMount)



================================================
FILE: cypress/support/e2e.ts
================================================
import type {Movie} from '../../src/consumer'
import './commands'
import './get-token'
import '@bahmutov/cy-api'

const commonHeaders = (token: string) => ({
  Authorization: token,
})

Cypress.Commands.add(
  'addMovie',
  (
    body: Omit<Movie, 'id'>,
    baseUrl = Cypress.env('VITE_API_URL'),
    allowedToFail = false,
  ) => {
    cy.log('**addMovie**')
    return cy.maybeGetToken('token-session').then(token =>
      cy.request({
        method: 'POST',
        url: `${baseUrl}/movies`,
        body,
        headers: commonHeaders(token),
        retryOnStatusCodeFailure: !allowedToFail,
        failOnStatusCode: !allowedToFail,
      }),
    )
  },
)



================================================
FILE: cypress/support/esbuild-preprocessor.ts
================================================
import createBundler from '@bahmutov/cypress-esbuild-preprocessor'
import {NodeGlobalsPolyfillPlugin} from '@esbuild-plugins/node-globals-polyfill'
import {NodeModulesPolyfillPlugin} from '@esbuild-plugins/node-modules-polyfill'

export default function tasks(on: Cypress.PluginEvents) {
  on(
    'file:preprocessor',
    createBundler({
      plugins: [
        NodeModulesPolyfillPlugin(),
        NodeGlobalsPolyfillPlugin({
          process: true,
          buffer: true,
        }),
      ],
    }),
  )
}



================================================
FILE: cypress/support/factories.ts
================================================
import {faker} from '@faker-js/faker'
import type {Movie} from '../../src/consumer'

export const generateMovie = (): Omit<Movie, 'id'> => {
  return {
    name: faker.lorem.words(3), // random 3-word title
    year: faker.date.past({years: 50}).getFullYear(), // random year within the past 50 years
    rating: faker.number.float({min: 1, max: 10, fractionDigits: 1}), // random rating between 1 and 10 with one decimal place,
    director: faker.lorem.words(3),
  }
}



================================================
FILE: cypress/support/get-token.ts
================================================
import 'cypress-data-session'
const getToken = () =>
  cy
    .request({
      method: 'POST',
      url: `${Cypress.env('VITE_API_URL')}/auth/fake-token`,
    })
    .its('body.token')

const maybeGetToken = (sessionName: string) =>
  cy.dataSession({
    name: sessionName,

    validate: () => true,

    setup: () => getToken(),

    shareAcrossSpecs: true,
  })
Cypress.Commands.add('maybeGetToken', maybeGetToken)



================================================
FILE: cypress/support/plugins.ts
================================================
const cyDataSession = require('cypress-data-session/src/plugin')

/**
 * The collection of plugins to use with Cypress
 * @param on  `on` is used to hook into various events Cypress emits
 * @param config  `config` is the resolved Cypress config
 */
export default function plugins(
  on: Cypress.PluginEvents,
  config: Cypress.PluginConfigOptions,
) {
  return {
    // add plugins here
    ...cyDataSession(on, config),
  }
}



================================================
FILE: cypress/support/retryable-before.ts
================================================
/**
 * A `before()` alternative that gets run when a failing test is retried.
 *
 * By default cypress `before()` isn't run when a test below it fails
 * and is retried. Because we use `before()` as a place to setup state
 * before running assertions inside `it()` this means we can't make use
 * of cypress retry functionality to make our suites more reliable.
 *
 * https://github.com/cypress-io/cypress/issues/19458
 * https://stackoverflow.com/questions/71285827/cypress-e2e-before-hook-not-working-on-retries
 */
export const retryableBefore = (fn: () => void) => {
  let shouldRun = true

  // we use beforeEach as cypress will run this on retry attempt
  // we just abort early if we detected that it's already run
  beforeEach(() => {
    if (!shouldRun) return
    shouldRun = false
    fn()
  })

  // When a test fails we flip the `shouldRun` flag back to true
  // so when cypress retries and runs the `beforeEach()` before
  // the test that failed, we'll run the `fn()` logic once more.
  Cypress.on('test:after:run', result => {
    if (result.state === 'failed') {
      if (result.currentRetry < result.retries) {
        shouldRun = true
      }
    }
  })
}



================================================
FILE: cypress/support/tasks.ts
================================================
import log from './tasks/log'
import isCi from './tasks/is-ci'

/**
 * The collection of tasks to use with `cy.task()`
 * @param on `on` is used to hook into various events Cypress emits
 */
export default function tasks(on: Cypress.PluginEvents) {
  on('task', {log})
  on('task', {isCi})
  // add tasks here
}



================================================
FILE: cypress/support/helpers/add-movie.ts
================================================
export const addMovie = (
  name: string,
  year: number,
  rating: number,
  director: string,
) => {
  cy.get('[placeholder="Movie name"]').type(name, {delay: 0})
  cy.get('[placeholder="Movie year"]')
    .clear()
    .type(`${year}{backspace}`, {delay: 0})
  cy.get('[placeholder="Movie rating"]').clear().type(`${rating}`, {
    delay: 0,
  })
  cy.get('[placeholder="Movie director"]').clear().type(director, {delay: 0})
}



================================================
FILE: cypress/support/helpers/edit-movie.ts
================================================
export const editMovie = (
  editedName: string,
  editedYear: number,
  editedRating: number,
  editedDirector: string,
) => {
  cy.getByCy('edit-movie').click()
  cy.getByCy('movie-edit-form-comp').within(() => {
    cy.get('[placeholder="Movie name"]').clear().type(editedName)
    cy.get('[placeholder="Movie year"]')
      .clear()
      .type(`${editedYear}{backspace}`)
    cy.get('[placeholder="Movie rating"]').clear().type(`${editedRating}`)
    cy.get('[placeholder="Movie director"]').clear().type(editedDirector)

    cy.getByCy('update-movie').click()
  })
}



================================================
FILE: cypress/support/tasks/is-ci.ts
================================================
// eslint-disable-next-line @typescript-eslint/no-var-requires
const isCI = require('is-ci')

const isCi = () => isCI

export default isCi



================================================
FILE: cypress/support/tasks/log.ts
================================================
// an example task that logs to the CLI console
// cy.task('log', 'e2e sanity passed')

const log = (x: string) => {
  console.log(x)

  return null
}

export default log



================================================
FILE: playwright/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Testing Page</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./index.tsx"></script>
  </body>
</html>



================================================
FILE: playwright/index.tsx
================================================
import {beforeMount} from '@playwright/experimental-ct-react/hooks'
import React, {Suspense} from 'react'
import {QueryClient, QueryClientProvider} from '@tanstack/react-query'
import {ErrorBoundary} from 'react-error-boundary'
import {MemoryRouter, Routes, Route} from 'react-router-dom'
import ErrorComponent from '@components/error-component'
import LoadingMessage from '@components/loading-message'

// Initialize MSW browser worker here if needed
// Initialize any global styles or theme providers here

beforeMount(async ({App, hooksConfig}) => {
  const {route = '/', path = '/'} =
    (hooksConfig as {route?: string; path?: string}) || {}

  // Push the route to history
  window.history.pushState({}, 'Test Page', route)

  return (
    <QueryClientProvider client={new QueryClient()}>
      <ErrorBoundary fallback={<ErrorComponent />}>
        <Suspense fallback={<LoadingMessage />}>
          <MemoryRouter initialEntries={[route]}>
            <Routes>
              <Route element={<App />} path={path} />
            </Routes>
          </MemoryRouter>
        </Suspense>
      </ErrorBoundary>
    </QueryClientProvider>
  )
})



================================================
FILE: pw/config/base.config.ts
================================================
import {defineConfig, devices} from '@playwright/test'

export const baseConfig = defineConfig({
  testDir: '../e2e',
  testMatch: '**/*.spec.ts',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 3 : 2,
  workers: process.env.CI ? 1 : undefined,
  reporter: process.env.CI
    ? 'html'
    : process.env.PW_HTML_REPORT
      ? [['list'], ['html']]
      : 'list',
  timeout: process.env.CI ? 15000 : 5000,
  use: {
    trace: 'retain-on-first-failure',
    testIdAttribute: 'data-cy',
  },
  projects: [
    {
      name: 'chromium',
      use: {...devices['Desktop Chrome']},
    },
  ],
})



================================================
FILE: pw/config/playwright-local.config.ts
================================================
import {baseConfig} from './base.config'
import merge from 'lodash/merge'
import {config as dotenvConfig} from 'dotenv'
import path from 'node:path'

dotenvConfig({
  path: path.resolve(__dirname, '../../.env'),
})
const PORT = process.env.VITE_PORT || 3000
const BASE_URL = `http://localhost:${PORT}`

export default merge({}, baseConfig, {
  use: {
    baseURL: BASE_URL,
  },
  webServer: {
    command: 'npm run start',
    url: BASE_URL,
    reuseExistingServer: !process.env.CI,
    stdout: 'pipe',
  },
})



================================================
FILE: pw/e2e/movie-crud-e2e-helper-version.spec.ts
================================================
import {generateMovie} from '@support/factories'
import {expect, test} from '../support/fixtures'
import {addMovie} from '../support/ui-helpers/add-movie'
import {editMovie} from '../support/ui-helpers/edit-movie'
import {runCommand} from '../support/utils/run-command'
const isCI = require('is-ci')

test.describe('movie crud e2e', () => {
  test.beforeAll(() => {
    // skip in CI, for sure the server is not running
    // when local, skip if the server is not running
    const responseCode = runCommand(
      `curl -s -o /dev/null -w "%{http_code}" ${process.env.VITE_API_URL}`,
    )
    if (isCI || responseCode !== '200') {
      test.skip()
    }
  })

  test.beforeEach(async ({page, interceptNetworkCall}) => {
    const loadGetMovies = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
    })

    await page.goto('/')
    const {status: responseStatus} = await loadGetMovies
    expect(responseStatus).toBeGreaterThanOrEqual(200)
    expect(responseStatus).toBeLessThan(400)
  })

  test('should add and delete a movie from movie list', async ({
    page,
    interceptNetworkCall,
  }) => {
    const {name, year, rating, director} = generateMovie()

    await addMovie(page, name, year, rating, director)

    const loadAddMovie = interceptNetworkCall({
      method: 'POST',
      url: '/movies',
    })

    await page.getByTestId('add-movie-button').click()

    const {responseJson: addMovieResponseBody} = await loadAddMovie
    expect(addMovieResponseBody).toEqual({
      status: 200,
      data: {
        id: expect.any(Number),
        name,
        year,
        rating,
        director,
      },
    })

    const loadDeleteMovie = interceptNetworkCall({
      method: 'DELETE',
      url: '/movies/*',
    })

    await page.getByTestId(`delete-movie-${name}`).click()

    const {responseJson: deleteMovieResponseBody} = await loadDeleteMovie
    expect(deleteMovieResponseBody).toEqual({
      status: 200,
      message: expect.any(String),
    })

    await expect(page.getByTestId(`delete-movie-${name}`)).not.toBeVisible()
  })

  test('should update and delete a movie at movie manager', async ({
    page,
    addMovie,
    apiRequest,
  }) => {
    const movie = generateMovie()
    const {
      name: editedName,
      year: editedYear,
      rating: editedRating,
      director: editedDirector,
    } = generateMovie()

    const {
      body: {token},
    } = await apiRequest<{token: string}>({
      method: 'GET',
      url: '/auth/fake-token',
      baseUrl: process.env.VITE_API_URL,
    })

    const {body: createResponse} = await addMovie(
      token,
      movie,
      process.env.VITE_API_URL,
    )

    const id = createResponse.data.id

    await page.goto(`/movies/${id}`)

    await editMovie(page, editedName, editedYear, editedRating, editedDirector)

    await page.getByTestId('back').click()
    await expect(page).toHaveURL('/movies')
    await page.getByText(editedName).waitFor()

    await page.goto(`/movies/${id}`)
    await page.getByTestId('delete-movie').click()

    await expect(page).toHaveURL('/movies')
    await page.waitForSelector(`text=${editedName}`, {state: 'detached'})
  })
})



================================================
FILE: pw/e2e/movie-crud-e2e.spec.ts
================================================
import {generateMovie} from '@support/factories'
import {expect, test} from '../support/fixtures'
import {addMovie} from '../support/ui-helpers/add-movie'
import {editMovie} from '../support/ui-helpers/edit-movie'
import {runCommand} from '../support/utils/run-command'
const isCI = require('is-ci')

test.describe('movie crud e2e', () => {
  test.beforeAll(() => {
    // skip in CI, for sure the server is not running
    // when local, skip if the server is not running
    const responseCode = runCommand(
      `curl -s -o /dev/null -w "%{http_code}" ${process.env.VITE_API_URL}`,
    )
    if (isCI || responseCode !== '200') {
      test.skip()
    }
  })

  test.beforeEach(async ({page}) => {
    const loadGetMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET',
    )

    await page.goto('/')
    const response = await loadGetMovies
    const responseStatus = response.status()
    expect(responseStatus).toBeGreaterThanOrEqual(200)
    expect(responseStatus).toBeLessThan(400)
  })

  test('should add and delete a movie from movie list', async ({page}) => {
    const {name, year, rating, director} = generateMovie()

    await addMovie(page, name, year, rating, director)

    const loadAddMovie = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'POST',
    )

    await page.getByTestId('add-movie-button').click()

    const addMovieResponse = await loadAddMovie
    const addMovieResponseBody = await addMovieResponse.json()
    expect(addMovieResponseBody).toEqual({
      status: 200,
      data: {
        id: expect.any(Number),
        name,
        year,
        rating,
        director,
      },
    })

    const loadDeleteMovie = page.waitForResponse(
      response =>
        response.url().includes('/movies/') &&
        response.request().method() === 'DELETE',
    )

    await page.getByTestId(`delete-movie-${name}`).click()

    const deleteMovieResponse = await loadDeleteMovie
    const deleteMovieResponseBody = await deleteMovieResponse.json()
    expect(deleteMovieResponseBody).toEqual({
      status: 200,
      message: expect.any(String),
    })

    await expect(page.getByTestId(`delete-movie-${name}`)).not.toBeVisible()
  })

  test('should update and delete a movie at movie manager', async ({
    page,
    addMovie,
    apiRequest,
  }) => {
    const movie = generateMovie()
    const {
      name: editedName,
      year: editedYear,
      rating: editedRating,
      director: editedDirector,
    } = generateMovie()

    const {
      body: {token},
    } = await apiRequest<{token: string}>({
      method: 'GET',
      url: '/auth/fake-token',
      baseUrl: process.env.VITE_API_URL,
    })

    const {body: createResponseBody} = await addMovie(
      token,
      movie,
      process.env.VITE_API_URL,
    )

    const id = createResponseBody.data.id

    await page.goto(`/movies/${id}`)

    await editMovie(page, editedName, editedYear, editedRating, editedDirector)

    await page.getByTestId('back').click()
    await expect(page).toHaveURL('/movies')
    await page.getByText(editedName).waitFor()

    await page.goto(`/movies/${id}`)
    await page.getByTestId('delete-movie').click()
    await expect(page).toHaveURL('/movies')
    await page.waitForSelector(`text=${editedName}`, {state: 'detached'})
  })
})



================================================
FILE: pw/e2e/movie-crud-stubbed-helper-version.spec.ts
================================================
import {generateMovie} from '../../cypress/support/factories' // Adjust path if necessary
import type {Movie} from '../../src/consumer'
import {expect, test} from '../support/fixtures'
import {addMovie} from '../support/ui-helpers/add-movie'
import {editMovie} from '../support/ui-helpers/edit-movie'

test.describe('movie crud e2e stubbed', () => {
  const {name, year, rating, director} = generateMovie()
  const id = 1
  const movie: Movie = {id, name, year, rating, director}

  const {
    name: editedName,
    year: editedYear,
    rating: editedRating,
    director: editedDirector,
  } = generateMovie()

  test('should add a movie', async ({page, interceptNetworkCall}) => {
    const loadNoMovies = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
      fulfillResponse: {
        status: 200,
        body: {data: []},
      },
    })

    await page.goto('/')
    await loadNoMovies

    await addMovie(page, name, year, rating, director)

    const loadPostOrGetMovies = interceptNetworkCall({
      url: '/movies',
      handler: async (route, request) => {
        if (request.method() === 'POST') {
          return route.fulfill({
            status: 200,
            body: JSON.stringify(movie),
            headers: {'Content-Type': 'application/json'},
          })
        } else if (request.method() === 'GET') {
          return route.fulfill({
            status: 200,
            body: JSON.stringify({data: [movie]}),
            headers: {'Content-Type': 'application/json'},
          })
        } else {
          return route.continue()
        }
      },
    })

    await page.getByTestId('add-movie-button').click()
    await loadPostOrGetMovies
    await loadPostOrGetMovies
  })

  test('should edit movie', async ({page, interceptNetworkCall}) => {
    const loadGetMovies = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
      fulfillResponse: {
        status: 200,
        body: {data: [movie]},
      },
    })

    const loadGetMovieById = interceptNetworkCall({
      method: 'GET',
      url: '/movies/*',
      fulfillResponse: {
        status: 200,
        body: {data: movie},
      },
    })

    await page.goto('/')
    await loadGetMovies

    await page.getByTestId(`link-${id}`).click()
    await expect(page).toHaveURL(`/movies/${id}`)
    const {
      responseJson: {data: getMovieByIdData},
    } = (await loadGetMovieById) as {responseJson: {data: Movie}}
    expect(getMovieByIdData).toEqual(movie)

    const loadUpdateMovieById = interceptNetworkCall({
      method: 'PUT',
      url: '/movies/*',
      fulfillResponse: {
        status: 200,
        body: {
          data: {
            id: movie.id,
            name: editedName,
            year: editedYear,
            rating: editedRating,
            director: editedDirector,
          },
        },
      },
    })

    await editMovie(page, editedName, editedYear, editedRating, editedDirector)
    const {responseJson: data} = await loadUpdateMovieById
    expect((data as {data: Movie}).data.name).toBe(editedName)
  })

  test('should delete a movie', async ({page, interceptNetworkCall}) => {
    const loadGetMovies = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
      fulfillResponse: {
        status: 200,
        body: {data: [movie]},
      },
    })

    await page.goto('/')
    await loadGetMovies

    const loadDeleteMovie = interceptNetworkCall({
      method: 'DELETE',
      url: '/movies/*',
      fulfillResponse: {
        status: 200,
      },
    })

    const loadGetMoviesAfterDelete = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
      fulfillResponse: {
        status: 200,
        body: {data: []},
      },
    })

    await page.getByTestId(`delete-movie-${name}`).click()
    await loadDeleteMovie
    await loadGetMoviesAfterDelete

    await expect(page.getByTestId(`delete-movie-${name}`)).not.toBeVisible()
  })
})



================================================
FILE: pw/e2e/movie-crud-stubbed.spec.ts
================================================
import {generateMovie} from '../../cypress/support/factories' // Adjust path if necessary
import type {Movie} from '../../src/consumer'
import {expect, test} from '../support/fixtures'
import {addMovie} from '../support/ui-helpers/add-movie'
import {editMovie} from '../support/ui-helpers/edit-movie'

test.describe('movie crud e2e stubbed', () => {
  // Generate initial movie data
  const {name, year, rating, director} = generateMovie()
  const id = 1
  const movie: Movie = {id, name, year, rating, director}

  // Generate edited movie data
  const {
    name: editedName,
    year: editedYear,
    rating: editedRating,
    director: editedDirector,
  } = generateMovie()

  test('should add a movie', async ({page}) => {
    await page.route('**/movies', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: []}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadNoMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.goto('/')
    await loadNoMovies

    await addMovie(page, name, year, rating, director)

    await page.route('**/movies', route => {
      if (route.request().method() === 'POST') {
        return route.fulfill({
          status: 200,
          body: JSON.stringify(movie),
          headers: {'Content-Type': 'application/json'},
        })
      } else if (route.request().method() === 'GET') {
        return route.fulfill({
          status: 200,
          body: JSON.stringify({data: [movie]}),
          headers: {'Content-Type': 'application/json'},
        })
      } else {
        return route.continue()
      }
    })

    const loadAddMovie = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'POST' &&
        response.status() === 200,
    )
    const loadGetMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.getByTestId('add-movie-button').click()
    await loadAddMovie
    await loadGetMovies
  })

  test('should edit a movie', async ({page}) => {
    await page.route('**/movies', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: [movie]}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadGetMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.route('**/movies/*', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: movie}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadGetMovieById = page.waitForResponse(
      response =>
        response.url().includes(`/movies/${id}`) &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.goto('/')
    await loadGetMovies

    await page.getByTestId(`link-${id}`).click()
    await expect(page).toHaveURL(`/movies/${id}`)
    const getMovieByIdResponse = await loadGetMovieById

    const {data} = await getMovieByIdResponse.json()
    expect(data).toEqual(movie)

    await page.route(`**/movies/${id}`, async route => {
      if (route.request().method() === 'PUT') {
        const updatedMovie: Movie = {
          id: movie.id,
          name: editedName,
          year: editedYear,
          rating: editedRating,
          director: editedDirector,
        }
        await route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify(updatedMovie),
        })
      } else {
        await route.continue()
      }
    })

    const loadUpdateMovieById = page.waitForResponse(
      response =>
        response.url().includes(`/movies/${id}`) &&
        response.request().method() === 'PUT' &&
        response.status() === 200,
    )

    await editMovie(page, editedName, editedYear, editedRating, editedDirector)
    const updateMovieByIdRes = await loadUpdateMovieById
    const updatedMovieData = await updateMovieByIdRes.json()
    expect(updatedMovieData.name).toBe(editedName)
  })

  test('should delete a movie', async ({page}) => {
    await page.route('**/movies', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: [movie]}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadGetMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.goto('/')
    await loadGetMovies

    await page.route(`**/movies/${id}`, async route => {
      if (route.request().method() === 'DELETE') {
        await route.fulfill({
          status: 200,
        })
      } else {
        await route.continue()
      }
    })
    const loadDeleteMovie = page.waitForResponse(
      response =>
        response.url().includes(`/movies/${id}`) &&
        response.request().method() === 'DELETE' &&
        response.status() === 200,
    )

    await page.route('**/movies', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: []}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadGetMoviesAfterDelete = page.waitForResponse(
      response =>
        response.url().includes('/movies') &&
        response.request().method() === 'GET' &&
        response.status() === 200,
    )

    await page.getByTestId(`delete-movie-${name}`).click()
    await loadDeleteMovie
    await loadGetMoviesAfterDelete

    await expect(page.getByTestId(`delete-movie-${name}`)).not.toBeVisible()
  })
})



================================================
FILE: pw/e2e/movie-routes-helper-version.spec.ts
================================================
import {test, expect} from '../support/fixtures'
import {generateMovie} from '../../cypress/support/factories'
import type {InterceptNetworkCall} from '../support/utils/network'
import type {Movie} from 'src/consumer'

test.describe('App routes', () => {
  const movies = [
    {id: 1, ...generateMovie()},
    {id: 2, ...generateMovie()},
    {id: 3, ...generateMovie()},
  ]
  const movie = movies[0]
  let loadGetMovies: InterceptNetworkCall

  test.beforeEach(({interceptNetworkCall}) => {
    loadGetMovies = interceptNetworkCall({
      method: 'GET',
      url: '/movies',
      fulfillResponse: {
        status: 200,
        body: {data: movies},
      },
    })
  })

  test('should redirect to /movies', async ({page}) => {
    await page.goto('/')

    await expect(page).toHaveURL('/movies')
    const {
      responseJson: {data: moviesResponse},
    } = (await loadGetMovies) as {responseJson: {data: typeof movies}}
    expect(moviesResponse).toEqual(movies)

    await expect(page.getByTestId('movie-list-comp')).toBeVisible()
    await expect(page.getByTestId('movie-form-comp')).toBeVisible()
    await expect(page.getByTestId('movie-item-comp')).toHaveCount(movies.length)
    // with PW you have to use for await of, since you have to await the expect
    const movieItemComps = page.getByTestId('movie-item-comp').all()
    const items = await movieItemComps
    for (const item of items) {
      await expect(item).toBeVisible()
    }
  })

  test('should direct nav to by query param', async ({
    page,
    interceptNetworkCall,
  }) => {
    const movieName = encodeURIComponent(movie?.name as Movie['name'])

    const loadGetMovies2 = interceptNetworkCall({
      method: 'GET',
      url: '/movies?*',
      fulfillResponse: {
        status: 200,
        body: movie,
      },
    })

    await page.goto(`/movies?name=${movieName}`)

    const {responseJson: resBody} = await loadGetMovies2
    expect(resBody).toEqual(movie)

    await expect(page).toHaveURL(`/movies?name=${movieName}`)
  })
})



================================================
FILE: pw/e2e/movie-routes.spec.ts
================================================
import {test, expect} from '../support/fixtures'
import {generateMovie} from '../../cypress/support/factories'
import type {Response} from '@playwright/test'
import type {Movie} from '../../src/consumer'

test.describe('App routes', () => {
  const movies = [
    {id: 1, ...generateMovie()},
    {id: 2, ...generateMovie()},
    {id: 3, ...generateMovie()},
  ]
  const movie = movies[0]
  let loadGetMovies: Promise<Response>

  test.beforeEach(async ({page}) => {
    await page.route('**/movies', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify({data: movies}),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    loadGetMovies = page.waitForResponse(
      response =>
        response.url().includes('/movies') && response.status() === 200,
    )
  })

  test('should redirect to /movies', async ({page}) => {
    await page.goto('/')

    await expect(page).toHaveURL('/movies')
    const getMovies = await loadGetMovies
    const {data} = await getMovies.json()
    expect(data).toEqual(movies)

    await expect(page.getByTestId('movie-list-comp')).toBeVisible()
    await expect(page.getByTestId('movie-form-comp')).toBeVisible()
    await expect(page.getByTestId('movie-item-comp')).toHaveCount(movies.length)
    // with PW you have to use for await of, since you have to await the expect
    const movieItemComps = page.getByTestId('movie-item-comp').all()
    const items = await movieItemComps
    for (const item of items) {
      await expect(item).toBeVisible()
    }
  })

  test('should direct nav to by query param', async ({page}) => {
    const movieName = encodeURIComponent(movie?.name as Movie['name'])

    await page.route('**/movies?*', route =>
      route.fulfill({
        status: 200,
        body: JSON.stringify(movie),
        headers: {'Content-Type': 'application/json'},
      }),
    )
    const loadGetMovies2 = page.waitForResponse(
      response =>
        response.url().includes('/movies?') && response.status() === 200,
    )

    await page.goto(`/movies?name=${movieName}`)

    const getMovie = await loadGetMovies2
    const resBody = await getMovie.json()
    expect(resBody).toEqual(movie)

    await expect(page).toHaveURL(`/movies?name=${movieName}`)
  })
})



================================================
FILE: pw/support/fixtures.ts
================================================
import {test as base, mergeTests} from '@playwright/test'
import {test as baseFixtures} from './fixtures/base-fixtures'
import {test as apiRequestFixture} from './fixtures/api-request-fixture'
import {test as crudHelperFixtures} from './fixtures/crud-helper-fixture'
import {test as networkFixture} from './fixtures/network-fixture'
import {test as failOnJSError} from './fixtures/fail-on-js-error'

// Merge the fixtures
const test = mergeTests(
  baseFixtures,
  apiRequestFixture,
  crudHelperFixtures,
  networkFixture,
  failOnJSError,
) // Add new fixtures as arguments

const expect = base.expect
export {test, expect}



================================================
FILE: pw/support/fixture-helpers/plain-functions.ts
================================================
import type {APIRequestContext, APIResponse} from '@playwright/test'

/**
 * Simplified helper for making API requests and returning the status and JSON body.
 * This helper automatically performs the request based on the provided method, URL, body, and headers.
 *
 * @param {Object} params - The parameters for the request.
 * @param {APIRequestContext} params.request - The Playwright request object, used to make the HTTP request.
 * @param {string} params.method - The HTTP method to use (POST, GET, PUT, DELETE).
 * @param {string} params.url - The URL to send the request to.
 * @param {string} [params.baseUrl] - The base URL to prepend to the request URL.
 * @param {Record<string, unknown> | null} [params.body=null] - The body to send with the request (for POST and PUT requests).
 * @param {Record<string, string> | undefined} [params.headers=undefined] - The headers to include with the request.
 * @returns {Promise<{ status: number; body: unknown }>} - An object containing the status code and the parsed response body.
 *    - `status`: The HTTP status code returned by the server.
 *    - `body`: The parsed JSON response body from the server.
 */
export async function apiRequest({
  request,
  method,
  url,
  baseUrl,
  body = null,
  headers,
}: {
  request: APIRequestContext
  method: 'POST' | 'GET' | 'PUT' | 'DELETE'
  url: string
  baseUrl?: string
  body?: Record<string, unknown> | null
  headers?: Record<string, string>
}): Promise<{status: number; body: unknown}> {
  let response: APIResponse

  // Common request options
  const options: {
    data?: Record<string, unknown> | null
    headers?: Record<string, string>
  } = {}
  if (body) options.data = body
  if (headers) options.headers = headers

  // Construct full URL
  const fullUrl = baseUrl ? `${baseUrl}${url}` : url

  // Make the request based on the method
  switch (method.toUpperCase()) {
    case 'POST':
      response = await request.post(fullUrl, options)
      break
    case 'GET':
      response = await request.get(fullUrl, {headers})
      break
    case 'PUT':
      response = await request.put(fullUrl, options)
      break
    case 'DELETE':
      response = await request.delete(fullUrl, {headers})
      break
    default:
      throw new Error(`Unsupported HTTP method: ${method}`)
  }

  const status = response.status()

  // Determine how to parse the response body
  let bodyData: unknown = null
  const contentType = response.headers()['content-type'] || ''

  try {
    if (contentType.includes('application/json')) {
      bodyData = await response.json()
    } else if (contentType.includes('text/')) {
      bodyData = await response.text()
    }
  } catch (err) {
    console.warn(`Failed to parse response body for status ${status}: ${err}`)
  }

  return {status, body: bodyData}
}



================================================
FILE: pw/support/fixtures/api-request-fixture.ts
================================================
import {test as base} from '@playwright/test'
import {apiRequest as apiRequestOriginal} from '../fixture-helpers/plain-functions'

export type ApiRequestParams = {
  method: 'POST' | 'GET' | 'PUT' | 'DELETE'
  url: string
  baseUrl?: string
  body?: Record<string, unknown> | null
  headers?: Record<string, string>
}

export type ApiRequestResponse<T = unknown> = {
  status: number
  body: T
}

// define the function signature as a type
type ApiRequestFn = <T = unknown>(
  params: ApiRequestParams,
) => Promise<ApiRequestResponse<T>>

// grouping them all together
type ApiRequestMethods = {
  apiRequest: ApiRequestFn
}

export const test = base.extend<ApiRequestMethods>({
  apiRequest: async ({request}, use) => {
    const apiRequestFn: ApiRequestFn = async <T = unknown>({
      method,
      url,
      baseUrl,
      body = null,
      headers,
    }: ApiRequestParams): Promise<ApiRequestResponse<T>> => {
      const response = await apiRequestOriginal({
        request,
        method,
        url,
        baseUrl,
        body,
        headers,
      })

      return {
        status: response.status,
        body: response.body as T,
      }
    }

    await use(apiRequestFn)
  },
})



================================================
FILE: pw/support/fixtures/base-fixtures.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import {test as base} from '@playwright/test'
import {
  spyOn as spyOnOriginal,
  stubMethod as stubMethodOriginal,
} from '../utils/spy-stub-helper'

type SpyOnFn = (objectName: string, method: string) => Promise<any[]>
type StubMethodFn = (
  objectName: string,
  method: string,
  implementation?: (...args: any[]) => any,
) => Promise<any[]>

// Extend the base test with our custom fixture
const test = base.extend<{
  spyOn: SpyOnFn
  stubMethod: StubMethodFn
}>({
  spyOn: async ({page}, use) => {
    const spyOnFn: SpyOnFn = (objectName, method) =>
      spyOnOriginal(page, objectName, method)
    await use(spyOnFn)
  },

  stubMethod: async ({page}, use) => {
    const stubMethod: StubMethodFn = (objectName, method, implementation) =>
      stubMethodOriginal(page, objectName, method, implementation)
    await use(stubMethod)
  },
})

export {test}

/*
We can have a base fixtures file and we can extend it

// fixtures.ts
import { mergeTests } from '@playwright/test';
import { test as baseTest } from './base-fixtures';
import { test as authTest } from './auth-fixtures';
import { test as apiTest } from './api-fixtures';

const test = mergeTests(baseTest, authTest, apiTest);

export { test };
*/



================================================
FILE: pw/support/fixtures/crud-helper-fixture.ts
================================================
import type {Movie} from 'src/consumer'
import {test as baseApiRequestFixture} from './api-request-fixture'
import type {ApiRequestResponse} from './api-request-fixture'

const commonHeaders = (token: string) => ({
  Authorization: token,
})

//  Shared Types
type ServerResponse<T> = {
  status: number
  data: T
}

// Define each function signature as a type:
type AddMovieFn = (
  token: string,
  body: Omit<Movie, 'id'>,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<Movie>>>

type GetAllMoviesFn = (
  token: string,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<Movie[]>>>

type GetMovieByIdFn = (
  token: string,
  id: number,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<Movie>>>

type GetMovieByNameFn = (
  token: string,
  name: string,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<Movie[]>>>

type UpdateMovieFn = (
  token: string,
  id: number,
  body: Partial<Movie>,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<Movie>>>

type DeleteMovieFn = (
  token: string,
  id: number,
  baseUrl?: string,
) => Promise<ApiRequestResponse<ServerResponse<void>>>

//  group them all together
type MovieApiMethods = {
  addMovie: AddMovieFn
  getAllMovies: GetAllMoviesFn
  getMovieById: GetMovieByIdFn
  getMovieByName: GetMovieByNameFn
  updateMovie: UpdateMovieFn
  deleteMovie: DeleteMovieFn
}

// Generic Type Extension
export const test = baseApiRequestFixture.extend<MovieApiMethods>({
  addMovie: async ({apiRequest}, use) => {
    const addMovieFn: MovieApiMethods['addMovie'] = async (
      token,
      body,
      baseUrl?,
    ) => {
      return apiRequest<ServerResponse<Movie>>({
        method: 'POST',
        url: '/movies',
        baseUrl,
        body,
        headers: commonHeaders(token),
      })
    }

    await use(addMovieFn)
  },

  // getAllMovies
  getAllMovies: async ({apiRequest}, use) => {
    const getAllMoviesFn: MovieApiMethods['getAllMovies'] = (
      token,
      baseUrl?,
    ) => {
      return apiRequest<ServerResponse<Movie[]>>({
        method: 'GET',
        url: '/movies',
        baseUrl,
        headers: commonHeaders(token),
      })
    }
    await use(getAllMoviesFn)
  },

  // getMovieById
  getMovieById: async ({apiRequest}, use) => {
    const getMovieByIdFn: MovieApiMethods['getMovieById'] = async (
      token,
      id,
      baseUrl?,
    ) => {
      return apiRequest<ServerResponse<Movie>>({
        method: 'GET',
        url: `/movies/${id}`,
        baseUrl,
        headers: commonHeaders(token),
      })
    }
    await use(getMovieByIdFn)
  },

  getMovieByName: async ({apiRequest}, use) => {
    const getMovieByNameFn: MovieApiMethods['getMovieByName'] = async (
      token,
      name,
      baseUrl?,
    ) => {
      const queryParams = new URLSearchParams({name}).toString()
      const url = `/movies?${queryParams}`

      return apiRequest<ServerResponse<Movie[]>>({
        method: 'GET',
        url,
        baseUrl,
        headers: commonHeaders(token),
      })
    }
    await use(getMovieByNameFn)
  },

  updateMovie: async ({apiRequest}, use) => {
    const updateMovieFn: MovieApiMethods['updateMovie'] = (
      token,
      id,
      body,
      baseUrl?,
    ) => {
      return apiRequest<ServerResponse<Movie>>({
        method: 'PUT',
        url: `/movies/${id}`,
        baseUrl,
        body,
        headers: commonHeaders(token),
      })
    }
    await use(updateMovieFn)
  },

  deleteMovie: async ({apiRequest}, use) => {
    const deleteMovieFn: MovieApiMethods['deleteMovie'] = (
      token,
      id,
      baseUrl?,
    ) => {
      return apiRequest<ServerResponse<void>>({
        method: 'DELETE',
        url: `/movies/${id}`,
        baseUrl,
        headers: commonHeaders(token),
      })
    }
    await use(deleteMovieFn)
  },
})



================================================
FILE: pw/support/fixtures/fail-on-js-error.ts
================================================
import type {Page} from '@playwright/test'
import {test as base, expect} from '@playwright/test'

export const test = base.extend<{page: Page; failOnJSError: boolean}>({
  // The first element true is the default value for the failOnJSError fixture
  // The second element { option: true } is a configuration object that tells Playwright this fixture can be configured per test
  failOnJSError: [true, {option: true}],
  page: async ({page, failOnJSError}, use) => {
    // before
    const errors: Array<Error> = []

    page.addListener('pageerror', error => {
      errors.push(error)
    })

    await use(page)

    // after
    if (failOnJSError) {
      expect(errors).toHaveLength(0)
    }
  },
})

/*

To turn off failing on JS error
in the beginning of a test file insert:

test.use({ failOnJSError: false })

*/



================================================
FILE: pw/support/fixtures/network-fixture.ts
================================================
import {test as base} from '@playwright/test'
import {
  interceptNetworkCall as InterceptNetworkCallOriginal,
  type InterceptOptions,
} from '../utils/network'

// Shared Types
type InterceptOptionsFixture = Omit<InterceptOptions, 'page'>

// Define the function signature as a type
type InterceptNetworkCallFn = (
  options: InterceptOptionsFixture,
) => ReturnType<typeof InterceptNetworkCallOriginal>

// group the types together
type InterceptNetworkMethods = {
  interceptNetworkCall: InterceptNetworkCallFn
}

// Generic Type Extension
export const test = base.extend<InterceptNetworkMethods>({
  interceptNetworkCall: async ({page}, use) => {
    const interceptNetworkCallFn: InterceptNetworkCallFn = ({
      method,
      url,
      fulfillResponse,
      handler,
    }: InterceptOptionsFixture) =>
      InterceptNetworkCallOriginal({
        method,
        url,
        fulfillResponse,
        handler,
        page,
      })

    await use(interceptNetworkCallFn)
  },
})



================================================
FILE: pw/support/ui-helpers/add-movie.ts
================================================
import type {Page} from '@playwright/test'

export const addMovie = async (
  page: Page,
  name: string,
  year: number,
  rating: number,
  director: string,
) => {
  await page.getByPlaceholder('Movie name').fill(name)
  await page.getByPlaceholder('Movie year').fill(String(year))
  await page.getByPlaceholder('Movie rating').fill(String(rating))
  await page.getByPlaceholder('Movie director').fill(director)
}



================================================
FILE: pw/support/ui-helpers/edit-movie.ts
================================================
import type {Page} from '@playwright/test'

export const editMovie = async (
  page: Page,
  editedName: string,
  editedYear: number,
  editedRating: number,
  editedDirector: string,
) => {
  await page.getByTestId('edit-movie').click()

  const editForm = page.getByTestId('movie-edit-form-comp')

  await editForm.getByPlaceholder('Movie name').fill(editedName)
  await editForm.getByPlaceholder('Movie year').fill(String(editedYear))
  await editForm.getByPlaceholder('Movie rating').fill(String(editedRating))
  await editForm.getByPlaceholder('Movie director').fill(editedDirector)

  await editForm.getByTestId('update-movie').click()
}



================================================
FILE: pw/support/utils/network.ts
================================================
import type {Page, Request, Response, Route} from '@playwright/test'
import picomatch from 'picomatch'

export type InterceptNetworkCall = ReturnType<typeof interceptNetworkCall>

type FulfillResponse = {
  status?: number
  headers?: Record<string, string>
  body?: unknown // Can be string, Buffer, or object
}

type PreparedResponse = {
  status?: number
  headers?: Record<string, string>
  body?: string | Buffer
}

export type InterceptOptions = {
  method?: string
  url?: string
  page: Page
  fulfillResponse?: FulfillResponse
  handler?: (route: Route, request: Request) => Promise<void> | void
}

type NetworkCallResult = {
  request: Request | null
  response: Response | null
  responseJson: unknown
  status: number
  requestJson: unknown
}

/**
 * Intercepts a network request matching the given criteria.
 * - If `fulfillResponse` is provided, stubs the request and fulfills it with the given response.
 * - If `handler` is provided, uses it to handle the route.
 * - Otherwise, observes the request and returns its data.
 * @param {InterceptOptions} options - Options for matching and handling the request.
 * @returns {Promise<NetworkCallResult>}
 */
export async function interceptNetworkCall({
  method,
  url,
  page,
  fulfillResponse,
  handler,
}: InterceptOptions): Promise<NetworkCallResult> {
  if (!page) {
    throw new Error('The `page` argument is required for network interception')
  }

  if (fulfillResponse || handler) {
    return fulfillNetworkCall(page, method, url, fulfillResponse, handler)
  } else {
    return observeNetworkCall(page, method, url)
  }
}

async function fulfillNetworkCall(
  page: Page,
  method?: string,
  url?: string,
  fulfillResponse?: FulfillResponse,
  handler?: (route: Route, request: Request) => Promise<void> | void,
): Promise<NetworkCallResult> {
  const routePattern = url?.startsWith('**') ? url : `**${url || '*'}`
  const preparedResponse = prepareResponse(fulfillResponse)

  // Create a promise that will resolve with the request data
  let resolveRequest: (request: Request) => void
  const requestPromise = new Promise<Request>(resolve => {
    resolveRequest = resolve
  })

  await page.route(routePattern, async (route, request) => {
    if (matchesRequest(request, method, url)) {
      // Capture the request before handling it
      resolveRequest(request)

      if (handler) {
        await handler(route, request)
      } else if (preparedResponse) {
        await route.fulfill(preparedResponse)
      }
    } else {
      await route.continue()
    }
  })

  // Wait for the request to be captured
  const request = await requestPromise
  let requestJson = null
  try {
    requestJson = await request.postDataJSON()
  } catch {
    // Request has no post data or is not JSON
  }

  return {
    request,
    response: null,
    responseJson: fulfillResponse?.body ?? null,
    status: fulfillResponse?.status ?? 200,
    requestJson,
  }
}

async function observeNetworkCall(
  page: Page,
  method?: string,
  url?: string,
): Promise<NetworkCallResult> {
  const request = await page.waitForRequest(req =>
    matchesRequest(req, method, url),
  )

  const response = await request.response()
  if (!response) {
    throw new Error('No response received for the request')
  }

  let data = null
  try {
    const contentType = response.headers()['content-type']
    if (contentType?.includes('application/json')) {
      data = await response.json()
    }
  } catch {
    // Response is not JSON
  }

  let requestJson = null
  try {
    requestJson = await request.postDataJSON()
  } catch {
    // Request has no post data or is not JSON
  }

  return {
    request,
    response,
    responseJson: data,
    status: response.status(),
    requestJson,
  }
}

/** Creates a URL matcher function based on the provided glob pattern.
 *
 * @param {string} [pattern] - Glob pattern to match URLs against.
 * @returns {(url: string) => boolean} - A function that takes a URL and returns whether it matches the pattern.
 */
function createUrlMatcher(pattern?: string) {
  if (!pattern) return () => true

  const globPattern = pattern.startsWith('**') ? pattern : `**${pattern}`
  const isMatch = picomatch(globPattern)

  return isMatch
}

/**
 * Determines whether a network request matches the specified method and URL pattern.
 *
 * @param {Request} request - The network request to evaluate.
 * @param {string} [method] - HTTP method to match.
 * @param {string} [urlPattern] - URL pattern to match.
 * @returns {boolean} - `true` if the request matches both the method and URL pattern; otherwise, `false`.
 */
function matchesRequest(
  request: Request,
  method?: string,
  urlPattern?: string,
): boolean {
  const matchesMethod = !method || request.method() === method

  const matcher = createUrlMatcher(urlPattern) // Step 1: Create the matcher function
  const matchesUrl = matcher(request.url()) // Step 2: Use the matcher with the URL

  return matchesMethod && matchesUrl
}

/**
 * Prepares the response by stringifying the body if it's an object and setting appropriate headers.
 * @param {FulfillResponse} fulfillResponse - The response details.
 * @returns {PreparedResponse | undefined} - The prepared response.
 */
function prepareResponse(
  fulfillResponse?: FulfillResponse,
): PreparedResponse | undefined {
  if (!fulfillResponse) return undefined

  const {status = 200, headers = {}, body} = fulfillResponse
  const contentType = headers['Content-Type'] || 'application/json'

  return {
    status,
    headers: {
      'Content-Type': contentType,
      ...headers,
    },
    body: typeof body === 'string' ? body : JSON.stringify(body),
  }
}



================================================
FILE: pw/support/utils/recurse-with-expect.ts
================================================
export async function recurseWithExpect(
  fn: () => Promise<void>,
  options?: {
    retries?: number
    interval?: number
    timeout?: number
  },
): Promise<void> {
  const retries = options?.retries ?? 10
  const interval = options?.interval ?? 500 // milliseconds
  const timeout = options?.timeout ?? 10000 // milliseconds

  const endTime = Date.now() + timeout
  let attempt = 0

  while (attempt < retries && Date.now() < endTime) {
    try {
      await fn()
      return // All assertions passed
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.warn(
          `Attempt ${attempt + 1} failed: ${error.message}. Retrying in ${interval}ms...`,
        )
      } else {
        console.error(
          `Attempt ${attempt + 1} failed: An unknown error occurred. Retrying in ${interval}ms...`,
          error,
        )
        throw error
      }
    }

    attempt++
    await new Promise(res => setTimeout(res, interval))
  }

  // Final attempt
  await fn()
}



================================================
FILE: pw/support/utils/run-command.ts
================================================
import {execSync} from 'child_process'

/**
 * Runs a shell command and returns the output.
 * Handles errors gracefully and returns null if the command fails.
 * @param {string} command - The command to run.
 * @returns {string | null} - The output of the command or null if it fails.
 */
export function runCommand(command: string): string | null {
  try {
    return execSync(command, {encoding: 'utf-8'}).trim()
  } catch (error) {
    const typedError = error as Error
    console.error(typedError.message)
    return null // Return null to signify failure
  }
}



================================================
FILE: pw/support/utils/spy-stub-helper.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import type {Page} from '@playwright/test'

/**
 * Sets up a spy on a specified method within the page context.
 * Captures all calls to the method into an array for later assertions.
 *
 * @param {Page} page - The Playwright page object.
 * @param {string} objectName - The name of the object to spy on (e.g., 'console').
 * @param {string} method - The method to spy on (e.g., 'log').
 * @returns {Promise<unknown[]>} - A promise that resolves to an array containing the captured calls and their arguments.
 *
 * @example
 * // To spy on console.log:
 * const logMessages = await spyOn(page, 'console', 'log');
 *
 * // Perform actions that trigger console.log in the page context
 * await page.goto('/');
 *
 * // Now, logMessages contains all the arguments passed to console.log
 * console.log(logMessages);
 *
 * @remarks
 * This function works by:
 * 1. Exposing a function (`exposedFunctionName`) to the page context.
 * 2. Injecting a script into the page that overrides the specified method (`objectName[method]`).
 *    - The overridden method calls the original method to maintain normal functionality.
 *    - It then calls the exposed function to pass the arguments back to the Node.js context.
 */
export async function spyOn(
  page: Page,
  objectName: string,
  method: string,
): Promise<unknown[]> {
  const messages: unknown[] = []

  // Create a function in the application's "window" object which pushes its arguments
  const exposedFunctionName = `${objectName}_${method}_spy`
  await page.exposeFunction(exposedFunctionName, (...args: unknown[]) =>
    messages.push(args),
  )

  // Inject the initial script into the application, which overwrites the specified method
  await page.addInitScript(
    ({
      objectName,
      method,
      exposedFunctionName,
    }: {
      objectName: string
      method: string
      exposedFunctionName: string
    }) => {
      const object = (window as any)[objectName] as Record<
        string,
        (...args: any[]) => any
      >

      if (!object || typeof object[method] !== 'function') {
        throw new Error(`Method ${method} not found on object ${objectName}`)
      }

      const originalMethod = object[method].bind(object)

      object[method] = (...args: any[]) => {
        // Call the original method
        originalMethod(...args)
        // Pass the arguments to the exposed function
        ;(window as any)[exposedFunctionName](...args)
      }
    },
    {objectName, method, exposedFunctionName},
  )

  return messages
}

/**
 * Stubs a specified method within the page context.
 * Replaces the method with a stub that can have custom behavior.
 * Captures all calls to the method into an array for later assertions.
 *
 * @param {Page} page - The Playwright page object.
 * @param {string} objectName - The name of the object to stub (e.g., 'console').
 * @param {string} method - The method to stub (e.g., 'log').
 * @param {(args: any[]) => any} [implementation] - Optional custom implementation for the stubbed method.
 * @returns {Promise<Array<any>>} - A promise that resolves to an array containing the captured calls and their arguments.
 */
export async function stubMethod(
  page: Page,
  objectName: string,
  method: string,
  implementation?: (...args: any[]) => any,
): Promise<any[]> {
  const calls: any[] = []

  // Create a function in the Node.js context that will receive the method arguments from the page context
  const exposedFunctionName = `${objectName}_${method}_stub`
  await page.exposeFunction(exposedFunctionName, (...args: any[]) => {
    calls.push(args)
  })

  // Inject a script into the page that replaces the specified method with a stub
  await page.addInitScript(
    ({
      objectName,
      method,
      exposedFunctionName,
      hasCustomImpl,
    }: {
      objectName: string
      method: string
      exposedFunctionName: string
      hasCustomImpl: boolean
    }) => {
      const object = (window as any)[objectName] as Record<
        string,
        (...args: any[]) => any
      >

      if (!object) {
        throw new Error(`Object ${objectName} not found in window`)
      }

      object[method] = (...args: any[]) => {
        // Call the exposed function in the Node.js context to capture the arguments
        ;(window as any)[exposedFunctionName](...args)

        if (hasCustomImpl) {
          // If a custom implementation is provided, call it
          return (window as any)[`customImpl_${exposedFunctionName}`](...args)
        }
        // Default behavior: Do nothing or return undefined
      }
    },
    {
      objectName,
      method,
      exposedFunctionName,
      hasCustomImpl: !!implementation,
    },
  )

  // If a custom implementation is provided, expose it to the page context
  if (implementation) {
    const customImplName = `customImpl_${exposedFunctionName}`
    await page.exposeFunction(customImplName, implementation)
  }

  return calls
}



================================================
FILE: scripts/can-i-deploy-consumer.sh
================================================
#!/bin/bash

# Load environment variables
. ./scripts/env-setup.sh

# Check if the ReactConsumer can be deployed
pact-broker can-i-deploy \
    --pacticipant ReactConsumer \
    --version=$GITHUB_SHA \
    --to-environment dev \
    --retry-while-unknown=10



================================================
FILE: scripts/env-setup.sh
================================================
#!/bin/bash

# Load environment variables from .env if it exists
if [ -f .env ]; then
  set -a # all variables that are subsequently defined are automatically exported to the environment of subsequent commands
  source .env
  set +a # turns off allexport
fi

# Set Git-related environment variables
export GITHUB_SHA=$(git rev-parse --short HEAD)
export GITHUB_BRANCH=$(git rev-parse --abbrev-ref HEAD)


================================================
FILE: scripts/publish-pact.sh
================================================
#!/bin/bash

# Load environment variables
. ./scripts/env-setup.sh

# Publish pacts to the broker
pact-broker publish ./pacts \
    --consumer-app-version=$GITHUB_SHA \
    --branch=$GITHUB_BRANCH \
    --broker-base-url=$PACT_BROKER_BASE_URL \
    --broker-token=$PACT_BROKER_TOKEN


================================================
FILE: scripts/record-consumer-deployment.sh
================================================
#!/bin/bash

# Load environment variables
. ./scripts/env-setup.sh

# Record consumer deployment for the main branch
if [ "$GITHUB_BRANCH" = "main" ]; then
  pact-broker record-deployment \
    --pacticipant ReactConsumer \
    --version $GITHUB_SHA \
    --environment $npm_config_env
fi



================================================
FILE: src/App-routes.tsx
================================================
import MovieForm from '@components/movie-form'
import MovieDetails from '@components/movie-details'
import MovieList from '@components/movie-list'
import {
  BrowserRouter,
  Navigate,
  Route,
  Routes,
  useSearchParams,
} from 'react-router-dom'
import type {ErrorResponse, Movie} from './consumer'

type AppRoutesProps = Readonly<{
  movies: Movie[] | ErrorResponse | undefined
  onDelete: (id: number) => void
}>

export default function AppRoutes({movies, onDelete}: AppRoutesProps) {
  return (
    <BrowserRouter>
      <Routes>
        <Route
          path="/movies"
          element={<MovieListWithForm movies={movies} onDelete={onDelete} />}
        />
        <Route path="/" element={<Navigate to="/movies" replace />} />
        <Route path="/movies/:id" element={<MovieDetails />} />
      </Routes>
    </BrowserRouter>
  )
}

/**
 * Renders both MovieList and MovieForm on the "/movies" route.
 *
 * @component
 * @param {Object} props - The properties passed to the component.
 * @param {Movie[] | ErrorResponse | undefined} props.movies - The list of movies or an error response.
 * @param {function} props.onDelete - A callback function for deleting a movie by its ID.
 * @returns {JSX.Element} - The rendered MovieList and MovieForm components.
 *
 * @example
 * // Example usage:
 * <MovieListWithForm movies={movieArray} onDelete={handleDeleteMovie} />
 */
function MovieListWithForm({movies, onDelete}: AppRoutesProps) {
  const [searchParams] = useSearchParams()
  const movieName = searchParams.get('name')

  return movieName ? (
    <MovieDetails />
  ) : (
    <>
      <MovieList movies={movies} onDelete={onDelete} />
      <MovieForm />
    </>
  )
}



================================================
FILE: src/App.tsx
================================================
import {useDeleteMovie, useMovies} from '@hooks/use-movies'
import {SAppContainer} from '@styles/styled-components'
import LoadingMessage from '@components/loading-message'
import {Suspense} from 'react'
import {ErrorBoundary} from 'react-error-boundary'
import ErrorComponent from '@components/error-component'
import AppRoutes from './App-routes'
import type {Movie} from './consumer'

export default function App() {
  const {data} = useMovies()
  const moviesData = (data as unknown as {data: Movie[]}).data

  const deleteMovieMutation = useDeleteMovie()
  const handleDeleteMovie = deleteMovieMutation.mutate

  return (
    <ErrorBoundary fallback={<ErrorComponent />}>
      <Suspense fallback={<LoadingMessage />}>
        <SAppContainer>
          <AppRoutes movies={moviesData} onDelete={handleDeleteMovie} />
        </SAppContainer>
      </Suspense>
    </ErrorBoundary>
  )
}



================================================
FILE: src/consumer-contract.pacttest.ts
================================================
import type {V3MockServer} from '@pact-foundation/pact'
import {MatchersV3, PactV4} from '@pact-foundation/pact'
import path from 'path'
import type {ErrorResponse, Movie} from './consumer'
import {
  addMovie,
  deleteMovieById,
  getMovies,
  getMovieById,
  getMovieByName,
  setApiUrl,
  updateMovie,
} from './consumer'
import {createProviderState, setJsonBody} from './test-utils/pact-utils/helpers'
import type {
  DeleteMovieResponse,
  GetMovieResponse,
  MovieNotFoundResponse,
} from './provider-schema/movie-types'

// full list of matchers:
// https://docs.pact.io/implementation_guides/javascript/docs/matching#v3-matching-rules
const {like, eachLike, integer, decimal, string} = MatchersV3

// 1) Setup the mock provider for the consumer
// 2) Register the consumer's expectations against the (mock) provider
// 3) Call the consumer against the mock provider
// 4) Verify the consumer test and generate the contract

// 1) Setup the mock provider for the consumer
const pact = new PactV4({
  dir: path.resolve(process.cwd(), 'pacts'),
  consumer: 'ReactConsumer',
  provider: 'MoviesAPI-bi-directional',
  // logLevel: 'debug'
})

describe('Movies API', () => {
  const movieWithId: Movie = {
    id: 1,
    name: 'My movie',
    year: 1999,
    rating: 8.5,
    director: 'John Doe',
  }
  const testId = 100
  const movieWithTestId100: Movie = {
    id: testId,
    name: 'My movie',
    year: 1999,
    rating: 8.5,
    director: 'John Doe',
  }
  const movieWithoutId: Omit<Movie, 'id'> = {
    name: 'New movie',
    year: 1999,
    rating: 8.5,
    director: 'John Doe',
  }

  const propMatcherNoId = (movieEntity: Movie | Omit<Movie, 'id'>) => ({
    name: string(movieEntity.name),
    year: integer(movieEntity.year),
    rating: decimal(movieEntity.rating),
    director: string(movieEntity.director),
  })

  describe('When a GET request is made to /movies', () => {
    it('should return all movies', async () => {
      // we want to ensure at least 1 movie is returned in the array of movies
      const [stateName, stateParams] = createProviderState({
        name: 'An existing movie exists',
        params: movieWithId,
      })

      // 2) Register the consumer's expectations against the (mock) provider
      await pact
        .addInteraction()
        .given(stateName, stateParams)
        .uponReceiving('a request to get all movies')
        .withRequest('GET', '/movies')
        .willRespondWith(
          200,
          setJsonBody({
            status: 200,
            data: eachLike(movieWithId),
          }),
        )
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = await getMovies()
          // 4) Verify the consumer test and generate the contract
          expect(res.data).toEqual([movieWithId])
        })
    })

    it('should return empty when no movies exist', async () => {
      const noMovies: Movie[] = []

      await pact
        .addInteraction()
        .given('No movies exist')
        .uponReceiving('a request to get all movies')
        .withRequest('GET', '/movies')
        .willRespondWith(200, setJsonBody({status: 200, data: like(noMovies)}))
        .executeTest(async (mockServer: V3MockServer) => {
          setApiUrl(mockServer.url)
          const res = await getMovies()
          expect(res.data).toEqual(noMovies)
        })
    })

    it('should return a movie by name when requested with query parameters', async () => {
      // we want to ensure at least 1 movie is returned in the array of movies
      const [stateName, stateParams] = createProviderState({
        name: 'An existing movie exists',
        params: movieWithId,
      })

      await pact
        .addInteraction()
        .given(stateName, stateParams)
        .uponReceiving('a request to get a movie by name')
        .withRequest('GET', '/movies', builder => {
          builder.query({name: movieWithId.name}) // Use query to specify query parameters
        })
        .willRespondWith(
          200,
          setJsonBody({
            status: 200,
            data: {
              id: integer(movieWithId.id),
              ...propMatcherNoId(movieWithId),
            },
          }),
        )
        .executeTest(async (mockServer: V3MockServer) => {
          setApiUrl(mockServer.url)
          const res = (await getMovieByName(
            movieWithId.name,
          )) as GetMovieResponse
          expect(res.data).toEqual(movieWithId)
        })
    })
  })

  // PROVIDER STATES: we can simulate certain states of the api (like an empty or non-empty db)
  // in order to cover different scenarios
  // the state could have many more variables; it is a good practice to represent it as an object
  // note that the consumer state name should match the provider side

  // * The purpose of the stateHandlers is to ensure that the provider is in the correct state
  // to fulfill the consumer's expectations as defined in the contract tests.
  // * In a real-world scenario, you would typically set up this state by interacting with your service's database
  // * or through an API provided by the service itself (locally).
  // * This ensures that the provider test runs in a controlled environment where all the necessary data
  // and conditions are met, allowing for accurate verification of the consumer's expectations.
  describe('When a GET request is made to a specific movie ID', () => {
    it('should return a specific movie', async () => {
      const [stateName, stateParams] = createProviderState({
        name: 'Has a movie with a specific ID',
        params: {id: testId},
      })

      await pact
        .addInteraction()
        .given(stateName, stateParams)
        .uponReceiving('a request to a specific movie')
        .withRequest('GET', `/movies/${testId}`)
        .willRespondWith(
          200,
          setJsonBody({
            status: 200,
            data: {
              id: integer(testId),
              ...propMatcherNoId(movieWithTestId100),
            },
          }),
        )
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = (await getMovieById(testId)) as GetMovieResponse
          expect(res.data).toEqual(movieWithTestId100)
        })
    })
  })

  describe('When a POST request is made to /movies', () => {
    it('should add a new movie', async () => {
      await pact
        .addInteraction()
        .given('No movies exist')
        .uponReceiving('a request to add a new movie')
        .withRequest('POST', '/movies', setJsonBody(movieWithoutId))
        .willRespondWith(
          200,
          setJsonBody({
            status: 200,
            data: {
              id: integer(), // if the example value is omitted, a random number is used
              ...propMatcherNoId(movieWithoutId),
            },
          }),
        )
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = await addMovie(movieWithoutId)
          expect(res).toEqual({
            status: 200,
            data: {
              id: expect.any(Number),
              name: movieWithoutId.name,
              year: movieWithoutId.year,
              rating: movieWithoutId.rating,
              director: movieWithoutId.director,
            },
          })
        })
    })

    it('should not add a movie that already exists', async () => {
      const errorRes: ErrorResponse = {
        error: `Movie ${movieWithoutId.name} already exists`,
      }

      const [stateName, stateParams] = createProviderState({
        name: 'An existing movie exists',
        params: movieWithoutId,
      })

      await pact
        .addInteraction()
        .given(stateName, stateParams)
        .uponReceiving('a request to the existing movie')
        .withRequest('POST', '/movies', setJsonBody({...movieWithoutId}))
        .willRespondWith(409, setJsonBody(errorRes))
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = await addMovie(movieWithoutId)
          expect(res).toEqual(errorRes)
        })
    })
  })

  describe('When a PUT request is made to a specific movie ID', () => {
    it('should update an existing movie', async () => {
      const testId = 99
      const updatedMovieData = {
        name: 'Updated movie',
        year: 2000,
        rating: 8.5,
        director: 'Steven Spielberg',
      }

      const [stateName, stateParams] = createProviderState({
        name: 'Has a movie with a specific ID',
        params: {id: testId},
      })

      await pact
        .addInteraction()
        .given(stateName, stateParams)
        .uponReceiving('a request to update a specific movie')
        .withRequest('PUT', `/movies/${testId}`, setJsonBody(updatedMovieData))
        .willRespondWith(
          200,
          setJsonBody({
            status: 200,
            data: {
              id: integer(testId),
              ...propMatcherNoId(updatedMovieData),
            },
          }),
        )
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)

          const res = await updateMovie(testId, updatedMovieData)

          expect(res).toEqual({
            status: 200,
            data: {
              id: testId,
              name: updatedMovieData.name,
              year: updatedMovieData.year,
              rating: updatedMovieData.rating,
              director: updatedMovieData.director,
            },
          })
        })
    })
  })

  describe('When a DELETE request is made to /movies', () => {
    it('should delete an existing movie successfully', async () => {
      const testId = 200
      const message = `Movie ${testId} has been deleted`

      const state = createProviderState({
        name: 'Has a movie with a specific ID',
        params: {id: testId},
      })

      await pact
        .addInteraction()
        .given(...state)
        .uponReceiving('a request to delete a movie that exists')
        .withRequest('DELETE', `/movies/${testId}`)
        .willRespondWith(200, setJsonBody({status: 200, message}))
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = (await deleteMovieById(testId)) as DeleteMovieResponse
          expect(res.message).toEqual(message)
        })
    })

    it('should throw an error if movie to delete does not exist', async () => {
      const testId = 123456789
      const error = `Movie with ID ${testId} not found`

      await pact
        .addInteraction()
        .uponReceiving('a request to delete a non-existing movie')
        .withRequest('DELETE', `/movies/${testId}`)
        .willRespondWith(404, setJsonBody({error, status: 404}))
        .executeTest(async (mockServer: V3MockServer) => {
          // Override the API URL to point to the mock server
          setApiUrl(mockServer.url)
          const res = (await deleteMovieById(testId)) as MovieNotFoundResponse
          expect(res.error).toEqual(error)
        })
    })
  })
})



================================================
FILE: src/consumer.test.ts
================================================
/**
 * @jest-environment node
 */

import nock, {cleanAll} from 'nock'
import {
  getMovies,
  getMovieById,
  getMovieByName,
  addMovie,
  deleteMovieById,
  updateMovie,
} from './consumer'
import type {Movie, ErrorResponse} from './consumer'
import type {
  DeleteMovieResponse,
  GetMovieResponse,
} from './provider-schema/movie-types'

const API_URL = import.meta.env.VITE_API_URL

// Nock can be used to test modules that make HTTP requests to external APIs in isolation.
// For example, if a module sends HTTP requests to an external API, you can test that module independently of the actual API.
/*
Key differences between Nock and Pact:

1) **Error handling**:
   - **Nock**: You can and should cover error scenarios in your code, regardless of the provider's actual behavior.
   - **Pact**: You cover error scenarios only if it is important for your consumer contract.

2) **Provider states**:
   - **Nock**: There are no provider states, as Nock focuses on testing in isolation without interacting with the provider.
   - **Pact**: Introduces provider states, enabling you to simulate various conditions (e.g., empty or non-empty databases) 
	 and verify contracts by running tests directly against the provider (at the provider repo, while locally serving the provider).

3) **Response flexibility**:
   - **Nock**: Mocked responses must be concrete and predefined.
   - **Pact**: Allows for loose matchers, enabling more flexibility by focusing on the shape of the data rather than exact values.
*/

// baseURL in axiosInstance: Axios uses a fixed base URL for all requests,
// and Nock must intercept that exact URL for the tests to work.

describe('Consumer API functions', () => {
  afterEach(() => {
    cleanAll()
  })

  const movieWithId: Movie = {
    id: 1,
    name: 'My movie',
    year: 1999,
    rating: 8.5,
    director: 'John Doe',
  }
  const movieWithoutId: Omit<Movie, 'id'> = {
    name: 'New movie',
    year: 1999,
    rating: 8.5,
    director: 'John Doe',
  }

  describe('getMovies, getMovieByName', () => {
    // this is 1:1 with the pacttest version
    it('should return all movies', async () => {
      nock(API_URL)
        .get('/movies')
        .reply(200, {status: 200, data: [movieWithId]})

      const res = await getMovies()
      expect(res.data).toEqual([movieWithId])
    })

    // a key difference in nock vs pact is covering the error cases in our code
    // in reality, the provider never errors; it just returns an empty array,
    // but our code can handle an error, so we can test it...
    it('should handle errors correctly', async () => {
      const errorRes: ErrorResponse = {error: 'Not found'}
      nock(API_URL).get('/movies').reply(404, errorRes)

      const res = await getMovies()
      expect(res).toEqual(errorRes)
    })

    it('should return a specific movie by name', async () => {
      nock(API_URL)
        .get(`/movies?name=${movieWithId.name}`)
        .reply(200, {status: 200, data: movieWithId})

      const res = (await getMovieByName(movieWithId.name)) as GetMovieResponse
      expect(res.data).toEqual(movieWithId)
    })
  })

  describe('getMovieById', () => {
    // this is similar to its pacttest version
    // a key difference in pact is using provider states, to fully simulate the provider side
    // in nock, we are not concerned with running our tests against the provider...
    it('should return a specific movie by id', async () => {
      // in pact the provider state would be specified here
      nock(API_URL)
        .get(`/movies/${movieWithId.id}`)
        .reply(200, {status: 200, data: movieWithId})

      const res = (await getMovieById(1)) as GetMovieResponse
      expect(res.data).toEqual(movieWithId)
    })

    it('should handle errors when movie not found', async () => {
      const testId = 999
      const errorRes: ErrorResponse = {error: 'Movie not found'}
      nock(API_URL).get(`/movies/${testId}`).reply(404, errorRes)

      const res = await getMovieById(testId)
      expect(res).toEqual(errorRes)
    })
  })

  describe('addMovie', () => {
    // this is similar to its pacttest version
    it('should add a new movie', async () => {
      // with pact we can keep the response generic
      // with nock it has to be concrete response
      nock(API_URL)
        .post('/movies', movieWithoutId)
        .reply(200, {
          status: 200,
          data: {
            id: 1,
            ...movieWithoutId,
          },
        })

      const res = await addMovie(movieWithoutId)
      expect(res).toEqual({
        status: 200,
        data: {
          id: expect.any(Number),
          ...movieWithoutId,
        },
      })
    })

    // this is similar to its pacttest version
    // a key difference in pact is using provider states, to fully simulate the provider side
    it('should not add a movie that already exists', async () => {
      const errorRes: ErrorResponse = {
        error: `Movie ${movieWithoutId.name} already exists`,
      }

      // in pact the provider state would be specified here
      nock(API_URL).post('/movies', movieWithoutId).reply(409, errorRes)

      const res = await addMovie(movieWithoutId)
      expect(res).toEqual(errorRes)
    })
  })

  describe('updateMovie', () => {
    const updatedMovieData = {
      name: 'Updated movie',
      year: 2000,
      rating: 8.5,
      director: 'Steven Spielberg',
    }
    it('should update an existing movie successfully', async () => {
      const testId = 1

      const EXPECTED_BODY: Movie = {
        id: testId,
        ...updatedMovieData,
      }

      nock(API_URL)
        .put(`/movies/${testId}`, updatedMovieData)
        .reply(200, {status: 200, movie: EXPECTED_BODY})

      const res = await updateMovie(testId, updatedMovieData)

      expect(res).toEqual({status: 200, movie: EXPECTED_BODY})
    })

    it('should return an error if movie to update does not exist', async () => {
      const testId = 999
      const errorRes: ErrorResponse = {
        error: `Movie with ID ${testId} no found`,
      }

      nock(API_URL)
        .put(`/movies/${testId}`, updatedMovieData)
        .reply(404, errorRes)

      const res = await updateMovie(testId, updatedMovieData)

      expect(res).toEqual(errorRes)
    })
  })

  describe('deleteMovieById', () => {
    // this is similar to its pacttest version
    // a key difference in pact is using provider states, to fully simulate the provider side
    it('should delete an existing movie successfully', async () => {
      const testId = 100
      const message = `Movie ${testId} has been deleted`

      // in pact the provider state would be specified here
      nock(API_URL)
        .delete(`/movies/${testId}`)
        .reply(200, {message, status: 200})

      const res = (await deleteMovieById(testId)) as DeleteMovieResponse
      expect(res.message).toEqual(message)
    })

    it('should throw an error if movie to delete does not exist', async () => {
      const testId = 123456789
      const message = `Movie with ID ${testId} not found`

      // in pact the provider state would be specified here
      nock(API_URL)
        .delete(`/movies/${testId}`)
        .reply(404, {message, status: 404})

      const res = (await deleteMovieById(testId)) as DeleteMovieResponse
      expect(res.message).toEqual(message)
    })
  })
})



================================================
FILE: src/consumer.ts
================================================
import type {AxiosResponse, AxiosError} from 'axios'
import axios from 'axios'
import type {
  ConflictMovieResponse,
  CreateMovieResponse,
  DeleteMovieResponse,
  GetMovieResponse,
  MovieNotFoundResponse,
  UpdateMovieResponse,
} from './provider-schema/movie-types'

const API_URL = import.meta.env.VITE_API_URL

// Movie type from the provider, in the real world this would come from a published package
export type Movie = {
  id: number
  name: string
  year: number
  rating: number
  director: string
}

export type ErrorResponse = {
  error: string
}
// baseURL in axiosInstance: Axios uses a fixed base URL for all requests,
// and Nock must intercept that exact URL for the tests to work
const axiosInstance = axios.create({
  baseURL: API_URL, // this is really the API url where the requests are going to
})

// function to override the baseURL, used during pact tests
// It allows to change the baseURL of axiosInstance dynamically
// By changing the baseURL during tests, we can direct the requests
// to the Pact mock server instead of the actual API
export const setApiUrl = (url: string) => {
  axiosInstance.defaults.baseURL = url
}

// Helper function to extract data from Axios response
const yieldData = <T>(res: AxiosResponse<T>): T => res.data

// Helper function to handle errors
const handleError = (err: AxiosError): ErrorResponse => {
  if (err.response?.data) return err.response.data as ErrorResponse
  return {error: 'Unexpected error occurred'}
}

const generateAuthToken = (): string => `Bearer ${new Date().toISOString()}`

const commonHeaders = {
  headers: {Authorization: generateAuthToken()},
}

// Fetch all movies
export const getMovies = (): Promise<GetMovieResponse> =>
  axiosInstance.get('/movies', commonHeaders).then(yieldData).catch(handleError)

// Fetch a single movie by ID
export const getMovieById = (
  id: number,
): Promise<GetMovieResponse | MovieNotFoundResponse> =>
  axiosInstance
    .get(`/movies/${id}`, commonHeaders)
    .then(yieldData)
    .catch(handleError)

export const getMovieByName = (
  name: string,
): Promise<GetMovieResponse | MovieNotFoundResponse> =>
  axiosInstance
    .get(`/movies?name=${name}`, commonHeaders)
    .then(yieldData)
    .catch(handleError)

// Create a new movie
export const addMovie = (
  data: Omit<Movie, 'id'>,
): Promise<CreateMovieResponse | ConflictMovieResponse> =>
  axiosInstance
    .post('/movies', data, commonHeaders)
    .then(yieldData)
    .catch(handleError)

// Delete movie by ID
export const deleteMovieById = (
  id: number,
): Promise<DeleteMovieResponse | MovieNotFoundResponse> =>
  axiosInstance
    .delete(`/movies/${id}`, commonHeaders)
    .then(yieldData)
    .catch(handleError)

// Update movie by ID
export const updateMovie = (
  id: number,
  data: Partial<Omit<Movie, 'id'>>,
): Promise<UpdateMovieResponse | MovieNotFoundResponse> =>
  axiosInstance
    .put(`/movies/${id}`, data, commonHeaders)
    .then(yieldData)
    .catch(handleError)



================================================
FILE: src/main.tsx
================================================
import React from 'react'
import {createRoot} from 'react-dom/client'
import {QueryClient, QueryClientProvider} from '@tanstack/react-query'
import App from './App'

const port = import.meta.env.VITE_PORT
const apiUrl = import.meta.env.VITE_API_URL
console.log(`React app is running on port: ${port}`)
console.log(`API should be running on: ${apiUrl}`)

const root = createRoot(document.getElementById('root') as HTMLElement)

const queryClient = new QueryClient()

root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>,
)



================================================
FILE: src/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "exclude": ["**/cypress.d.ts", "**/cypress", "**/*.cy.ts*"],
  "compilerOptions": {
    "types": ["@types/jest", "@testing-library/jest-dom"]
  },
  "include": [
    "**/*.test.ts*",
    "**/*.vitest.ts*",
    "**/*.pacttest.ts*",
    "vite-env.d.ts"
  ]
}



================================================
FILE: src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: src/components/error-component.cy.tsx
================================================
import ErrorComponent from './error-component'

describe('<ErrorComponent />', () => {
  it('should render an error message', () => {
    cy.mount(<ErrorComponent />)
    cy.getByCy('error').should('be.visible')
    cy.contains('p', 'Try reloading the page')
  })
})



================================================
FILE: src/components/error-component.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import ErrorComp from './error-component'

test.describe('<ErrorComponent />', () => {
  test('should render an error message', async ({mount}) => {
    const c = await mount(<ErrorComp />)
    await expect(c.getByTestId('error')).toBeVisible()
    await expect(c.locator('p')).toHaveText('Try reloading the page.')
  })
})



================================================
FILE: src/components/error-component.tsx
================================================
export default function ErrorComp() {
  return (
    <>
      <h1 data-cy="error">Something went wrong!</h1>
      <p>Try reloading the page.</p>
    </>
  )
}



================================================
FILE: src/components/error-component.vitest.tsx
================================================
import {describe, expect, it, screen, wrappedRender} from '@vitest-utils/utils'
import ErrorComponent from './error-component'

describe('<ErrorComponent />', () => {
  it('should render an error message', () => {
    wrappedRender(<ErrorComponent />)
    expect(screen.getByTestId('error')).toBeVisible()
    expect(screen.getByText('Try reloading the page.'))
  })
})



================================================
FILE: src/components/loading-message.cy.tsx
================================================
import LoadingMessage from './loading-message'

describe('<LoadingMessage>', () => {
  it('should render a loading message', () => {
    cy.mount(<LoadingMessage />)
    cy.getByCy('loading-message-comp').should('be.visible')
  })
})



================================================
FILE: src/components/loading-message.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import LoadingMessage from './loading-message'

test.describe('<LoadingMessage>', () => {
  test('should render a loading message', async ({mount}) => {
    const c = await mount(<LoadingMessage />)

    // PW CT is in beta: PW has Issues with attribute selectors in component tests
    await expect(c.getByText('Loading movies...')).toBeVisible()
    // await expect(c.getByTestId('loading-message-comp')).toBeVisible() // this fails
  })
})



================================================
FILE: src/components/loading-message.tsx
================================================
export default function LoadingMessage() {
  return <p data-cy="loading-message-comp">Loading movies...</p>
}



================================================
FILE: src/components/loading-message.vitest.tsx
================================================
import {describe, expect, it, screen, wrappedRender} from '@vitest-utils/utils'
import LoadingMessage from './loading-message'

describe('<LoadingMessage />', () => {
  it('should render a loading message', () => {
    wrappedRender(<LoadingMessage />)

    expect(screen.getByTestId('loading-message-comp')).toBeVisible()
  })
})



================================================
FILE: src/components/movie-list.cy.tsx
================================================
import {generateMovie} from '@support/factories'
import MovieList from './movie-list'

describe('<MovieList />', () => {
  it('should show nothing with no movies', () => {
    cy.routeWrappedMount(
      <MovieList movies={[]} onDelete={cy.stub().as('onDelete')} />,
    )

    cy.getByCy('movie-list-comp').should('not.exist')
  })

  it('should show error with error', () => {
    cy.routeWrappedMount(
      <MovieList
        movies={{error: 'boom'}}
        onDelete={cy.stub().as('onDelete')}
      />,
    )

    cy.getByCy('movie-list-comp').should('not.exist')
    cy.getByCy('error').should('be.visible')
  })

  it('should verify the movie and delete', () => {
    const movie1Id = 7
    const movie2Id = 42
    const movie1 = {id: movie1Id, ...generateMovie()}
    const movie2 = {id: movie2Id, ...generateMovie()}

    cy.routeWrappedMount(
      <MovieList
        movies={[movie1, movie2]}
        onDelete={cy.stub().as('onDelete')}
      />,
    )

    cy.getByCy('movie-list-comp').should('be.visible')
    cy.getByCy('movie-item-comp').should('have.length', 2)

    cy.getByCy(`delete-movie-${movie1.name}`).click()
    cy.getByCy(`delete-movie-${movie2.name}`).click()
    cy.get('@onDelete').should('be.calledTwice')
    cy.get('@onDelete').its('callCount').should('eq', 2) // same thing
    cy.get('@onDelete').should('be.calledWith', movie1Id)
    cy.get('@onDelete').should('be.calledWith', movie2Id)
  })
})



================================================
FILE: src/components/movie-list.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import MovieList from './movie-list'
import {generateMovie} from '@support/factories'
import sinon from 'sinon'

test.describe('<MovieList>', () => {
  const sandbox = sinon.createSandbox()
  const onDelete = sandbox.stub()

  test.afterEach(() => {
    sandbox.restore()
  })

  test('should show nothing with no movies', async ({mount}) => {
    const c = await mount(<MovieList movies={[]} onDelete={onDelete} />)

    await expect(c.getByTestId('movie-list-comp')).not.toBeVisible()
  })

  test('should show error with error', async ({mount}) => {
    const c = await mount(
      <MovieList movies={{error: 'boom'}} onDelete={onDelete} />,
    )

    await expect(c.getByTestId('movie-list-comp')).not.toBeVisible()
    await expect(c.getByTestId('error')).toBeVisible()
  })

  test('should verify the movie and delete', async ({mount}) => {
    const movie1Id = 7
    const movie2Id = 42
    const movie1 = {id: movie1Id, ...generateMovie()}
    const movie2 = {id: movie2Id, ...generateMovie()}

    const c = await mount(
      <MovieList movies={[movie1, movie2]} onDelete={onDelete} />,
    )

    await expect(c.getByTestId('movie-list-comp')).toBeVisible()

    const movieItems = c.getByTestId('movie-item-comp').all()
    const items = await movieItems
    expect(items).toHaveLength(2)
    // with PW you have to use for await of, since you have to await the expect
    for (const item of items) {
      await expect(item).toBeVisible()
    }

    await c.getByTestId(`delete-movie-${movie1.name}`).click()
    await c.getByTestId(`delete-movie-${movie2.name}`).click()
    expect(onDelete.calledTwice).toBe(true)
    expect(onDelete.callCount).toBe(2)
    expect(onDelete.calledWith(movie1Id)).toBe(true)
    expect(onDelete.calledWith(movie2Id)).toBe(true)
  })
})



================================================
FILE: src/components/movie-list.tsx
================================================
import ErrorComp from '@components/error-component'
import styled from 'styled-components'
import type {ErrorResponse, Movie} from '../consumer'
import MovieItem from './movie-item'
import {STitle} from '@styles/styled-components'

type MovieListProps = Readonly<{
  movies: Movie[] | ErrorResponse | undefined
  onDelete: (id: number) => void
}>

export default function MovieList({movies, onDelete}: MovieListProps) {
  if (Array.isArray(movies) && movies.length === 0) {
    return null
  }

  if (movies && 'error' in movies) {
    return <ErrorComp />
  }

  return (
    <>
      <STitle>Movie List</STitle>
      <SMovieList data-cy="movie-list-comp">
        {Array.isArray(movies) &&
          movies.map(movie => (
            <MovieItem key={movie.id} {...movie} onDelete={onDelete} />
          ))}
      </SMovieList>
    </>
  )
}

const SMovieList = styled.ul`
  list-style: none;
  padding: 0;
  max-width: 600px;
  margin: 0 auto 20px;
`



================================================
FILE: src/components/movie-list.vitest.tsx
================================================
import {
  describe,
  expect,
  it,
  vi,
  screen,
  wrappedRender,
} from '@vitest-utils/utils'
import {generateMovie} from '@cypress/support/factories'
import MovieList from './movie-list'

describe('<MovieList />', () => {
  const onDelete = vi.fn()

  it('should show nothing with no movies', () => {
    wrappedRender(<MovieList movies={[]} onDelete={onDelete} />)

    expect(screen.queryByTestId('movie-list-comp')).not.toBeInTheDocument()
  })

  it('should show error with error', () => {
    wrappedRender(<MovieList movies={{error: 'boom'}} onDelete={onDelete} />)

    expect(screen.queryByTestId('movie-list-comp')).not.toBeInTheDocument()
    expect(screen.getByTestId('error')).toBeInTheDocument()
  })

  it('should verify the movie and delete', () => {
    const movie1Id = 7
    const movie2Id = 42
    const movie1 = {id: movie1Id, ...generateMovie()}
    const movie2 = {id: movie2Id, ...generateMovie()}

    wrappedRender(<MovieList movies={[movie1, movie2]} onDelete={onDelete} />)

    expect(screen.getByTestId('movie-list-comp')).toBeVisible()

    const movieItems = screen.getAllByTestId('movie-item-comp')
    expect(movieItems).toHaveLength(2)
    movieItems.forEach(movieItem => expect(movieItem).toBeVisible())

    screen.getByTestId(`delete-movie-${movie1.name}`).click()
    screen.getByTestId(`delete-movie-${movie2.name}`).click()
    expect(onDelete).toBeCalledTimes(2)
    expect(onDelete).toBeCalledWith(movie1Id)
    expect(onDelete).toBeCalledWith(movie2Id)
  })
})



================================================
FILE: src/components/validation-error-display.cy.tsx
================================================
import {ZodError} from 'zod'
import ValidationErrorDisplay from './validation-error-display'

describe('<ValidationErrorDisplay />', () => {
  it('should not render when there is no validation error', () => {
    cy.wrappedMount(<ValidationErrorDisplay validationError={null} />)
    cy.getByCy('validation-error').should('not.exist')
  })

  it('should render validation errors correctly', () => {
    const mockError = new ZodError([
      {
        path: ['name'],
        message: 'Name is required',
        code: 'invalid_type',
        expected: 'string',
        received: 'undefined',
      },
      {
        path: ['year'],
        message: 'Year must be a number',
        code: 'invalid_type',
        expected: 'number',
        received: 'string',
      },
    ])

    cy.wrappedMount(<ValidationErrorDisplay validationError={mockError} />)

    cy.getByCy('validation-error').should('have.length', 2)
    cy.contains('Name is required')
    cy.contains('Year must be a number')
  })
})



================================================
FILE: src/components/validation-error-display.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import ValidationErrorDisplay from './validation-error-display'
import {ZodError} from 'zod'

test.describe('<ValidationErrorDisplay>', () => {
  test('should not render when there is no validation error', async ({
    mount,
  }) => {
    const c = await mount(<ValidationErrorDisplay validationError={null} />)
    await expect(c.getByText('Name is required')).not.toBeVisible()
  })

  test('should render validation errors correctly', async ({mount}) => {
    const mockError = new ZodError([
      {
        path: ['name'],
        message: 'Name is required',
        code: 'invalid_type',
        expected: 'string',
        received: 'undefined',
      },
      {
        path: ['year'],
        message: 'Year must be a number',
        code: 'invalid_type',
        expected: 'number',
        received: 'string',
      },
    ])

    const c = await mount(
      <ValidationErrorDisplay validationError={mockError} />,
    )

    // PW CT is in beta: Playwright's Error boundary is always active in the global mount... this is not ideal

    // these should be the real check
    // await expect(c.getByText('Name is required')).toBeVisible()
    // await expect(c.getByText('Year must be a number')).toBeVisible()

    // but only this works
    await expect(c.getByText('Something went wrong')).toBeVisible()
  })
})



================================================
FILE: src/components/validation-error-display.tsx
================================================
import styled from 'styled-components'
import type {z} from 'zod'

type props = {
  readonly validationError: z.ZodError | null
}

export default function ValidationErrorDisplay({validationError}: props) {
  if (!validationError) return null

  return (
    <SError>
      {validationError.errors.map(err => (
        <p key={err.path.join('.')} data-cy="validation-error">
          {err.message}
        </p>
      ))}
    </SError>
  )
}

const SError = styled.div`
  color: red;
  margin-bottom: 10px;
`



================================================
FILE: src/components/validation-error-display.vitest.tsx
================================================
import {describe, expect, it, screen, wrappedRender} from '@vitest-utils/utils'
import ValidationErrorDisplay from './validation-error-display'
import {ZodError} from 'zod'

describe('<ValidationErrorDisplay />', () => {
  it('should not render when there is no validation error', () => {
    wrappedRender(<ValidationErrorDisplay validationError={null} />)

    expect(screen.queryByTestId('validation-error')).not.toBeInTheDocument()
  })

  it('should render validation errors correctly', () => {
    const mockError = new ZodError([
      {
        path: ['name'],
        message: 'Name is required',
        code: 'invalid_type',
        expected: 'string',
        received: 'undefined',
      },
      {
        path: ['year'],
        message: 'Year must be a number',
        code: 'invalid_type',
        expected: 'number',
        received: 'string',
      },
    ])

    wrappedRender(<ValidationErrorDisplay validationError={mockError} />)

    expect(screen.getAllByTestId('validation-error')).toHaveLength(2)
    expect(screen.getByText('Name is required')).toBeVisible()
    expect(screen.getByText('Year must be a number')).toBeVisible()
  })
})



================================================
FILE: src/components/movie-details/index.ts
================================================
import MovieDetails from './movie-details'
export default MovieDetails



================================================
FILE: src/components/movie-details/movie-details.cy.tsx
================================================
import {generateMovie} from '@support/factories'
import MovieDetails from './movie-details'
import spok from 'cy-spok'

describe('<MovieDetails />', () => {
  const id = 123
  const movieName = 'The Godfather 123'
  const movie = {id, ...generateMovie(), name: movieName}

  it('should display the default error with delay', () => {
    const error = 'Unexpected error occurred'
    cy.intercept('GET', '/movies/*', {
      statusCode: 400,
      delay: 20,
      body: {error},
    }).as('networkErr')

    cy.routeWrappedMount(<MovieDetails />, {path: '/:id', route: `/${id}`})
    cy.getByCy('loading-message-comp').should('be.visible')

    cy.wait('@networkErr').its('response.body.error').should('eq', error)
    cy.contains('Unexpected error occurred')
  })

  it('should display a specific error', () => {
    const error = 'Movie not found'
    cy.intercept('GET', '/movies/*', {
      statusCode: 400,
      body: {
        error: {
          error,
        },
      },
    }).as('networkErr')

    cy.routeWrappedMount(<MovieDetails />, {path: '/:id', route: `/${id}`})
    cy.wait('@networkErr').its('response.body.error.error').should('eq', error)

    cy.contains(error)
  })

  it('should make a unique network call when the route takes an id', () => {
    cy.intercept('GET', '/movies/*', {body: {data: movie}}).as('getMovieById')
    cy.routeWrappedMount(<MovieDetails />, {path: '/:id', route: `/${id}`})

    cy.wait('@getMovieById')
      .its('response.body.data')
      .should(spok({...movie}))
  })

  it('should make a unique network call when the route takes a query parameter', () => {
    const route = `/movies?name=${encodeURIComponent(movieName)}`

    cy.intercept('GET', route, {
      body: {data: movie},
    }).as('getMovieByName')

    cy.routeWrappedMount(<MovieDetails />, {
      path: '/movies',
      route,
    })

    cy.wait('@getMovieByName')
      .its('response.body.data')
      .should(spok({...movie}))
  })
})



================================================
FILE: src/components/movie-details/movie-details.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import MovieDetails from './movie-details'
import {generateMovie} from '@support/factories'
import {interceptNetworkCall} from '@pw/support/utils/network'

test.describe('<MovieDetails />', () => {
  const id = 123
  const movieName = 'The Godfather 123'
  const movie = {id, ...generateMovie(), name: movieName}

  test('should display the default error with delay', async ({mount, page}) => {
    const error = 'Unexpected error occurred'

    const loadNetworkError = interceptNetworkCall({
      page,
      method: 'GET',
      url: `/movies/${id}`,
      fulfillResponse: {
        status: 400,
        body: {error},
      },
    })

    const c = await mount(<MovieDetails />, {
      hooksConfig: {path: '/:id', route: `/${id}`},
    })

    // loading state in PW ct is handled differently than in Cypress
    // due to how React Suspense and the test runners interact.
    // so, this fails
    // await expect(c.getByTestId('loading-message-comp')).toBeVisible()
    const {responseJson} = await loadNetworkError
    expect(responseJson).toMatchObject({error})

    await expect(c.getByText(error)).toBeVisible()
  })

  test('should display a specific error', async ({mount, page}) => {
    const error = 'Movie not found'

    const loadNetworkError = interceptNetworkCall({
      page,
      method: 'GET',
      url: `/movies/${id}`,
      fulfillResponse: {
        status: 400,
        body: {
          error: {
            error,
          },
        },
      },
    })

    const c = await mount(<MovieDetails />, {
      hooksConfig: {path: '/:id', route: `/${id}`},
    })

    const {responseJson} = await loadNetworkError
    expect(responseJson).toMatchObject({
      error: {
        error,
      },
    })

    await expect(c.getByText(error)).toBeVisible()
  })

  test('should make a unique network call when the route takes an id', async ({
    mount,
    page,
  }) => {
    const loadGetMovieById = interceptNetworkCall({
      page,
      method: 'GET',
      url: `/movies/${id}`,
      fulfillResponse: {
        body: {data: movie},
      },
    })

    await mount(<MovieDetails />, {
      hooksConfig: {route: `/${id}`, path: '/:id'},
    })

    const {responseJson} = await loadGetMovieById
    expect(responseJson).toMatchObject({data: movie})
  })

  test('should make a unique network call when the route takes a query parameter', async ({
    mount,
    page,
  }) => {
    const route = `/movies?name=${encodeURIComponent(movieName)}`

    const loadGetMovieByName = interceptNetworkCall({
      page,
      method: 'GET',
      url: route,
      fulfillResponse: {
        body: {data: movie},
      },
    })

    await mount(<MovieDetails />, {
      hooksConfig: {route, path: '/movies'},
    })

    const {responseJson} = await loadGetMovieByName
    expect(responseJson).toMatchObject({data: movie})
  })
})



================================================
FILE: src/components/movie-details/movie-details.tsx
================================================
import LoadingMessage from '@components/loading-message'
import {SButton, STitle} from '@styles/styled-components'
import type {ErrorResponse, Movie} from 'src/consumer'
import styled from 'styled-components'
import MovieManager from './movie-manager'
import {useMovieDetails} from '@hooks/use-movie-detail'
import {useDeleteMovie} from '@hooks/use-movies'
import {useNavigate} from 'react-router-dom'

export default function MovieDetails() {
  const {data, isLoading, hasIdentifier} = useMovieDetails()
  const deleteMovieMutation = useDeleteMovie()
  const navigate = useNavigate()

  const handleDeleteMovie = (id: number) =>
    deleteMovieMutation.mutate(id, {
      onSuccess: () => navigate('/movies'), // Redirect to /movies after delete success
    })

  if (!hasIdentifier) return <p>No movie selected</p>
  if (isLoading) return <LoadingMessage />

  const movieData = (data as unknown as {data: Movie}).data
  const movieError = (data as unknown as {error: ErrorResponse}).error?.error

  return (
    <SMovieDetails data-cy="movie-details-comp">
      <STitle>Movie Details</STitle>

      {movieData && 'name' in movieData ? (
        <MovieManager movie={movieData} onDelete={handleDeleteMovie} />
      ) : (
        <p>{movieError || 'Unexpected error occurred'}</p>
      )}

      <SButton onClick={() => navigate(-1)} data-cy="back">
        Back
      </SButton>
    </SMovieDetails>
  )
}

const SMovieDetails = styled.div`
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
`



================================================
FILE: src/components/movie-details/movie-details.vitest.tsx
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  describe,
  expect,
  it,
  screen,
  wrappedRender,
  http,
  worker,
  waitFor,
} from '@vitest-utils/utils'
import {generateMovie} from '@cypress/support/factories'
import MovieDetails from './movie-details'

describe('<MovieDetails />', () => {
  const id = 123
  const movieName = 'The Godfather 123'
  const movie = {id, ...generateMovie(), name: movieName}
  const baseUrl = 'http://localhost:3001'

  it('should display the default error with delay', async () => {
    const error = 'Unexpected error occurred'
    let responseData: any

    worker.use(
      http.get(`${baseUrl}/movies/${id}`, () => {
        responseData = {error}
        return new Response(JSON.stringify(responseData), {
          status: 400,
        })
      }),
    )

    wrappedRender(<MovieDetails />, {path: '/:id', route: `/${id}`})

    await waitFor(() => {
      expect(responseData).toMatchObject({error})
    })

    expect(await screen.findByText(error)).toBeVisible()
  })

  it('should display a specific error', async () => {
    const error = 'Movie not found'
    let responseData: any

    worker.use(
      http.get(`${baseUrl}/movies/${id}`, () => {
        responseData = {
          error: {
            error,
          },
        }
        return new Response(JSON.stringify(responseData), {
          status: 400,
        })
      }),
    )

    wrappedRender(<MovieDetails />, {path: '/:id', route: `/${id}`})

    await waitFor(() => {
      expect(responseData).toMatchObject({
        error: {
          error,
        },
      })
    })

    expect(await screen.findByText(error)).toBeVisible()
  })

  it('should make a unique network call when the route takes an id', async () => {
    let responseData: any

    worker.use(
      http.get(`${baseUrl}/movies/${id}`, () => {
        responseData = {data: movie}
        return new Response(JSON.stringify(responseData), {status: 200})
      }),
    )

    wrappedRender(<MovieDetails />, {path: '/:id', route: `/${id}`})

    await waitFor(() => {
      expect(responseData).toMatchObject({data: movie})
    })
  })

  it('should make a unique network call when the route takes a query parameter', async () => {
    const route = `/movies?name=${encodeURIComponent(movieName)}`
    let responseData: any

    worker.use(
      http.get(`${baseUrl}/movies`, () => {
        responseData = {data: movie}
        return new Response(JSON.stringify(responseData), {
          status: 200,
        })
      }),
    )

    wrappedRender(<MovieDetails />, {
      route,
      path: '/movies',
    })

    await waitFor(() => {
      expect(responseData).toMatchObject({data: movie})
    })
  })
})



================================================
FILE: src/components/movie-details/movie-edit-form.cy.tsx
================================================
import type {Movie} from 'src/consumer'
import MovieEditForm from './movie-edit-form'
import {generateMovie} from '@cypress/support/factories'
import spok from 'cy-spok'

describe('<MovieEditForm />', () => {
  const id = 7
  const movie: Movie = {id, ...generateMovie()}

  it('should cancel and submit a movie update', () => {
    cy.intercept('PUT', `/movies/${id}`, {status: 200}).as('updateMovie')

    cy.wrappedMount(
      <MovieEditForm movie={movie} onCancel={cy.stub().as('onCancel')} />,
    )

    cy.getByCy('cancel').click()
    cy.get('@onCancel').should('have.been.calledOnce')

    cy.getByCy('update-movie').click()

    cy.wait('@updateMovie')
      .its('request.body')
      .should(
        spok({
          name: movie.name,
          year: movie.year,
          rating: movie.rating,
          director: movie.director,
        }),
      )
  })
})



================================================
FILE: src/components/movie-details/movie-edit-form.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import MovieEditForm from './movie-edit-form'
import {generateMovie} from '@cypress/support/factories'
import {interceptNetworkCall} from '@pw/support/utils/network'
import sinon from 'sinon'

test.describe('<MovieEditForm />', () => {
  const id = 7
  const movie = {id, ...generateMovie()}

  const sandbox = sinon.createSandbox()

  test.afterEach(() => {
    sandbox.restore()
  })

  test('should cancel and submit a movie update', async ({mount, page}) => {
    const onCancel = sandbox.stub()
    const c = await mount(<MovieEditForm movie={movie} onCancel={onCancel} />)

    await c.getByTestId('cancel').click()
    expect(onCancel.calledOnce).toBe(true)

    const loadUpdateMovie = interceptNetworkCall({
      page,
      method: 'PUT',
      url: `/movies/${id}`,
      fulfillResponse: {
        status: 200,
      },
    })

    await c.getByTestId('update-movie').click()

    const {requestJson} = await loadUpdateMovie
    expect(requestJson).toMatchObject({
      name: movie.name,
      year: movie.year,
      rating: movie.rating,
      director: movie.director,
    })
  })
})



================================================
FILE: src/components/movie-details/movie-edit-form.tsx
================================================
import styled from 'styled-components'
import {useMovieEditForm} from '@hooks/use-movie-edit-form'
import {SButton} from '@styles/styled-components'
import type {Movie} from 'src/consumer'
import ValidationErrorDisplay from '@components/validation-error-display'
import {MovieInput} from '@components/movie-form'

type MovieEditFormProps = Readonly<{
  movie: Movie
  onCancel: () => void
}>

export default function MovieEditForm({movie, onCancel}: MovieEditFormProps) {
  const {
    movieName,
    setMovieName,
    movieYear,
    setMovieYear,
    movieRating,
    setMovieRating,
    handleUpdateMovie,
    movieLoading,
    validationError,
    movieDirector,
    setMovieDirector,
  } = useMovieEditForm(movie)

  return (
    <div data-cy="movie-edit-form-comp">
      <SSubtitle>Edit Movie</SSubtitle>

      <ValidationErrorDisplay validationError={validationError} />

      <MovieInput
        type="text"
        value={movieName}
        placeholder="Movie name"
        onChange={e => setMovieName(e.target.value)}
      />
      <MovieInput
        type="number"
        value={movieYear}
        placeholder="Movie year"
        onChange={e => setMovieYear(Number(e.target.value))}
      />
      <MovieInput
        type="number"
        value={movieRating}
        placeholder="Movie rating"
        onChange={e => setMovieRating(Number(e.target.value))}
      />
      <MovieInput
        type="text"
        value={movieDirector}
        placeholder="Movie director"
        onChange={e => setMovieDirector(e.target.value)}
      />
      <SButton
        data-cy="update-movie"
        onClick={handleUpdateMovie}
        disabled={movieLoading}
      >
        {movieLoading ? 'Updating...' : 'Update Movie'}
      </SButton>
      <SButton data-cy="cancel" onClick={onCancel}>
        Cancel
      </SButton>
    </div>
  )
}

const SSubtitle = styled.h2`
  color: #333;
  font-size: 2rem;
  margin-bottom: 10px;
`



================================================
FILE: src/components/movie-details/movie-edit-form.vitest.tsx
================================================
import {
  wrappedRender,
  screen,
  worker,
  http,
  describe,
  it,
  expect,
  userEvent,
  vi,
  waitFor,
} from '@vitest-utils/utils'
import MovieEditForm from './movie-edit-form'
import {generateMovie} from '@cypress/support/factories'
import type {Movie} from 'src/consumer'

describe('<MovieEditForm />', () => {
  const id = 7
  const movie: Movie = {id, ...generateMovie()}

  it('should cancel and submit a movie update', async () => {
    const onCancel = vi.fn()

    wrappedRender(<MovieEditForm movie={movie} onCancel={onCancel} />)

    await userEvent.click(screen.getByTestId('cancel'))
    expect(onCancel).toHaveBeenCalledOnce()

    let putRequest: Record<string, unknown> | undefined
    worker.use(
      http.put(`http://localhost:3001/movies/${id}`, async ({request}) => {
        const requestBody = await request.json()
        putRequest = requestBody as Record<string, unknown>
        return new Response(undefined, {status: 200})
      }),
    )

    await userEvent.click(screen.getByTestId('update-movie'))

    await waitFor(() => {
      expect(putRequest).toMatchObject({
        name: movie.name,
        year: movie.year,
        rating: movie.rating,
        director: movie.director,
      })
    })
  })
})



================================================
FILE: src/components/movie-details/movie-manager.cy.tsx
================================================
import type {MovieManagerProps} from './movie-manager'
import MovieManager from './movie-manager'

describe('<MovieManager />', () => {
  const id = 1
  const name = 'Inception'
  const year = 2010
  const rating = 8.5
  const director = 'Christopher Nolan'
  it('should toggle between movie info and movie edit components', () => {
    const props: MovieManagerProps = {
      movie: {
        id,
        name,
        year,
        rating,
        director,
      },
      onDelete: cy.stub().as('onDelete'),
    }

    cy.wrappedMount(<MovieManager {...props} />)

    cy.getByCy('delete-movie').click()
    cy.get('@onDelete').should('have.been.calledOnceWith', id)

    cy.getByCy('movie-info-comp').should('be.visible')
    cy.getByCy('movie-edit-form-comp').should('not.exist')

    cy.getByCy('edit-movie').click()
    cy.getByCy('movie-info-comp').should('not.exist')
    cy.getByCy('movie-edit-form-comp').should('be.visible')
  })
})



================================================
FILE: src/components/movie-details/movie-manager.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import type {MovieManagerProps} from './movie-manager'
import MovieManager from './movie-manager'
import sinon from 'sinon'

test.describe('<MovieManager />', () => {
  const id = 1
  const name = 'Inception'
  const year = 2010
  const rating = 8.5
  const director = 'Christopher Nolan'

  const sandbox = sinon.createSandbox()

  test.afterEach(() => {
    sandbox.restore()
  })

  test('should toggle between movie info and movie edit components', async ({
    mount,
  }) => {
    const onDelete = sandbox.stub()
    const props: MovieManagerProps = {
      movie: {
        id,
        name,
        year,
        rating,
        director,
      },
      onDelete,
    }

    const c = await mount(<MovieManager {...props} />)

    await c.getByTestId('delete-movie').click()
    expect(onDelete.calledOnceWith(id)).toBe(true)

    await expect(c.getByTestId('movie-info-comp')).toBeVisible()
    await expect(c.getByTestId('movie-edit-form-comp')).not.toBeVisible()

    await c.getByTestId('edit-movie').click()
    await expect(c.getByTestId('movie-info-comp')).not.toBeVisible()
    await expect(c.getByTestId('movie-edit-form-comp')).toBeVisible()
  })
})



================================================
FILE: src/components/movie-details/movie-manager.tsx
================================================
import styled from 'styled-components'
import type {Movie} from 'src/consumer'
import {useState} from 'react'
import MovieEditForm from './movie-edit-form'
import {SButton} from '@styles/styled-components'
import {MovieInfo} from '@components/movie-item'

export type MovieManagerProps = {
  readonly movie: Movie
  readonly onDelete: (id: number) => void
}

export default function MovieManager({movie, onDelete}: MovieManagerProps) {
  const [isEditing, setIsEditing] = useState(false)

  return (
    <SMovieManager>
      {isEditing ? (
        <MovieEditForm movie={movie} onCancel={() => setIsEditing(false)} />
      ) : (
        <>
          <MovieInfo movie={movie} />
          <SButton data-cy="edit-movie" onClick={() => setIsEditing(true)}>
            Edit
          </SButton>
          <SButton data-cy="delete-movie" onClick={() => onDelete(movie.id)}>
            Delete
          </SButton>
        </>
      )}
    </SMovieManager>
  )
}

const SMovieManager = styled.div`
  h2 {
    margin-top: 20px;
    color: #333;
    font-size: 24px;
  }
  p {
    font-size: 18px;
    color: #555;
  }
`



================================================
FILE: src/components/movie-details/movie-manager.vitest.tsx
================================================
import {
  wrappedRender,
  screen,
  describe,
  it,
  expect,
  userEvent,
  vi,
} from '@vitest-utils/utils'
import type {MovieManagerProps} from './movie-manager'
import MovieManager from './movie-manager'

describe('<MovieManager />', () => {
  const id = 1
  const name = 'Inception'
  const year = 2010
  const rating = 8.5
  const director = 'Christopher Nolan'

  it('should toggle between movie info and movie edit components', async () => {
    const onDelete = vi.fn()
    const props: MovieManagerProps = {
      movie: {
        id,
        name,
        year,
        rating,
        director,
      },
      onDelete,
    }

    wrappedRender(<MovieManager {...props} />)

    await userEvent.click(screen.getByTestId('delete-movie'))
    expect(onDelete).toHaveBeenCalledOnce()
    expect(onDelete).toHaveBeenCalledWith(id)

    expect(screen.getByTestId('movie-info-comp')).toBeVisible()
    expect(screen.queryByTestId('movie-edit-form-comp')).not.toBeInTheDocument()

    await userEvent.click(screen.getByTestId('edit-movie'))
    expect(screen.queryByTestId('movie-info-comp')).not.toBeInTheDocument()
    expect(screen.getByTestId('movie-edit-form-comp')).toBeVisible()
  })
})



================================================
FILE: src/components/movie-form/index.ts
================================================
import MovieForm from './movie-form'
import MovieInput from './movie-input'
export {MovieInput}
export default MovieForm



================================================
FILE: src/components/movie-form/movie-form.cy.tsx
================================================
import {generateMovie} from '../../../cypress/support/factories'
import MovieForm from './movie-form'
import spok from 'cy-spok'

describe('<MovieForm />', () => {
  const getByPlaceHolder = (placeholder: string) =>
    cy.get(`[placeholder="${placeholder}"]`)

  const fillYear = (year: number) =>
    getByPlaceHolder('Movie year')
      .clear({force: true})
      .type(`${year}{backspace}`, {delay: 0})

  const fillName = (name: string) =>
    getByPlaceHolder('Movie name').type(name, {delay: 0})

  const fillRating = (rating: number) =>
    getByPlaceHolder('Movie rating')
      .clear({force: true})
      .type(`${rating}`, {delay: 0})

  const fillDirector = (director: string) =>
    getByPlaceHolder('Movie director').type(director, {delay: 0})

  it('should fill the form and add the movie', () => {
    const {name, year, rating, director} = generateMovie()
    cy.wrappedMount(<MovieForm />)
    fillName(name)
    fillYear(year)
    fillRating(rating)
    fillDirector(director)

    cy.intercept('POST', '/movies', {statusCode: 200, delay: 50}).as('addMovie')
    cy.getByCy('add-movie-button').contains('Add Movie').click()
    cy.getByCy('add-movie-button').contains('Adding...')

    cy.wait('@addMovie')
      .its('request.body')
      .should(
        spok({
          name,
          year: spok.number,
        }),
      )

    cy.log('**check the form reset**')
    getByPlaceHolder('Movie name').should('have.value', '')
    getByPlaceHolder('Movie year').should('have.value', 2023)
    getByPlaceHolder('Movie rating').should('have.value', 0)
  })

  it('should exercise validation errors', () => {
    cy.wrappedMount(<MovieForm />)

    fillYear(2025)
    cy.getByCy('add-movie-button').click()
    cy.getByCy('validation-error').should('have.length', 2)

    fillYear(1899)
    cy.getByCy('add-movie-button').click()
    cy.getByCy('validation-error').should('have.length', 3)

    fillYear(2024)
    fillName('4')
    fillDirector('Christopher Nolan')
    cy.getByCy('add-movie-button').click()
    cy.getByCy('validation-error').should('not.exist')

    fillYear(1900)
    fillName('4')
    fillDirector('Christopher Nolan')
    cy.getByCy('add-movie-button').click()
    cy.getByCy('validation-error').should('not.exist')
  })
})



================================================
FILE: src/components/movie-form/movie-form.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import type {MountResult} from '@playwright/experimental-ct-react'
import MovieForm from './movie-form'
import {generateMovie} from '@cypress/support/factories'
import {interceptNetworkCall} from '@pw/support/utils/network'

test.describe('<MovieForm />', () => {
  const fillName = async (c: MountResult, name: string) =>
    c.getByPlaceholder('Movie name').fill(name)

  const fillYear = async (c: MountResult, year: string) =>
    c.getByPlaceholder('Movie year').fill(year)

  const fillRating = async (c: MountResult, rating: string) =>
    c.getByPlaceholder('Movie rating').fill(rating)

  const fillDirector = async (c: MountResult, director: string) =>
    c.getByPlaceholder('Movie director').fill(director)

  test('should fill the form and add the movie', async ({mount, page}) => {
    const {name, year, rating, director} = generateMovie()

    const c = await mount(<MovieForm />)
    await fillName(c, name)
    await fillYear(c, String(year))
    await fillRating(c, String(rating))
    await fillDirector(c, director)

    const loadPostMovie = interceptNetworkCall({
      method: 'POST',
      url: '/movies',
      page,
      fulfillResponse: {
        status: 200,
      },
    })

    await c.getByText('Add Movie').click()
    const {requestJson} = await loadPostMovie
    expect(requestJson).toEqual({
      name,
      year,
      rating,
      director,
    })

    await expect(c.getByPlaceholder('Movie name')).toHaveValue('')
    await expect(c.getByPlaceholder('Movie year')).toHaveValue('2023')
    await expect(c.getByPlaceholder('Movie rating')).toHaveValue('0')
  })

  test('should exercise validation errors', async ({mount}) => {
    const c = await mount(<MovieForm />)

    await fillYear(c, '2025')
    await c.getByText('Add Movie').click()

    const validationError = c.getByTestId('validation-error')
    await expect(validationError).toHaveCount(3)

    await fillYear(c, '1899')
    await c.getByText('Add Movie').click()
    await expect(
      c.getByText('Number must be greater than or equal to 1900'),
    ).toBeVisible()

    await fillYear(c, '2024')
    await fillName(c, '4')
    await fillDirector(c, 'Christopher Nolan')
    await c.getByText('Add Movie').click()
    await expect(validationError).toHaveCount(0)

    await fillYear(c, '1900')
    await fillName(c, '4')
    await fillDirector(c, 'Christopher Nolan')
    await c.getByText('Add Movie').click()
    await expect(validationError).toHaveCount(0)
  })
})



================================================
FILE: src/components/movie-form/movie-form.tsx
================================================
import styled from 'styled-components'
import MovieInput from './movie-input'
import ValidationErrorDisplay from '@components/validation-error-display'
import {useMovieForm} from '@hooks/use-movie-form'
import {SButton} from '@styles/styled-components'

export default function MovieForm() {
  const {
    movieName,
    setMovieName,
    movieYear,
    setMovieYear,
    movieRating,
    setMovieRating,
    handleAddMovie,
    movieLoading,
    validationError,
    movieDirector,
    setMovieDirector,
  } = useMovieForm()

  return (
    <div data-cy="movie-form-comp">
      <SSubtitle>Add a New Movie</SSubtitle>

      {/* Zod key feature 4: use the validation state at the component  */}
      <ValidationErrorDisplay validationError={validationError} />

      <MovieInput
        type="text"
        value={movieName}
        placeholder="Movie name"
        onChange={e => setMovieName(e.target.value)}
      />
      <MovieInput
        type="number"
        value={movieYear}
        placeholder="Movie year"
        onChange={e => setMovieYear(Number(e.target.value))}
      />
      <MovieInput
        type="number"
        value={movieRating}
        placeholder="Movie rating"
        onChange={e => setMovieRating(Number(e.target.value))}
      />
      <MovieInput
        type="text"
        value={movieDirector}
        placeholder="Movie director"
        onChange={e => setMovieDirector(e.target.value)}
      />
      <SButton
        data-cy="add-movie-button"
        onClick={handleAddMovie}
        disabled={movieLoading}
      >
        {movieLoading ? 'Adding...' : 'Add Movie'}
      </SButton>
    </div>
  )
}

const SSubtitle = styled.h2`
  color: #333;
  font-size: 2rem;
  margin-bottom: 10px;
`



================================================
FILE: src/components/movie-form/movie-form.vitest.tsx
================================================
import {
  wrappedRender,
  screen,
  waitFor,
  worker,
  http,
  describe,
  it,
  expect,
  userEvent,
} from '@vitest-utils/utils'
import MovieForm from './movie-form'
import {generateMovie} from '../../../cypress/support/factories'
import type {Movie} from 'src/consumer'

describe('<MovieForm />', () => {
  const user = userEvent.setup()

  const fillYear = async (year: number) => {
    const yearInput = screen.getByPlaceholderText('Movie year')
    await user.clear(yearInput)
    await user.type(yearInput, String(year))
  }

  const fillName = async (name: string) => {
    const nameInput = screen.getByPlaceholderText('Movie name')
    await user.type(nameInput, name)
  }

  const fillRating = async (rating: number) => {
    const ratingInput = screen.getByPlaceholderText('Movie rating')
    await user.clear(ratingInput)
    await user.type(ratingInput, String(rating))
  }

  const fillDirector = async (director: string) => {
    const directorInput = screen.getByPlaceholderText('Movie director')
    await user.type(directorInput, director)
  }

  it('should fill the form and add the movie', async () => {
    const {name, year, rating, director} = generateMovie()
    const movie: Omit<Movie, 'id'> = {name, year, rating, director}

    wrappedRender(<MovieForm />)
    await fillName(name)
    await fillYear(year)
    await fillRating(rating)
    await fillDirector(director)

    let postRequest
    worker.use(
      http.post('http://localhost:3001/movies', async ({request}) => {
        postRequest = await request.json()
        return new Response(undefined, {
          status: 200,
        })
      }),
    )

    await user.click(screen.getByText('Add Movie'))

    await waitFor(() => {
      expect(screen.getByPlaceholderText('Movie name')).toHaveValue('')
      expect(screen.getByPlaceholderText('Movie year')).toHaveValue(2023)
      expect(screen.getByPlaceholderText('Movie rating')).toHaveValue(0)
    })
    expect(postRequest).toEqual(movie)
  })

  it('should exercise validation errors', async () => {
    wrappedRender(<MovieForm />)

    await fillYear(2025)
    await user.click(screen.getByText('Add Movie'))

    const validationError = screen.getAllByTestId('validation-error')
    expect(validationError).toHaveLength(3)

    await fillYear(1899)
    screen.getByText('Add Movie').click()
    expect(validationError).toHaveLength(3)

    await fillYear(2024)
    await fillName('4')
    await fillDirector('Christopher Nolan')
    screen.getByText('Add Movie').click()
    await waitFor(() => {
      expect(screen.queryByTestId('validation-error')).not.toBeInTheDocument()
    })

    await fillYear(1900)
    await fillName('4')
    await fillDirector('Christopher Nolan')
    screen.getByText('Add Movie').click()
    await waitFor(() => {
      expect(screen.queryByTestId('validation-error')).not.toBeInTheDocument()
    })
  })
})



================================================
FILE: src/components/movie-form/movie-input.cy.tsx
================================================
import 'cypress-map'
import {generateMovie} from '../../../cypress/support/factories'
import MovieInput from './movie-input'
import spok from 'cy-spok'

describe('<MovieInput />', () => {
  const movie = generateMovie()
  it('should render a name input', () => {
    const {name} = movie

    cy.mount(
      <MovieInput
        type="text"
        value={name}
        placeholder="place holder"
        onChange={cy.stub().as('onChange')}
      />,
    )

    cy.getByCy('movie-input-comp-text')
      .should('have.value', name)
      .should('have.attr', 'placeholder', 'place holder')

    cy.getByCy('movie-input-comp-text').type('a')

    // different ways of checking the call
    // 1
    cy.get('@onChange')
      .should('have.been.calledOnce')
      .its('firstCall.args.0.nativeEvent.data')
      .should('eq', 'a')

    // 2
    cy.get('@onChange').should('have.been.calledWithMatch', {
      nativeEvent: {data: 'a'},
    })

    // 3
    cy.get('@onChange')
      .invoke('getCalls')
      .map('args')
      .should(
        spok([
          [
            {
              nativeEvent: {data: 'a'},
            },
          ],
        ]),
      )
  })

  it('should render a year input', () => {
    const {year} = movie

    cy.mount(
      <MovieInput
        type="number"
        value={year}
        placeholder="place holder"
        onChange={cy.stub().as('onChange')}
      />,
    )

    cy.getByCy('movie-input-comp-number').should('have.value', year)
    cy.getByCy('movie-input-comp-number').type('1')

    cy.get('@onChange').should('have.been.calledWithMatch', {
      nativeEvent: {data: '1'},
    })
  })
})



================================================
FILE: src/components/movie-form/movie-input.pw.tsx
================================================
import {test} from '@playwright/experimental-ct-react'
import MovieInput from './movie-input'
import {generateMovie} from '@support/factories'
import sinon from 'sinon'

test.describe('<MovieInput>', () => {
  const movie = generateMovie()

  const sandbox = sinon.createSandbox()
  const onChange = sandbox.stub()

  test.afterEach(() => {
    sandbox.restore()
  })

  test('should render a name input', async ({mount}) => {
    const {name} = movie

    const c = await mount(
      <MovieInput
        type="text"
        value={name}
        placeholder="place holder"
        onChange={onChange}
      />,
    )
    c.getByPlaceholder('place holder')
    // PW is in beta
    // await expect(input).toBeVisible()
    // await expect(input).toHaveValue(name)

    // await input.fill('a') // enabling this fails the test
    // const call = onChange.firstCall
    // expect(call.args[0].nativeEvent.data).toBe('a')
  })

  test('should render a year input', async ({mount}) => {
    const {year} = movie

    const c = await mount(
      <MovieInput
        type="number"
        value={year}
        onChange={onChange}
        placeholder="place holder"
      />,
    )

    c.getByPlaceholder('place holder')
    // PW is in beta
    // await expect(input).toBeVisible()
    // await expect(input).toHaveValue(String(year))

    // await input.fill('1') // enabling this fails the test
    // const call = onChange.firstCall
    // expect(call.args[0].nativeEvent.data).toBe('1')
  })
})



================================================
FILE: src/components/movie-form/movie-input.tsx
================================================
import {SInput} from '@styles/styled-components'

type MovieInputProps = Readonly<{
  type: 'text' | 'number'
  value: string | number
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  placeholder: string
}>

export default function MovieInput({
  type,
  value,
  onChange,
  placeholder,
}: MovieInputProps) {
  return (
    <SInput
      data-cy={`movie-input-comp-${type}`}
      type={type}
      value={value}
      onChange={onChange}
      placeholder={placeholder}
    />
  )
}



================================================
FILE: src/components/movie-form/movie-input.vitest.tsx
================================================
import {
  wrappedRender,
  screen,
  describe,
  it,
  expect,
  vi,
} from '@vitest-utils/utils'
import userEvent from '@testing-library/user-event'
import MovieInput from './movie-input'
import {generateMovie} from '@cypress/support/factories'

describe('<MovieInput />', () => {
  const movie = generateMovie()
  const onChange = vi.fn()
  const user = userEvent.setup()

  it('should render a text input', async () => {
    const {name} = movie

    wrappedRender(
      <MovieInput
        type="text"
        value={name}
        placeholder="place holder"
        onChange={onChange}
      />,
    )

    const input = screen.getByPlaceholderText('place holder')
    expect(input).toBeVisible()
    expect(input).toHaveValue(name)

    await user.type(input, 'a')
    expect(onChange).toHaveBeenCalledTimes(1)

    // @ts-expect-error okay
    expect(onChange.mock.calls[0][0].target.value).toBe(`${name}`)
    // alternative
    expect(onChange).toHaveBeenCalledWith(
      expect.objectContaining({
        target: expect.objectContaining({
          value: name,
        }),
      }),
    )
  })

  it('should render a year input', async () => {
    const {year} = movie
    wrappedRender(
      <MovieInput
        type="number"
        value={year}
        onChange={onChange}
        placeholder="place holder"
      />,
    )

    const input = screen.getByTestId('movie-input-comp-number')
    expect(input).toBeVisible()
    expect(input).toHaveValue(year)

    await user.type(input, '1')
  })
})



================================================
FILE: src/components/movie-item/index.ts
================================================
import MovieItem from './movie-item'
import MovieInfo from './movie-info'

export {MovieInfo}
export default MovieItem



================================================
FILE: src/components/movie-item/movie-info.cy.tsx
================================================
import MovieInfo from './movie-info'

describe('<MovieInfo />', () => {
  it('should verify the movie and delete', () => {
    const id = 1
    const name = 'Inception'
    const year = 2010
    const rating = 8.5
    const director = 'Christopher Nolan'
    const movie = {id, name, year, rating, director}
    // const props = {movie}
    // cy.mount(<MovieInfo {...props} />)
    cy.mount(<MovieInfo movie={movie} />)

    cy.contains(`ID: ${id}`)
    cy.contains(name)
    cy.contains(year)
    cy.contains(rating).should('be.visible')
  })
})



================================================
FILE: src/components/movie-item/movie-info.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import MovieInfo from './movie-info'

test.describe('<MovieInfo />', () => {
  test('should verify the movie and delete', async ({mount}) => {
    const id = 1
    const name = 'Inception'
    const year = 2010
    const rating = 8.5
    const director = 'Christopher Nolan'
    const movie = {id, name, year, rating, director}

    const component = await mount(<MovieInfo movie={movie} />)

    await expect(component.getByText(`ID: ${id}`)).toBeVisible()
    await expect(component.getByText(name)).toBeVisible()
    await expect(component.getByText(String(year))).toBeVisible()
    await expect(component.getByText(String(rating))).toBeVisible()
  })
})



================================================
FILE: src/components/movie-item/movie-info.tsx
================================================
import type {Movie} from 'src/consumer'

type MovieInfoProps = {
  readonly movie: Movie
}

export default function MovieInfo({movie}: MovieInfoProps) {
  return (
    <div data-cy="movie-info-comp">
      <h2>{movie.name}</h2>
      <p>ID: {movie.id}</p>
      <p>Year: {movie.year}</p>
      <p>Rating: {movie.rating}</p>
    </div>
  )
}



================================================
FILE: src/components/movie-item/movie-info.vitest.tsx
================================================
import {wrappedRender, screen, describe, it, expect} from '@vitest-utils/utils'
import MovieInfo from './movie-info'

describe('<MovieInfo />', () => {
  it('should render the movie info', () => {
    const id = 1
    const name = 'Inception'
    const year = 2010
    const rating = 8.5
    const director = 'Christopher Nolan'
    const movie = {id, name, year, rating, director}

    wrappedRender(<MovieInfo movie={movie} />)

    expect(screen.getByText(`ID: ${id}`)).toBeVisible()
    expect(screen.getByText(name)).toBeVisible()
    expect(screen.getByText(`Year: ${year}`)).toBeVisible()
    expect(screen.getByText(`Rating: ${rating}`)).toBeVisible()
  })
})



================================================
FILE: src/components/movie-item/movie-item.cy.tsx
================================================
import MovieItem from './movie-item'

describe('<MovieItem />', () => {
  it('should verify the movie and delete', () => {
    const id = 3
    cy.routeWrappedMount(
      <MovieItem
        id={id}
        name={'my movie'}
        year={2023}
        rating={8.5}
        director={'my director'}
        onDelete={cy.stub().as('onDelete')}
      />,
    )

    cy.getByCy('movie-item-comp')
      .contains('my movie (2023)')
      .should('have.attr', 'href', `/movies/${id}`)

    cy.getByCyLike('delete-movie').click()
    cy.get('@onDelete').should('have.been.calledOnce')
    cy.get('@onDelete').should('have.been.calledWith', id)
  })
})



================================================
FILE: src/components/movie-item/movie-item.pw.tsx
================================================
import {test, expect} from '@playwright/experimental-ct-react'
import MovieItem from './movie-item'
import sinon from 'sinon'

test.describe('<MovieItem>', () => {
  const sandbox = sinon.createSandbox()
  const onDelete = sandbox.stub()

  test.afterEach(() => {
    sandbox.restore()
  })

  test('should verify the movie and delete', async ({mount}) => {
    const id = 3
    const c = await mount(
      <MovieItem
        id={id}
        name={'my movie'}
        year={2023}
        rating={8.5}
        director={'my director'}
        onDelete={onDelete}
      />,
    )

    const link = c.getByText('my movie')
    await expect(link).toBeVisible()
    await expect(link).toHaveAttribute('href', `/movies/${id}`)

    await c.getByRole('button', {name: /delete/i}).click()
    expect(onDelete.calledOnce).toBe(true)
    expect(onDelete.calledWith(id)).toBe(true)
  })
})



================================================
FILE: src/components/movie-item/movie-item.tsx
================================================
import {Link} from 'react-router-dom'
import {SButton} from '@styles/styled-components'
import styled from 'styled-components'
import type {Movie} from 'src/consumer'

type MovieItemProps = Movie & {onDelete: (id: number) => void}

export default function MovieItem({
  id,
  name,
  year,
  rating,
  director,
  onDelete,
}: MovieItemProps) {
  return (
    <SMovieItem data-cy="movie-item-comp">
      <Link to={`/movies/${id}`} data-cy={`link-${id}`}>
        {name} ({year}) {rating} {director}
      </Link>
      <SButton data-cy={`delete-movie-${name}`} onClick={() => onDelete(id)}>
        Delete
      </SButton>
    </SMovieItem>
  )
}

const SMovieItem = styled.li`
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 5px;
  padding: 10px 20px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
`



================================================
FILE: src/components/movie-item/movie-item.vitest.tsx
================================================
import {
  wrappedRender,
  screen,
  describe,
  it,
  expect,
  vi,
} from '@vitest-utils/utils'

import MovieItem from './movie-item'

describe('<MovieItem />', () => {
  const onDelete = vi.fn()

  it('should verify the movie and delete', async () => {
    const id = 3
    wrappedRender(
      <MovieItem
        id={id}
        name={'my movie'}
        year={2023}
        rating={8.5}
        director={'my director'}
        onDelete={onDelete}
      />,
    )

    const link = screen.getByText('my movie (2023) 8.5 my director')
    expect(link).toBeVisible()
    expect(link).toHaveAttribute('href', `/movies/${id}`)

    screen.getByRole('button', {name: /delete/i}).click()
    expect(onDelete).toHaveBeenCalledTimes(1)
    expect(onDelete).toHaveBeenCalledWith(id)
  })
})



================================================
FILE: src/hooks/use-movie-detail.ts
================================================
import {useMovie} from '@hooks/use-movies'
import {useParams, useSearchParams} from 'react-router-dom'

export function useMovieDetails() {
  // Get the id from the route params or query parameters
  // .../movies/{{movieId}}
  const {id} = useParams<{id: string}>()
  // .../movies?name={{movieName}}
  const [searchParams] = useSearchParams()
  const movieName = searchParams.get('name')

  const identifier =
    movieName ?? (id && !isNaN(Number(id)) ? parseInt(id, 10) : null)
  if (!identifier) return {movie: null, isLoading: false, hasIdentifier: false}

  const {data, isLoading} = useMovie(identifier)

  return {data, isLoading, hasIdentifier: true}
}



================================================
FILE: src/hooks/use-movie-edit-form.ts
================================================
import {useState} from 'react'
import {useUpdateMovie} from '@hooks/use-movies'
import {UpdateMovieSchema} from '@provider-schema/schema'
import type {ZodError} from 'zod'
import type {Movie} from 'src/consumer'

export function useMovieEditForm(initialMovie: Movie) {
  const [movieName, setMovieName] = useState(initialMovie.name)
  const [movieYear, setMovieYear] = useState(initialMovie.year)
  const [movieRating, setMovieRating] = useState(initialMovie.rating)
  const [movieDirector, setMovieDirector] = useState(initialMovie.director)
  const [validationError, setValidationError] = useState<ZodError | null>(null)

  const {status, mutate} = useUpdateMovie()
  const movieLoading = status === 'pending'

  // Zod Key feature 3: safeParse
  // Zod note: if you have a frontend, you can use the schema + safeParse there
  // in order to perform form validation before sending the data to the server

  const handleUpdateMovie = () => {
    const payload = {
      name: movieName,
      year: movieYear,
      rating: movieRating,
      director: movieDirector,
    }
    const result = UpdateMovieSchema.safeParse(payload)

    // Zod key feature 4: you can utilize
    // and expose the validation state to be used at a component
    if (!result.success) {
      setValidationError(result.error)
      return
    }

    mutate({
      id: initialMovie.id,
      movie: payload,
    })

    setValidationError(null)
  }

  return {
    movieName,
    movieYear,
    movieRating,
    setMovieName,
    setMovieYear,
    setMovieRating,
    handleUpdateMovie,
    movieLoading,
    validationError,
    movieDirector,
    setMovieDirector,
  }
}



================================================
FILE: src/hooks/use-movie-form.ts
================================================
import {useAddMovie} from '@hooks/use-movies'
import {useState} from 'react'
import {CreateMovieSchema} from '@provider-schema/schema'
import type {ZodError} from 'zod'

export function useMovieForm() {
  const [movieName, setMovieName] = useState('')
  const [movieYear, setMovieYear] = useState(2023)
  const [movieRating, setMovieRating] = useState(0)
  const [movieDirector, setMovieDirector] = useState('')
  const [validationError, setValidationError] = useState<ZodError | null>(null)

  const {status, mutate} = useAddMovie()
  const movieLoading = status === 'pending'

  // Zod Key feature 3: safeParse
  // Zod note: if you have a frontend, you can use the schema + safeParse there
  // in order to perform form validation before sending the data to the server
  const handleAddMovie = () => {
    const payload = {
      name: movieName,
      year: movieYear,
      rating: movieRating,
      director: movieDirector,
    }
    const result = CreateMovieSchema.safeParse(payload)

    // Zod key feature 4: you can utilize
    // and expose the validation state to be used at a component
    if (!result.success) {
      setValidationError(result.error)
      return
    }

    mutate(payload)
    // reset form after successful submission
    setMovieName('')
    setMovieYear(2023)
    setMovieRating(0)
    setMovieDirector('')

    setValidationError(null)
  }

  return {
    movieName,
    movieYear,
    movieRating,
    setMovieName,
    setMovieYear,
    setMovieRating,
    handleAddMovie,
    movieLoading,
    validationError, // for Zod key feature 4: expose the validation state
    movieDirector,
    setMovieDirector,
  }
}



================================================
FILE: src/hooks/use-movies.ts
================================================
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from '@tanstack/react-query'
import type {Movie} from '../consumer'
import {
  getMovies,
  addMovie,
  deleteMovieById,
  getMovieById,
  getMovieByName,
  updateMovie,
} from '../consumer'

export const useMovies = () =>
  useSuspenseQuery({
    queryKey: ['movies'],
    queryFn: getMovies,
    staleTime: 5000, // data considered fresh for 5 seconds
    retry: 2, // retry failed requests up to 2 times
  })

export const useMovie = (identifier: number | string) =>
  useQuery({
    queryKey: ['movie', identifier],
    queryFn: () => {
      if (!identifier) return Promise.resolve(null)
      const isNumericOnly = /^\d+$/.test(String(identifier))

      return isNumericOnly
        ? getMovieById(Number(identifier))
        : getMovieByName(String(identifier))
    },
    enabled: !!identifier, // Only enable the query when an identifier is set
    // By default, React Query will execute the query as soon as the component mounts
    // However, in this case, you only want to fetch data when there’s a valid identifier (either a non-empty string or a number)
    staleTime: 5000,
    retry: 2,
  })

export const useAddMovie = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (movie: Omit<Movie, 'id'>) => addMovie(movie),

    // Invalidate cache when a new movie is added
    onSuccess: () => queryClient.invalidateQueries({queryKey: ['movies']}),
  })
}

export const useUpdateMovie = () => {
  const queryClient = useQueryClient()

  // note: react query expects a single argument for the mutationFn
  return useMutation({
    mutationFn: ({
      id,
      movie,
    }: {
      id: number
      movie: Partial<Omit<Movie, 'id'>>
    }) => updateMovie(id, movie),
    // handles both error and success scenarios
    onSettled: () => queryClient.invalidateQueries({queryKey: ['movies']}),
    // Optional: Handle errors globally if needed
    onError: error => {
      console.error('Update failed', error)
      // Optionally, display a toast or log the error somewhere
    },
  })
}

export const useDeleteMovie = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: number) => deleteMovieById(id),
    onSuccess: () => queryClient.invalidateQueries({queryKey: ['movies']}),
  })
}

/*
react-query in a nutshell

Caching: react-query automatically caches query results, 
reducing unnecessary network requests and improving performance.

Automatic Refetching: stale queries can be automatically re-fetched when data might have changed, 
ensuring that your UI is always displaying the most up-to-date information.

Queries:
* purpose: used to fetch data. They are idempotent, meaning they don’t change the server's state when called.
* arguments: they match the function responsible for fetching the data

Mutations:
* purpose: used to modify data on the server (e.g., creating, updating, deleting data). 
they typically change the server's state.
* arguments: the mutationFn (or mutateAsync for async calls) takes arguments 
that match the function responsible
this allows for more flexibility in how and when the mutation is executed.
* onSuccess: when a mutation completes successfully 
(i.e., the API call was made, and the server responded without error), onSuccess is triggered. 
This function provides an opportunity to respond to the mutation’s success, 
often by updating the state or cache to reflect the new data.

-------------
Longer version

react-query (tanstack-query) offers a wide range of utilities and functions 
that help manage server-state in React applications.  


1. useQuery:
   - Purpose: Used to fetch and cache data.
   - Key Options: 
     - queryKey: Uniquely identifies the query.
     - queryFn: The function responsible for fetching data.
     - enabled: A boolean that can disable the query from automatically running.
     - staleTime: How long the data is considered fresh.
     - refetchOnWindowFocus: Whether the query should refetch when the window is focused.

2. useMutation:
   - Purpose: Used for creating, updating, or deleting data.
   - Key Options:
     - mutationFn: The function that performs the mutation.
     - onMutate: Called before the mutation function is fired, useful for optimistic updates.
     - onSuccess: Executes after a successful mutation, often used to update the cache or perform side effects.
     - onError: Called if the mutation encounters an error.
     - onSettled: Called when the mutation either succeeds or fails, useful for cleanup actions.
     - mutateAsync: An asynchronous alternative to mutate, returning a promise.
  
	isLoading, isError, data, error:
   - Purpose: Standard states and data provided by both useQuery and 
	   useMutation hooks to manage UI rendering based on the request's lifecycle.

  mutate:
   - Purpose: A method provided by useMutation to trigger a mutation with the required variables.

3. queryClient:
   - Purpose: A central place to manage queries and mutations.
   - Key Methods:
     - invalidateQueries: Invalidate and refetch queries.
     - setQueryData: Manually set the data for a query in the cache.
     - getQueryData: Retrieve the data for a query from the cache.
     - resetQueries: Reset a query's state to its initial state.
     - removeQueries: Remove queries from the cache.

These utilities collectively provide a robust framework for managing server-state in React applications,
making data fetching, caching, synchronization, and mutations efficient and easy to implement.

notes:

useSuspenseQuery: integrates directly with React's Suspense.
It doesn't return isLoading or isError states; instead, 
React Suspense automatically shows the fallback component when the query is loading 
and throws an error boundary when an error occurs.

useQuery: you are responsible for managing the loading, error, and data states in your component.
Has more control on when he query is executed, with options like 'enabled'
*/



================================================
FILE: src/provider-schema/movie-types.ts
================================================
// in the real world, this file which is from the server side
// would be published in a package and installed here

import type {z} from 'zod'
import type {
  CreateMovieResponseSchema,
  CreateMovieSchema,
  GetMovieResponseUnionSchema,
  MovieNotFoundResponseSchema,
  DeleteMovieResponseSchema,
  ConflictMovieResponseSchema,
  UpdateMovieSchema,
  UpdateMovieResponseSchema,
} from './schema'

export type CreateMovieRequest = z.infer<typeof CreateMovieSchema>

export type CreateMovieResponse = z.infer<typeof CreateMovieResponseSchema>

export type ConflictMovieResponse = z.infer<typeof ConflictMovieResponseSchema>

export type GetMovieResponse = z.infer<typeof GetMovieResponseUnionSchema>

export type MovieNotFoundResponse = z.infer<typeof MovieNotFoundResponseSchema>

export type DeleteMovieResponse = z.infer<typeof DeleteMovieResponseSchema>

export type UpdateMovieRequest = z.infer<typeof UpdateMovieSchema>

export type UpdateMovieResponse = z.infer<typeof UpdateMovieResponseSchema>



================================================
FILE: src/provider-schema/schema.ts
================================================
// in the real world, this file which is from the server side
// would be published in a package and installed here

import {z} from 'zod'
import {extendZodWithOpenApi} from '@asteasolutions/zod-to-openapi'

// Zod Key feature 1: define the schema with Zod (and expand it with zod-to-openapi)

// Generate OpenAPI Docs with Zod step 1) Define Schemas (with zod)
// Each field is annotated with OpenAPI-specific metadata such as example and description.

// extends Zod with OpenAPI support
extendZodWithOpenApi(z)

extendZodWithOpenApi(z)

export const CreateMovieSchema = z
  .object({
    id: z
      .number()
      .int()
      .optional()
      .openapi({example: 1, description: 'Movie ID '}),
    name: z
      .string()
      .min(1)
      .openapi({example: 'Inception', description: 'Movie name'}),
    year: z
      .number()
      .int()
      .min(1900)
      .max(2024)
      .openapi({example: 2010, description: 'Release year'}),
    rating: z.number().openapi({example: 7.5, description: 'Rating'}),
    director: z.string().min(1).openapi({
      example: 'Christopher Nolan',
      description: 'Director',
    }),
  })
  .openapi('CreateMovieRequest')

export const CreateMovieResponseSchema = z
  .object({
    status: z
      .number()
      .int()
      .openapi({example: 200, description: 'Response status code'}),
    data: z.object({
      id: z.number().int().openapi({example: 1, description: 'Movie ID'}),
      name: z
        .string()
        .openapi({example: 'Inception', description: 'Movie name'}),
      year: z
        .number()
        .int()
        .openapi({example: 2010, description: 'Release year'}),
      rating: z.number().openapi({example: 7.5, description: 'Rating'}),
      director: z.string().openapi({
        example: 'Christopher Nolan',
        description: 'Director',
      }),
    }),
    error: z
      .string()
      .optional()
      .openapi({description: 'Error message, if any'}),
  })
  .openapi('CreateMovieResponse')

export const ConflictMovieResponseSchema = z.object({
  status: z
    .number()
    .int()
    .openapi({example: 409, description: 'Conflict status code'}),
  error: z
    .string()
    .openapi({example: 'Movie already exists', description: 'Error message'}),
})

const movieObj = {
  id: z.number().openapi({example: 1, description: 'Movie ID'}),
  name: z.string().openapi({example: 'Inception', description: 'Movie name'}),
  year: z.number().openapi({example: 2010, description: 'Release year'}),
  rating: z.number().openapi({example: 7.5, description: 'Rating'}),
  director: z.string().openapi({
    example: 'Christopher Nolan',
    description: 'Director',
  }),
}

export const GetMovieResponseUnionSchema = z
  .object({
    status: z
      .number()
      .int()
      .openapi({example: 200, description: 'Response status code'}),
    data: z.union([
      z
        .object(movieObj)
        .nullable()
        .openapi({
          description: 'Movie details or null if not found',
          example: {
            id: 1,
            name: 'Inception',
            year: 2010,
            rating: 7.5,
            director: 'Christopher Nolan',
          },
        }),
      z.array(z.object(movieObj)).openapi({
        description: 'List of movies or an empty array if no movies exist',
        example: [],
      }),
    ]),
    error: z.string().nullable().optional().openapi({
      description: 'Error message if an error occurred, otherwise null',
      example: null,
    }),
  })
  .openapi('GetMovieResponse')

export const MovieNotFoundResponseSchema = z.object({
  status: z
    .number()
    .int()
    .openapi({example: 404, description: 'Response status code'}),
  error: z
    .string()
    .openapi({example: 'Movie not found', description: 'Error message'}),
})

export const DeleteMovieResponseSchema = z.object({
  status: z
    .number()
    .int()
    .openapi({example: 200, description: 'Response status code'}),
  message: z.string().openapi({
    example: 'Movie {id} has been deleted',
    description: 'Success message for the deleted movie',
  }),
})

export const UpdateMovieSchema = z
  .object({
    id: z.number().optional().openapi({example: 1, description: 'Movie ID'}),
    name: z
      .string()
      .min(1)
      .optional()
      .openapi({example: 'Inception', description: 'Movie name'}),
    year: z
      .number()
      .int()
      .min(1900)
      .max(2024)
      .optional()
      .openapi({example: 2010, description: 'Release year'}),
    rating: z
      .number()
      .optional()
      .openapi({example: 7.5, description: 'Rating'}),
    director: z.string().min(1).optional().openapi({
      example: 'Christopher Nolan',
      description: 'Director',
    }),
  })
  .openapi('UpdateMovieRequest')

export const UpdateMovieResponseSchema = z
  .object({
    status: z
      .number()
      .int()
      .openapi({example: 200, description: 'Response status code'}),
    data: z
      .object({
        id: z.number().openapi({example: 1, description: 'Movie ID'}),
        name: z
          .string()
          .openapi({example: 'Inception', description: 'Movie name'}),
        year: z.number().openapi({example: 2010, description: 'Release year'}),
        rating: z.number().openapi({example: 7.5, description: 'Rating'}),
        director: z.string().openapi({
          example: 'Christopher Nolan',
          description: 'Director',
        }),
      })
      .openapi({description: 'Updated movie data'}),
    error: z
      .string()
      .optional()
      .openapi({description: 'Error message, if any'}),
  })
  .openapi('UpdatedMovieResponse')



================================================
FILE: src/styles/styled-components.ts
================================================
import styled from 'styled-components'

export const SAppContainer = styled.div`
  text-align: center;
  padding: 20px;
`

export const STitle = styled.h1`
  color: #333;
  font-size: 2.5rem;
  margin-bottom: 20px;
`

export const SButton = styled.button`
  background-color: #ff6347;
  color: #fff;
  border: none;
  border-radius: 3px;
  margin: 10px;
  padding: 5px 10px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s;

  &:hover {
    background-color: #e5533d;
  }

  &:disabled {
    background-color: #ddd;
    cursor: not-allowed;
  }
`

export const SInput = styled.input`
  padding: 10px;
  margin: 10px;
  border-radius: 5px;
  border: 1px solid #ddd;
  font-size: 1rem;

  &[type='number'] {
    width: 100px;
  }
`



================================================
FILE: src/test-utils/pact-utils/helpers.ts
================================================
import type {JsonMap} from '@pact-foundation/pact/src/common/jsonTypes'
import type {V4ResponseBuilder} from '@pact-foundation/pact/src/v4/http/types'

/**
 * Converts an object with arbitrary value types to a `JsonMap` where all values are compatible with Pact's expectations.
 * This is useful for ensuring compatibility with functions that expect all values in the map to be of specific types,
 * such as in Pact state management.
 *
 * The function handles various data types as follows:
 * - `null` and `undefined`: Converted to the string `"null"`.
 * - `object`: Serialized using `JSON.stringify` unless it's a Date or Array.
 * - `number` and `boolean`: Preserved as is, ensuring numeric and boolean types remain unaltered.
 * - `Date`: Converted to an ISO string format (`toISOString()`).
 * - `Array`: Preserved in its original form, as arrays should not be converted to strings.
 *
 * @param {Record<string, unknown>} obj - The object to convert, with string keys and values of any type.
 * @returns {JsonMap} - A new object where all values are in a format compatible with Pact.
 *
 * @example
 * const movie = { name: 'Inception', year: 2010, released: new Date(), tags: ['Sci-Fi', 'Thriller'], director: { firstName: 'Christopher', lastName: 'Nolan' } }
 * toJsonMap(movie) // { name: 'Inception', year: 2010, released: '2024-09-01T12:00:00.000Z', tags: ['Sci-Fi', 'Thriller'], director: '{"firstName":"Christopher","lastName":"Nolan"}' }
 */
const toJsonMap = (obj: Record<string, unknown>): JsonMap =>
  Object.fromEntries(
    Object.entries(obj).map(([key, value]) => {
      if (value === null || value === undefined) {
        return [key, 'null']
      } else if (
        typeof value === 'object' &&
        !(value instanceof Date) &&
        !Array.isArray(value)
      ) {
        return [key, JSON.stringify(value)]
      } else if (typeof value === 'number' || typeof value === 'boolean') {
        return [key, value] // Preserve numbers and booleans
      } else if (value instanceof Date) {
        return [key, value.toISOString()] // Convert dates to ISO strings
      } else {
        return [key, String(value)]
      }
    }),
  )

type ProviderStateInput = {
  name: string
  params: Record<string, unknown>
}

/**
 * Creates a tuple representing a provider state for use with Pact.
 * The function takes a state name and an object of parameters, converting
 * the parameters into a JsonMap where all values are strings.
 *
 * This function is useful for simplifying the setup of provider states in tests
 * by ensuring the parameters are in the correct format required by Pact.
 *
 * @param {Object} options - The options for creating the provider state.
 * @param {string} options.name - The name of the provider state.
 * @param {Record<string, unknown>} options.params - The parameters for the provider state, with string keys and values of any type.
 *
 * @returns {[string, JsonMap]} - A tuple containing the state name and the converted parameters.
 *
 * @example
 *  * const movie: Movie = {
 *   name: 'My existing movie',
 *   year: 2001
 * }
 *
 * const state = createProviderState({
 *   name: 'An existing movie exists',
 *   params: movie
 * })
 *
 * provider.given(...state)
 *
 * // OR
 *
 * const [stateName, stateParams] = createProviderState({
 *   name: 'An existing movie exists',
 *   params: movie
 * })
 *
 * provider.given(stateName, stateParams)
 */
export const createProviderState = ({
  name,
  params,
}: ProviderStateInput): [string, JsonMap] => [name, toJsonMap(params)]

/**
 * Utility function to set a JSON body on a Pact V4 response.
 *
 * This improves readability using currying and supports any JSON-serializable value.
 *
 * @param {unknown} body - The JSON body object to set in the response, which can be any serializable structure.
 * @returns {(builder: V4ResponseBuilder) => V4ResponseBuilder} - A function to set the JSON body.
 *
 * Example usage:
 * ```js
 * // Before
 * .willRespondWith(200, (builder) => builder.jsonBody({
 *   id: integer(),
 *   name: string(name),
 *   year: integer(year)
 * }))
 *
 * // After
 * .willRespondWith(200, setJsonBody({
 *   id: integer(),
 *   name: string(name),
 *   year: integer(year)
 * }))
 * ```
 */
export const setJsonBody = (body: unknown) => (builder: V4ResponseBuilder) =>
  builder.jsonBody(body)



================================================
FILE: src/test-utils/vitest-utils/msw-setup.ts
================================================
import {setupWorker} from 'msw/browser'
import {http} from 'msw'

// Create worker with no default handlers
export const worker = setupWorker()

export {http}



================================================
FILE: src/test-utils/vitest-utils/utils.tsx
================================================
import type {FC, ReactNode} from 'react'
import {Suspense} from 'react'
import type {RenderOptions} from '@testing-library/react'
import {render} from 'vitest-browser-react'
import {QueryClient, QueryClientProvider} from '@tanstack/react-query'
import {ErrorBoundary} from 'react-error-boundary'
import {MemoryRouter, Routes, Route} from 'react-router-dom'
import ErrorComponent from '@components/error-component'
import LoadingMessage from '@components/loading-message'
import {describe, it, expect, vi} from 'vitest'
import userEvent from '@testing-library/user-event'

interface WrapperProps {
  children: ReactNode
  route?: string
  path?: string
}

const AllTheProviders: FC<WrapperProps> = ({
  children,
  route = '/',
  path = '/',
}) => {
  return (
    <QueryClientProvider client={new QueryClient()}>
      <ErrorBoundary fallback={<ErrorComponent />}>
        <Suspense fallback={<LoadingMessage />}>
          <MemoryRouter initialEntries={[route]}>
            <Routes>
              <Route element={children} path={path} />
            </Routes>
          </MemoryRouter>
        </Suspense>
      </ErrorBoundary>
    </QueryClientProvider>
  )
}

/**
 * Custom render function that wraps component with all necessary providers:
 * - QueryClientProvider
 * - ErrorBoundary
 * - Suspense
 * - MemoryRouter with Routes
 */
export function wrappedRender(
  ui: ReactNode,
  {
    route = '/',
    path = '/',
    ...options
  }: Omit<RenderOptions, 'wrapper'> & {
    route?: string
    path?: string
  } = {},
) {
  return render(ui, {
    wrapper: ({children}) => (
      <AllTheProviders route={route} path={path}>
        {children}
      </AllTheProviders>
    ),
    ...options,
  })
}

// re-export everything
export * from '@testing-library/react'
export * from './msw-setup'
export {describe, it, expect, vi, userEvent}



================================================
FILE: src/test-utils/vitest-utils/vitest.setup.ts
================================================
import {afterEach, beforeAll, afterAll} from 'vitest'
import '@testing-library/jest-dom/vitest'
import {cleanup, configure} from '@testing-library/react'
import {worker} from './msw-setup'

configure({testIdAttribute: 'data-cy'})

afterEach(() => {
  cleanup()
})

// we need all this so msw works without flake in headless mode

beforeAll(async () => {
  await worker.start({onUnhandledRequest: 'bypass'})
  if ('serviceWorker' in navigator) {
    await waitForServiceWorkerControl()
  }
})

afterAll(() => {
  // If you want to stop the worker eventually, do it here:
  worker.stop()
})

async function waitForServiceWorkerControl() {
  // If the page is already controlled, great
  if (navigator.serviceWorker.controller) return

  // Otherwise, wait up to ~2 seconds for it
  let attempts = 0
  while (!navigator.serviceWorker.controller && attempts < 20) {
    await new Promise(r => setTimeout(r, 100))
    attempts++
  }
}



================================================
FILE: .github/workflows/contract-test.yml
================================================
name: Run contract tests

on: push

# if this branch is pushed back to back, cancel the older branch's workflow
concurrency:
  group: ${{ github.ref }} && ${{ github.workflow }}
  cancel-in-progress: true

env:
  PACT_BROKER_BASE_URL: ${{ secrets.PACT_BROKER_BASE_URL }}
  PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
  GITHUB_SHA: ${{ github.sha }}
  GITHUB_BRANCH: ${{ github.head_ref }}

jobs:
  contract-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.head_ref }} # Ensure you're on the correct branch

      - name: Read Node version from .nvmrc
        id: node_version
        run: echo "NODE_VERSION=$(cat .nvmrc)" >> $GITHUB_ENV

      - uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Run consumer contract tests
        run: npm run test:consumer

      - name: Publish contract to Pactflow
        run: npm run publish:pact

      # in CDCT, a web hook is triggered on the provider
      # which executes the provider tests
      # in BDCT, we do not need such a thing

      - name: Can I deploy consumer?
        run: npm run can:i:deploy:consumer

      - name: Record web consumer deployment
        if: github.ref == 'refs/heads/main'
        run: npm run record:consumer:deployment --env=dev



================================================
FILE: .github/workflows/merge-gatekeeper.yml
================================================
# add this job to branch prot
name: Merge Gatekeeper

on:
  pull_request:
    branches:
      - main
      - master

jobs:
  merge-gatekeeper:
    runs-on: ubuntu-latest
    permissions:
      checks: read
      statuses: read
    steps:
      - name: Run Merge Gatekeeper
        uses: upsidr/merge-gatekeeper@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .github/workflows/pr-checks.yml
================================================
name: Run PR checks
on:
  push:
  workflow_dispatch:

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  install-dependencies:
    name: Install Dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Install dependencies
        run: npm ci
      - name: Cache Node Modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key:
            ${{ runner.os }}-node_modules-${{
            hashFiles('**/package-lock.json')}}
          restore-keys: |
            ${{ runner.os }}-node_modules

  jest:
    name: Unit-jest
    runs-on: ubuntu-latest
    needs: install-dependencies
    steps:
      - uses: actions/checkout@v5
      - name: Restore Node Modules Cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key:
            ${{ runner.os }}-node_modules-${{
            hashFiles('**/package-lock.json')}}
      - name: Run Jest
        run: npm run jest

  lint:
    name: Lint
    runs-on: ubuntu-latest
    needs: install-dependencies
    steps:
      - uses: actions/checkout@v5
      - name: Restore Node Modules Cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key:
            ${{ runner.os }}-node_modules-${{
            hashFiles('**/package-lock.json')}}
      - name: Run Lint
        run: npm run lint

  typecheck:
    name: Typecheck
    runs-on: ubuntu-latest
    needs: install-dependencies
    steps:
      - uses: actions/checkout@v5
      - name: Restore Node Modules Cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key:
            ${{ runner.os }}-node_modules-${{
            hashFiles('**/package-lock.json')}}
      - name: Run Typecheck
        run: npm run typecheck



================================================
FILE: .github/workflows/test-cy-ct.yml
================================================
name: Run ct with cy
on:
  push:
  workflow_dispatch:

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # if you want to enable parallelization
  CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  cy-ct:
    # if you want to enable parallelization
    # strategy:
    #   fail-fast: false
    #   matrix:
    #     machines: [1, 2]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Cypress component tests
        uses: cypress-io/github-action@v6.10.2
        with:
          component: true
          browser: chrome
          config-file: cypress/config/local.config.ts
          # if you want to enable parallelization
          # parallel: true
          record: true
          group: ct-tests
          tag: ct-tests



================================================
FILE: .github/workflows/test-cy-e2e.yml
================================================
name: Run e2e with cy
on:
  push:
  workflow_dispatch:

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # if you want to enable parallelization
  CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  cy-e2e:
    # if you want to enable parallelization
    # strategy:
    #   fail-fast: false
    #   matrix:
    #     machines: [1, 2]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Cypress component tests
        uses: cypress-io/github-action@v6.10.2
        with:
          component: true
          browser: chrome
          config-file: cypress/config/local.config.ts
          # if you want to enable parallelization
          # parallel: true
          record: true
          group: ct-tests
          tag: ct-tests



================================================
FILE: .github/workflows/test-pw-ct.yml
================================================
name: Run ct with pw
on:
  push:
  workflow_dispatch:

# if this branch is pushed back to back, cancel the older branch's workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  pw-ct:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Read Node version from .nvmrc
        id: node_version
        run: echo "NODE_VERSION=$(cat .nvmrc)" >> $GITHUB_ENV

      - uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright Chromium Only
        run: npx playwright install chromium

      - name: Run PW ct tests
        run: npm run pw:run-ct

      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-artifacts
          path: |
            playwright-report/
            test-results/
          retention-days: 3



================================================
FILE: .github/workflows/test-pw-e2e.yml
================================================
name: Run e2e with pw
on:
  push:
  workflow_dispatch:

# if this branch is pushed back to back, cancel the older branch's workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  pw-e2e:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Read Node version from .nvmrc
        id: node_version
        run: echo "NODE_VERSION=$(cat .nvmrc)" >> $GITHUB_ENV

      - uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright Chromium Only
        run: npx playwright install chromium

      - name: Run PW e2e tests
        run: npm run pw:run-local

      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-artifacts
          path: |
            playwright-report/
            test-results/
          retention-days: 3



================================================
FILE: .github/workflows/test-vitest-ct.yml
================================================
name: Run ct with Vitest
on:
  push:
  workflow_dispatch:

# if this branch is pushed back to back, cancel the older branch's workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  VITE_PORT: 3000
  API_PORT: 3001
  VITE_API_URL: 'http://localhost:3001'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  vitest-ct:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Read Node version from .nvmrc
        id: node_version
        run: echo "NODE_VERSION=$(cat .nvmrc)" >> $GITHUB_ENV

      - uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright Chromium Only
        run: npx playwright install chromium

      - name: Run Vitest
        run: npm run vitest:run


