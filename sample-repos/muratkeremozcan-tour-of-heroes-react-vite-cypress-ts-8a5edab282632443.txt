Directory structure:
└── muratkeremozcan-tour-of-heroes-react-vite-cypress-ts/
    ├── README.md
    ├── codecov.yml
    ├── cypress.config.ts
    ├── cypress.d.ts
    ├── db.json
    ├── index.html
    ├── jest.config.js
    ├── package.json
    ├── renovate.json
    ├── routes.json
    ├── tsconfig.json
    ├── vite.config.ts
    ├── .eslintignore
    ├── .eslintrc.js
    ├── .lintstagedrc
    ├── .nvmrc
    ├── .nycrc
    ├── .prettierignore
    ├── .prettierrc
    ├── cypress/
    │   ├── tsconfig.json
    │   ├── .eslintrc.js
    │   ├── e2e/
    │   │   ├── create-boy.cy.ts
    │   │   ├── create-hero.cy.ts
    │   │   ├── create-villain.cy.ts
    │   │   ├── delete-boy.cy.ts
    │   │   ├── delete-hero.cy.ts
    │   │   ├── delete-villain.cy.ts
    │   │   ├── edit-boy.cy.ts
    │   │   ├── edit-hero.cy.ts
    │   │   ├── edit-villain.cy.ts
    │   │   ├── routes-nav.cy.ts
    │   │   └── backend/
    │   │       └── crud.cy.ts
    │   ├── fixtures/
    │   │   ├── boys.json
    │   │   ├── db.json
    │   │   ├── heroes.json
    │   │   └── villains.json
    │   └── support/
    │       ├── commands.ts
    │       ├── component-index.html
    │       ├── component.tsx
    │       ├── e2e.ts
    │       ├── esbuild-preprocessor.ts
    │       ├── log.ts
    │       ├── plugins.ts
    │       └── tasks.ts
    ├── public/
    │   ├── index.html
    │   ├── manifest.json
    │   └── robots.txt
    ├── scripts/
    │   ├── reset-database.js
    │   ├── run_cyct_changed_tests.sh
    │   └── run_jest_changed_tests.sh
    ├── src/
    │   ├── About.tsx
    │   ├── App.css
    │   ├── App.cy.tsx
    │   ├── App.tsx
    │   ├── index.css
    │   ├── index.tsx
    │   ├── react-app-env.d.ts
    │   ├── reportWebVitals.ts
    │   ├── setupTests.ts
    │   ├── styles.scss
    │   ├── test-utils.tsx
    │   ├── tsconfig.json
    │   ├── api/
    │   │   └── api.ts
    │   ├── boys/
    │   │   ├── BoyDetail.cy.tsx
    │   │   ├── BoyDetail.test.tsx
    │   │   ├── BoyDetail.tsx
    │   │   ├── BoyList.cy.tsx
    │   │   ├── BoyList.test.tsx
    │   │   ├── BoyList.tsx
    │   │   ├── Boys.cy.tsx
    │   │   ├── Boys.test.tsx
    │   │   └── Boys.tsx
    │   ├── components/
    │   │   ├── ButtonFooter.cy.tsx
    │   │   ├── ButtonFooter.test.tsx
    │   │   ├── ButtonFooter.tsx
    │   │   ├── CardContent.cy.tsx
    │   │   ├── CardContent.test.tsx
    │   │   ├── CardContent.tsx
    │   │   ├── ErrorComp.cy.tsx
    │   │   ├── ErrorComp.test.tsx
    │   │   ├── ErrorComp.tsx
    │   │   ├── HeaderBar.cy.tsx
    │   │   ├── HeaderBar.test.tsx
    │   │   ├── HeaderBar.tsx
    │   │   ├── HeaderBarBrand.cy.tsx
    │   │   ├── HeaderBarBrand.test.tsx
    │   │   ├── HeaderBarBrand.tsx
    │   │   ├── InputDetail.cy.tsx
    │   │   ├── InputDetail.test.tsx
    │   │   ├── InputDetail.tsx
    │   │   ├── ListHeader.cy.tsx
    │   │   ├── ListHeader.test.tsx
    │   │   ├── ListHeader.tsx
    │   │   ├── Modal.tsx
    │   │   ├── ModalYesNo.cy.tsx
    │   │   ├── ModalYesNo.test.tsx
    │   │   ├── ModalYesNo.tsx
    │   │   ├── NavBar.cy.tsx
    │   │   ├── NavBar.test.tsx
    │   │   ├── NavBar.tsx
    │   │   ├── NotFound.cy.tsx
    │   │   ├── NotFound.test.tsx
    │   │   ├── NotFound.tsx
    │   │   ├── PageSpinner.cy.tsx
    │   │   ├── PageSpinner.test.tsx
    │   │   ├── PageSpinner.tsx
    │   │   ├── Spinner.cy.tsx
    │   │   ├── Spinner.test.tsx
    │   │   └── Spinner.tsx
    │   ├── heroes/
    │   │   ├── HeroDetail.cy.tsx
    │   │   ├── HeroDetail.test.tsx
    │   │   ├── HeroDetail.tsx
    │   │   ├── Heroes.cy.tsx
    │   │   ├── Heroes.test.tsx
    │   │   ├── Heroes.tsx
    │   │   ├── HeroList.cy.tsx
    │   │   ├── HeroList.test.tsx
    │   │   └── HeroList.tsx
    │   ├── hooks/
    │   │   ├── useDeleteEntity.ts
    │   │   ├── useEntityParams.ts
    │   │   ├── useGetEntities.ts
    │   │   ├── usePostEntity.ts
    │   │   ├── usePutEntity.ts
    │   │   └── useVillainsContext.ts
    │   ├── models/
    │   │   ├── Boy.ts
    │   │   ├── Hero.ts
    │   │   ├── types.ts
    │   │   └── Villain.ts
    │   └── villains/
    │       ├── VillainDetail.cy.tsx
    │       ├── VillainDetail.test.tsx
    │       ├── VillainDetail.tsx
    │       ├── VillainList.cy.tsx
    │       ├── VillainList.test.tsx
    │       ├── VillainList.tsx
    │       ├── Villains.cy.tsx
    │       ├── Villains.test.tsx
    │       └── Villains.tsx
    └── .github/
        └── workflows/
            ├── badges.yml
            ├── main.yml
            └── merge-gatekeeper.yml

================================================
FILE: README.md
================================================
[![unit-lint-typecheck-e2e-ct](https://github.com/muratkeremozcan/tour-of-heroes-react-vite-cypress-ts/actions/workflows/main.yml/badge.svg?branch=main)](https://github.com/muratkeremozcan/tour-of-heroes-react-vite-cypress-ts/actions/workflows/main.yml)

![react version](https://img.shields.io/badge/react-18.2.0-brightgreen)
![cypress version](https://img.shields.io/badge/cypress-13.14.1-brightgreen)
![typescript version](https://img.shields.io/badge/typescript-4.8.3-brightgreen)
![vite version](https://img.shields.io/badge/vite-4.5.3-brightgreen)
[![renovate-app badge][renovate-badge]][renovate-app]

[renovate-badge]: https://img.shields.io/badge/renovate-app-blue.svg
[renovate-app]: https://renovateapp.com/

Vite version of the application built in the book
[CCTDD: Cypress Component Test Driven Development](https://github.com/muratkeremozcan/cctdd).

The Webpack version of the application can be found
[here](https://github.com/muratkeremozcan/tour-of-heroes-react-cypress-ts).

```bash
# specify the registry in case you are using a proprietary registry
yarn install --registry https://registry.yarnpkg.com

# parallel unit, typecheck, lint, format
yarn validate

# no need to have server running for these:
yarn cy:open-ct # for cypress component test runner
yarn cy:run-ct # headless version

# runs the ui and api servers, then opens e2e runner
yarn cy:open-e2e
yarn cy:run-e2e  # headless version

yarn test # run unit tests with jest
```

## CI

```
build  -->  Cypress e2e test
       -->  Cypress component test
       -->  Typecheck
       -->  Lint
       -->  Unit test
```



================================================
FILE: codecov.yml
================================================
codecov:
  notify:
    after_n_builds: 5
coverage:
  status:
    project:
      default:
        target: auto
        # this allows a 1% drop from the previous base commit coverage
        threshold: 2%
  # makes it so that unit, cy ct and cy e2e reports finish running before the report is shown in a PAR
  # https://docs.codecov.com/docs/notifications#preventing-notifications-until-after-n-builds
  ignore:
    - 'src/setupTests.ts'
    - 'src/**/*.test.tsx'
    - 'src/**/*.cy.ts'
    - 'src/**/*.cy.tsx'
    - 'src/**/*.d.ts'
    - './src/models'
    - 'src/reportWebVitals.ts'



================================================
FILE: cypress.config.ts
================================================
import {defineConfig} from 'cypress'
import plugins from './cypress/support/plugins'
import tasks from './cypress/support/tasks'
import esbuildPreprocessor from './cypress/support/esbuild-preprocessor'
import viteConfig from './vite.config'
import {mergeConfig} from 'vite'
import {CypressEsm} from '@cypress/vite-plugin-cypress-esm'

export default defineConfig({
  projectId: 'x953wq',
  // @ts-expect-error - experimentalSingleTabRunMode is not in the type definition
  experimentalSingleTabRunMode: true,
  retries: {
    runMode: 2,
    openMode: 0,
  },
  env: {
    API_URL: 'http://localhost:4000/api',
    coverage: {
      quiet: true,
    },
  },
  e2e: {
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    baseUrl: 'http://localhost:3000',
    setupNodeEvents(on, config) {
      esbuildPreprocessor(on) // no need with vite
      tasks(on)
      return plugins(on, config)
    },
  },

  component: {
    experimentalJustInTimeCompile: true,
    setupNodeEvents(on, config) {
      tasks(on)
      return plugins(on, config)
    },
    specPattern: 'src/**/*.cy.{js,jsx,ts,tsx}',
    devServer: {
      framework: 'react',
      bundler: 'vite',
      viteConfig: () =>
        mergeConfig(viteConfig, {
          plugins: [
            CypressEsm({
              ignoreList: ['*react*'],
            }),
          ],
        }),
    },
  },
})



================================================
FILE: cypress.d.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import type {MountOptions, MountReturn} from 'cypress/react'
import type {HeroProperty, VillainProperty, EntityType} from 'models/types'
import type {Hero} from './models/types/Hero'
import type {Villain} from './models/types/Villain'
import type {Boy} from './models/types/Boy'
import 'vite/client'

export {}
declare global {
  namespace Cypress {
    interface Chainable {
      /** Yields elements with a data-cy attribute that matches a specified selector.
       * ```
       * cy.getByCy('search-toggle') // where the selector is [data-cy="search-toggle"]
       * ```
       */
      getByCy(qaSelector: string, args?: any): Chainable<JQuery<HTMLElement>>

      /** Yields elements with data-cy attribute that partially matches a specified selector.
       * ```
       * cy.getByCyLike('chat-button') // where the selector is [data-cy="chat-button-start-a-new-claim"]
       * ```
       */
      getByCyLike(
        qaSelector: string,
        args?: any,
      ): Chainable<JQuery<HTMLElement>>

      /** Yields the element that partially matches the css class
       * ```
       * cy.getByClassLike('StyledIconBase') // where the class is class="StyledIconBase-ea9ulj-0 lbJwfL"
       * ```
       */
      getByClassLike(
        qaSelector: string,
        args?: any,
      ): Chainable<JQuery<HTMLElement>>

      /** Mounts a React node
       * @param component React Node to mount
       * @param options Additional options to pass into mount
       */
      mount(
        component: React.ReactNode,
        options?: MountOptions,
      ): Cypress.Chainable<MountReturn>

      /** Mounts the component wrapped by all the providers:
       * QueryClientProvider, ErrorBoundary, Suspense, BrowserRouter
       * @param component React Node to mount
       * @param options Additional options to pass into mount
       */
      wrappedMount(
        component: React.ReactNode,
        options?: MountOptions,
      ): Cypress.Chainable<MountReturn>

      /** Visits heroes or villains routes, uses real network, verifies path */
      visitEntities(entityRoute: EntityRoute): Cypress.Chainable<string>

      /** Visits heroes or villains routes, uses stubbed network, verifies path */
      visitStubbedEntities(entityRoute: EntityRoute): Cypress.Chainable<string>

      /**
       * Gets an entity by name.
       * ```js
       * cy.getEntityByName(newHero.name).then(myHero => ...)
       * ```
       * @param name: Hero['name']
       */
      getEntityByProperty(
        entityType: EntityType,
        property: HeroProperty | VillainProperty,
      ): Cypress.Chainable<Hero | Villain | Boy>

      /**
       * Given a hero property (name, description or id),
       * returns the index of the hero, and the entire collection, as an object.
       */
      findEntityIndex(
        entityType: EntityType,
        property: HeroProperty,
      ): Cypress.Chainable<{
        entityIndex: number
        entityArray: Hero[] | Villain[] | Boy[]
      }>

      /**
       * Performs crud operations GET, POST, PUT and DELETE.
       *
       * `body` and `allowedToFail are optional.
       *
       * If they are not passed in, body is empty but `allowedToFail` still is `false`.
       *
       * If the body is passed in and the method is `POST` or `PUT`, the payload will be taken,
       * otherwise undefined for `GET` and `DELETE`.
       * @param method
       * @param route
       * @param options: {body?: Hero | object; allowedToFail?: boolean}
       */
      crud(
        method: 'GET' | 'POST' | 'PUT' | 'DELETE',
        route: string,
        {
          body,
          allowedToFail = false,
        }: {body?: Hero | object; allowedToFail?: boolean} = {},
      ): Cypress.Chainable<Response<Hero[] & Hero>>

      /**
       * Resets the data in the database to the initial data.
       */
      resetData(): Cypress.Chainable<
        Response<(Hero[] & Hero) | (Villain[] & Villain) | (Boy[] & Boy)>
      >
    }
  }
}



================================================
FILE: db.json
================================================
{
  "heroes": [
    {
      "id": "HeroAslaug",
      "name": "Aslaug",
      "description": "warrior queen"
    },
    {
      "id": "HeroBjorn",
      "name": "Bjorn Ironside",
      "description": "king of 9th century Sweden"
    },
    {
      "id": "HeroIvar",
      "name": "Ivar the Boneless",
      "description": "commander of the Great Heathen Army"
    },
    {
      "id": "HeroLagertha",
      "name": "Lagertha the Shieldmaiden",
      "description": "aka Hlaðgerðr"
    },
    {
      "id": "HeroRagnar",
      "name": "Ragnar Lothbrok",
      "description": "aka Ragnar Sigurdsson"
    },
    {
      "id": "HeroThora",
      "name": "Thora Town-hart",
      "description": "daughter of Earl Herrauðr of Götaland"
    }
  ],
  "villains": [
    {
      "id": "VillainMadelyn",
      "name": "Madelyn",
      "description": "the cat whisperer"
    },
    {
      "id": "VillainHaley",
      "name": "Haley",
      "description": "pen wielder"
    },
    {
      "id": "VillainElla",
      "name": "Ella",
      "description": "fashionista"
    },
    {
      "id": "VillainLandon",
      "name": "Landon",
      "description": "Mandalorian mauler"
    }
  ],
  "boys": [
    {
      "id": "BoyHomelander",
      "name": "Homelander",
      "description": "Like Superman, but a jerk."
    },
    {
      "id": "BoyAnnieJanuary",
      "name": "Annie January",
      "description": "The Defender of Des Moines."
    },
    {
      "id": "BoyBillyButcher",
      "name": "Billy Butcher",
      "description": "A former member of the British special forces turned vigilante."
    },
    {
      "id": "BoyBlackNoir",
      "name": "Black Noir",
      "description": "Master Martial Artist, expert hand-to-hand combatant highly trained in various forms of martial arts."
    }
  ]
}



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <!--
      Only files inside the `public` folder can be referenced from the HTML.

      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>



================================================
FILE: jest.config.js
================================================
/*
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

module.exports = {
  // All imported modules in your tests should be mocked automatically
  // automock: false,

  // Stop running tests after `n` failures
  // bail: 0,

  // The directory where Jest should store its cached dependency information
  // cacheDirectory: "/private/var/folders/c6/0v2tz0bs3fsgx30yln6fsj0m0000gq/T/jest_dz",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  collectCoverage: true,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  collectCoverageFrom: ['src/**/*.ts*', '!src/**/*.cy.ts*'],

  // The directory where Jest should output its coverage files
  coverageDirectory: 'coverage',

  // An array of regexp pattern strings used to skip coverage collection
  // coveragePathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // Indicates which provider should be used to instrument code for coverage
  // coverageProvider: "babel",

  // A list of reporter names that Jest uses when writing coverage reports
  // coverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // coverageThreshold: undefined,

  // A path to a custom dependency extractor
  // dependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

  // The default configuration for fake timers
  // fakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // forceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // globalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // globalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number.
  // E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // maxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  // moduleDirectories: [
  //   "node_modules"
  // ],

  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  moduleNameMapper: {
    '^components/(.*)$': '<rootDir>/src/components/$1',
    '^villains/(.*)$': '<rootDir>/src/villains/$1',
    '^boys/(.*)$': '<rootDir>/src/boys/$1',
    '^heroes/(.*)$': '<rootDir>/src/heroes/$1',
    '^hooks/(.*)$': '<rootDir>/src/hooks/$1',
    '^models/(.*)$': '<rootDir>/src/models/$1',
  },

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  // modulePathIgnorePatterns: [],

  // Activates notifications for test results
  // notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // notifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: 'ts-jest',

  // Run tests from one or more projects
  // projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  // reporters: undefined,

  // Automatically reset mock state before every test
  // resetMocks: false,

  // Reset the module registry before running each individual test
  // resetModules: false,

  // A path to a custom resolver
  // resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // restoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // rootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  roots: ['<rootDir>/src'],

  // Allows you to use a custom runner instead of Jest's default test runner
  // runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // setupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // slowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // snapshotSerializers: [],

  // The test environment that will be used for testing
  testEnvironment: 'jsdom',

  // Options that will be passed to the testEnvironment
  testEnvironmentOptions: {
    url: 'http://localhost',
  },

  // Adds a location field to test results
  // testLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  testPathIgnorePatterns: ['/node_modules/', '/cypress'],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // testRegex: [],

  // This option allows the use of a custom results processor
  // testResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // testRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  verbose: true,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // watchman: true,
}



================================================
FILE: package.json
================================================
{
  "name": "react-cypress-ts-template",
  "version": "0.1.0",
  "license": "UNLICENSED",
  "scripts": {
    "start": "vite",
    "start:api": "json-server --watch db.json --port 4000 --delay 1000 --routes routes.json --middlewares ./node_modules/json-server-reset",
    "dev": "concurrently -k yarn:start yarn:start:api",
    "build": "vite build",
    "test": "jest --watch",
    "test:coverage": "yarn test --watchAll=false --collectCoverageFrom=src/**/*.ts* --collectCoverageFrom=!src/**/*.*.ts* --coverage",
    "test:debug": "node --inspect-brk ./node_modules/jest/bin/jest.js --watch --runInBand",
    "format": "prettier --ignore-path .gitignore --write \"**/*.+(js|json|css|md|mdx|html)\"",
    "lint": "eslint . --cache-location node_modules/.cache/eslint --fix",
    "typecheck": "tsc --noEmit",
    "reset": "node ./scripts/reset-database.js",
    "reset:db": "npm run reset",
    "validate": "npm-run-all --parallel format lint typecheck build",
    "cy:open": "cypress open --e2e --browser chrome",
    "cy:run": "cypress run --e2e --browser chrome",
    "cy:open-e2e": "concurrently -k yarn:start:api 'server-test 3000 cy:open'",
    "cy:run-e2e": "concurrently -k yarn:start:api 'server-test 3000 cy:run'",
    "cy:open-ct": "cypress open --component --browser chrome",
    "cy:run-ct": "cypress run --component --browser chrome",
    "cy:run-ct-fast": "CYPRESS_NO_COMMAND_LOG=1 yarn cy:run-ct --config video=false screenshot=false",
    "cov:combined": "yarn copy:reports && yarn combine:reports && yarn finalize:combined-report",
    "copy:reports": "(mkdir reports || true) && cp coverage-cy/coverage-final.json reports/from-cypress.json && cp coverage/coverage-final.json reports/from-jest.json",
    "combine:reports": "(mkdir .nyc_output || true) && yarn nyc merge reports && mv coverage.json .nyc_output/out.json",
    "finalize:combined-report": "yarn nyc report --reporter html --reporter text --reporter json-summary --report-dir combined-coverage",
    "cov:reset": "rm -rf .nyc_output && rm -rf reports && rm -rf coverage && rm -rf coverage-cy && rm -rf combined-coverage",
    "cy:run-ct-changed": "chmod +x ./scripts/run_cyct_changed_tests.sh && ./scripts/run_cyct_changed_tests.sh",
    "test:jest-changed": "chmod +x ./scripts/run_jest_changed_tests.sh && ./scripts/run_jest_changed_tests.sh"
  },
  "dependencies": {
    "@vitejs/plugin-react": "3.1.0",
    "axios": "0.27.2",
    "bulma": "0.9.4",
    "json-server": "0.17.1",
    "ramda": "0.30.0",
    "ramda-adjunct": "5.0.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-error-boundary": "4.0.13",
    "react-icons": "5.2.1",
    "react-query": "3.39.3",
    "react-router-dom": "6.23.1",
    "sass": "^1.77.1",
    "vite": "4.5.3",
    "web-vitals": "3.5.2"
  },
  "devDependencies": {
    "@bahmutov/cypress-code-coverage": "2.6.1",
    "@bahmutov/cypress-esbuild-preprocessor": "2.2.5",
    "@cypress/vite-plugin-cypress-esm": "^1.0.0",
    "@faker-js/faker": "8.4.1",
    "@testing-library/cypress": "10.1.0",
    "@testing-library/dom": "10.0.0",
    "@testing-library/jest-dom": "6.4.2",
    "@testing-library/react": "14.1.2",
    "@testing-library/user-event": "14.5.2",
    "@types/jest": "29.5.12",
    "@types/node": "20.12.11",
    "@types/ramda": "0.30.0",
    "@types/react": "18.2.21",
    "@types/react-dom": "18.2.7",
    "@types/react-icons": "3.0.0",
    "@typescript-eslint/eslint-plugin": "7.8.0",
    "@typescript-eslint/parser": "7.8.0",
    "concurrently": "8.2.2",
    "cypress": "13.17.0",
    "esbuild": "0.21.2",
    "eslint": "8.57.0",
    "eslint-config-prettier": "9.1.0",
    "eslint-config-react-app": "7.0.1",
    "eslint-plugin-chai-friendly": "0.7.2",
    "eslint-plugin-cypress": "4.3.0",
    "eslint-plugin-no-only-tests": "3.1.0",
    "eslint-plugin-prettier": "4.2.1",
    "esbuild-plugin-polyfill-node": "0.3.0",
    "husky": "4.3.8",
    "istanbul": "0.4.5",
    "istanbul-lib-coverage": "3.2.2",
    "jest": "27.5.1",
    "jest-environment-jsdom": "27.5.1",
    "json-server-reset": "1.6.0",
    "lint-staged": "14.0.1",
    "msw": "0.47.2",
    "npm-run-all2": "6.1.2",
    "nyc": "15.1.0",
    "prettier": "2.8.8",
    "start-server-and-test": "2.0.3",
    "ts-jest": "27.1.4",
    "typescript": "4.8.3",
    "vite-plugin-environment": "1.1.3",
    "vite-plugin-istanbul": "6.0.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "yarn typecheck && yarn test --watchAll=false && yarn cy:run-ct-fast && lint-staged "
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



================================================
FILE: renovate.json
================================================
{
  "extends": ["config:base"],
  "automerge": true,
  "prHourlyLimit": 2,
  "updateNotScheduled": false,
  "timezone": "America/New_York",
  "schedule": ["after 10pm and before 5am on every weekday", "every weekend"],
  "masterIssue": true,
  "labels": ["type: dependencies", "renovate"],
  "dependencyDashboardApproval": false,
  "packageRules": [
    {
      "packagePatterns": ["*"],
      "excludePackagePatterns": ["cypress", "@cypress/code-coverage"],
      "enabled": false
    }
  ]
}



================================================
FILE: routes.json
================================================
{
  "/api/*": "/$1"
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": {
      "@cypress/*": ["../cypress/*"],
      "@support/*": ["../cypress/support/*"],
      "@fixtures/*": ["../cypress/fixtures/*"]
    },
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "types": ["cypress", "node", "@testing-library/cypress"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["./src", "cypress.d.ts"]
}



================================================
FILE: vite.config.ts
================================================
import {defineConfig} from 'vite'
import path from 'path'
import react from '@vitejs/plugin-react'
import istanbul from 'vite-plugin-istanbul' // cy code cov
import EnvironmentPlugin from 'vite-plugin-environment' // to be able to use process.env.

export default defineConfig({
  server: {port: 3000},
  build: {
    sourcemap: true,
  },
  plugins: [
    react(),
    istanbul({
      cypress: true,
      requireEnv: false,
    }),
    EnvironmentPlugin(['VITE_API_URL']),
  ],
  resolve: {
    alias: {
      components: path.resolve(__dirname, 'src', 'components'),
      villains: path.resolve(__dirname, 'src', 'villains'),
      boys: path.resolve(__dirname, 'src', 'boys'),
      heroes: path.resolve(__dirname, 'src', 'heroes'),
      hooks: path.resolve(__dirname, 'src', 'hooks'),
      models: path.resolve(__dirname, 'src', 'models'),
      '@support': path.resolve(__dirname, 'cypress', 'support'),
      '@fixtures': path.resolve(__dirname, 'cypress', 'fixtures'),
      '@cypress': path.resolve(__dirname, 'cypress'),
    },
  },
})



================================================
FILE: .eslintignore
================================================
node_modules
build
coverage
public
.docz
global


================================================
FILE: .eslintrc.js
================================================
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'chai-friendly', 'no-only-tests'],
  extends: [
    // 'react-app', // error: ESLint couldn't determine the plugin "@typescript-eslint" uniquely.
    'react-app/jest',
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  rules: {
    '@typescript-eslint/consistent-type-imports': 'error',
    'no-only-tests/no-only-tests': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-var-requires': 'off',
    'testing-library/no-render-in-setup': 'off',
  },
  env: {
    browser: true,
    amd: true,
    node: true,
  },
}



================================================
FILE: .lintstagedrc
================================================
{
  "*.+(js|jsx|ts|tsx)": [
    "eslint"
  ],
  "**/*.+(ts|js|tsx|jsx|json)": [
    "prettier --write",
    "git add"
  ]
}



================================================
FILE: .nvmrc
================================================
v18


================================================
FILE: .nycrc
================================================
{
  "all": true,
  "excludeAfterRemap": true,
  "report-dir": "coverage-cy",
  "reporter": ["text", "json", "html"],
  "extension": [".ts", ".tsx", "js", "jsx"],
  "include": ["src/**/*.tsx", "src/**/*.ts", "src/**/*.jsx", "src/**/*.js"],
  "exclude": [
    "src/setupTests.ts",
    "src/**/*.test.tsx",
    "src/**/*.cy.ts",
    "src/**/*.cy.tsx",
    "src/**/*.d.ts",
    "./src/models",
    "src/reportWebVitals.ts"
  ]
}



================================================
FILE: .prettierignore
================================================
node_modules
build
coverage
public
.docz



================================================
FILE: .prettierrc
================================================
{
  "arrowParens": "avoid",
  "bracketSpacing": false,
  "endOfLine": "lf",
  "htmlWhitespaceSensitivity": "css",
  "insertPragma": false,
  "jsxSingleQuote": false,
  "printWidth": 80,
  "proseWrap": "always",
  "quoteProps": "as-needed",
  "requirePragma": false,
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false
}



================================================
FILE: cypress/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["esnext", "dom"],
    "types": ["cypress", "node", "@testing-library/cypress"],
    "baseUrl": "./",
    "paths": {
      "@support/*": ["support/*"],
      "@fixtures/*": ["fixtures/*"]
    }
  },
  "include": ["**/*.ts*", "../cypress.d.ts"],
  "extends": "../tsconfig.json"
}



================================================
FILE: cypress/.eslintrc.js
================================================
module.exports = {
  plugins: ['eslint-plugin-cypress'],
  extends: ['react-app', 'plugin:cypress/recommended', 'react-app/jest'],
  env: {'cypress/globals': true},
  rules: {
    'cypress/unsafe-to-chain-command': 'off',
  },
}



================================================
FILE: cypress/e2e/create-boy.cy.ts
================================================
import {faker} from '@faker-js/faker'
describe('Create boy', () => {
  before(cy.resetData)

  const navToAddBoy = () => {
    cy.location('pathname').should('eq', '/boys')
    cy.getByCy('add-button').click()
    cy.location('pathname').should('eq', '/boys/add-boy')
    cy.getByCy('boy-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('not.exist')
  }

  it('should go through the refresh flow (ui-integration)', () => {
    cy.visitStubbedEntities('boys')
    navToAddBoy()

    cy.getByCy('refresh-button').click()
    cy.location('pathname').should('eq', '/boys')
    cy.getByCy('boy-list').should('be.visible')
  })

  it('should go through the cancel flow and perform direct navigation (ui-integration)', () => {
    cy.intercept('GET', `${Cypress.env('API_URL')}/boys`, {
      fixture: 'boys',
    }).as('stubbedGetBoys')
    cy.visit('/boys/add-boy')
    cy.wait('@stubbedGetBoys')

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/boys')
    cy.getByCy('boy-list').should('be.visible')
  })

  it('should go through the add boy flow (ui-e2e)', () => {
    cy.visitEntities('boys')
    navToAddBoy()

    const newBoy = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }
    cy.getByCy('input-detail-name').type(newBoy.name)
    cy.getByCy('input-detail-description').type(newBoy.description)
    cy.getByCy('save-button').click()

    cy.location('pathname').should('eq', '/boys')

    cy.getByCy('boys').should('be.visible')
    cy.getByCyLike('boy-list-item').should('have.length.gt', 0)
    cy.getByCy('boy-list')
      .should('contain', newBoy.name)
      .and('contain', newBoy.description)

    cy.getEntityByProperty('boy', newBoy.name).then(myBoy =>
      cy.crud('DELETE', `boys/${myBoy.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/create-hero.cy.ts
================================================
import {faker} from '@faker-js/faker'
describe('Create hero', () => {
  before(cy.resetData)

  const navToAddHero = () => {
    cy.location('pathname').should('eq', '/heroes')
    cy.getByCy('add-button').click()
    cy.location('pathname').should('eq', '/heroes/add-hero')
    cy.getByCy('hero-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('not.exist')
  }

  it('should go through the refresh flow (ui-integration)', () => {
    cy.visitStubbedEntities('heroes')
    navToAddHero()

    cy.getByCy('refresh-button').click()
    cy.location('pathname').should('eq', '/heroes')
    cy.getByCy('hero-list').should('be.visible')
  })

  it('should go through the cancel flow and perform direct navigation (ui-integration)', () => {
    cy.intercept('GET', `${Cypress.env('API_URL')}/heroes`, {
      fixture: 'heroes',
    }).as('stubbedGetHeroes')
    cy.visit('/heroes/add-hero')
    cy.wait('@stubbedGetHeroes')

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/heroes')
    cy.getByCy('hero-list').should('be.visible')
  })

  it('should go through the add hero flow (ui-e2e)', () => {
    cy.visitEntities('heroes')
    navToAddHero()

    const newHero = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }
    cy.getByCy('input-detail-name').type(newHero.name)
    cy.getByCy('input-detail-description').type(newHero.description)
    cy.getByCy('save-button').click()

    cy.location('pathname').should('eq', '/heroes')

    cy.getByCy('heroes').should('be.visible')
    cy.getByCyLike('hero-list-item').should('have.length.gt', 0)
    cy.getByCy('hero-list')
      .should('contain', newHero.name)
      .and('contain', newHero.description)

    cy.getEntityByProperty('hero', newHero.name).then(myHero =>
      cy.crud('DELETE', `heroes/${myHero.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/create-villain.cy.ts
================================================
import {faker} from '@faker-js/faker'
describe('Create villain', () => {
  before(cy.resetData)

  const navToAddVillain = () => {
    cy.location('pathname').should('eq', '/villains')
    cy.getByCy('add-button').click()
    cy.location('pathname').should('eq', '/villains/add-villain')
    cy.getByCy('villain-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('not.exist')
  }

  it('should go through the refresh flow (ui-integration)', () => {
    cy.visitStubbedEntities('villains')
    navToAddVillain()

    cy.getByCy('refresh-button').click()
    cy.location('pathname').should('eq', '/villains')
    cy.getByCy('villain-list').should('be.visible')
  })

  it('should go through the cancel flow and perform direct navigation (ui-integration)', () => {
    cy.intercept('GET', `${Cypress.env('API_URL')}/villains`, {
      fixture: 'villains',
    }).as('stubbedGetVillains')
    cy.visit('/villains/add-villain')
    cy.wait('@stubbedGetVillains')

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/villains')
    cy.getByCy('villain-list').should('be.visible')
  })

  it('should go through the add villain flow (ui-e2e)', () => {
    cy.visitEntities('villains')
    navToAddVillain()

    const newVillain = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }
    cy.getByCy('input-detail-name').type(newVillain.name)
    cy.getByCy('input-detail-description').type(newVillain.description)
    cy.getByCy('save-button').click()

    cy.location('pathname').should('eq', '/villains')

    cy.getByCy('villains').should('be.visible')
    cy.getByCyLike('villain-list-item').should('have.length.gt', 0)
    cy.getByCy('villain-list')
      .should('contain', newVillain.name)
      .and('contain', newVillain.description)

    cy.getEntityByProperty('villain', newVillain.name).then(myVillain =>
      cy.crud('DELETE', `villains/${myVillain.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/delete-boy.cy.ts
================================================
import {faker} from '@faker-js/faker'
import {Boy} from '../../src/models/Boy'
describe('Delete boy', () => {
  before(cy.resetData)

  const yesOnModal = () =>
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-yes').click())

  it('should go through the cancel flow (ui-integration)', () => {
    cy.visitStubbedEntities('boys')

    cy.getByCy('delete-button').first().click()
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-no').click())
    cy.getByCy('boys').should('be.visible')
    cy.get('modal-yes-no').should('not.exist')
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const boy: Boy = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'boys', {body: boy})

    cy.visitEntities('boys')

    cy.findEntityIndex('boy', boy.id).then(
      ({entityIndex: boyIndex, entityArray: boyArray}) => {
        cy.getByCy('delete-button').eq(boyIndex).click()

        yesOnModal()

        cy.getByCy('boy-list')
          .should('be.visible')
          .should('not.contain', boyArray[boyIndex].name)
          .and('not.contain', boyArray[boyIndex].description)
      },
    )
  })
})



================================================
FILE: cypress/e2e/delete-hero.cy.ts
================================================
import {faker} from '@faker-js/faker'
import {Hero} from '../../src/models/Hero'
describe('Delete hero', () => {
  before(cy.resetData)

  const yesOnModal = () =>
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-yes').click())

  it('should go through the cancel flow (ui-integration)', () => {
    cy.visitStubbedEntities('heroes')

    cy.getByCy('delete-button').first().click()
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-no').click())
    cy.getByCy('heroes').should('be.visible')
    cy.get('modal-yes-no').should('not.exist')
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const hero: Hero = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'heroes', {body: hero})

    cy.visitEntities('heroes')

    cy.findEntityIndex('hero', hero.id).then(
      ({entityIndex: heroIndex, entityArray: heroArray}) => {
        cy.getByCy('delete-button').eq(heroIndex).click()

        yesOnModal()

        cy.getByCy('hero-list')
          .should('be.visible')
          .should('not.contain', heroArray[heroIndex].name)
          .and('not.contain', heroArray[heroIndex].description)
      },
    )
  })
})



================================================
FILE: cypress/e2e/delete-villain.cy.ts
================================================
import {faker} from '@faker-js/faker'
import {Villain} from '../../src/models/Villain'
describe('Delete villain', () => {
  before(cy.resetData)

  const yesOnModal = () =>
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-yes').click())

  it('should go through the cancel flow (ui-integration)', () => {
    cy.visitStubbedEntities('villains')

    cy.getByCy('delete-button').first().click()
    cy.getByCy('modal-yes-no').within(() => cy.getByCy('button-no').click())
    cy.getByCy('villains').should('be.visible')
    cy.get('modal-yes-no').should('not.exist')
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const villain: Villain = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'villains', {body: villain})

    cy.visitEntities('villains')

    cy.findEntityIndex('villain', villain.id).then(
      ({entityIndex: villainIndex, entityArray: villainArray}) => {
        cy.getByCy('delete-button').eq(villainIndex).click()

        yesOnModal()

        cy.getByCy('villain-list')
          .should('be.visible')
          .should('not.contain', villainArray[villainIndex].name)
          .and('not.contain', villainArray[villainIndex].description)
      },
    )
  })
})



================================================
FILE: cypress/e2e/edit-boy.cy.ts
================================================
/* eslint-disable cypress/unsafe-to-chain-command */
import {faker} from '@faker-js/faker'
import {Boy} from '../../src/models/Boy'
import '@testing-library/cypress/add-commands'
describe('Edit boy', () => {
  before(cy.resetData)

  /** Verifies boy info on Edit page */
  const verifyBoy = (boys: Boy[], heroIndex: number) => {
    cy.location('pathname').should('include', '/boys/edit-boy/')
    cy.getByCy('boy-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('be.visible')
    cy.findByDisplayValue(boys[heroIndex].id)
    cy.findByDisplayValue(boys[heroIndex].name)
    cy.findByDisplayValue(boys[heroIndex].description)
  }

  const randomBoyIndex = (boys: Boy[]) => Cypress._.random(0, boys.length - 1)

  it('should go through the cancel flow for a random boy (ui-integration)', () => {
    cy.visitStubbedEntities('boys')

    cy.fixture('boys').then(boys => {
      const heroIndex = randomBoyIndex(boys)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyBoy(boys, heroIndex)
    })

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/boys')
    cy.getByCy('boy-list').should('be.visible')
  })

  it('should go through the PUT error flow (ui-integration)', () => {
    cy.visitStubbedEntities('boys')

    cy.fixture('boys').then(boys => {
      const heroIndex = randomBoyIndex(boys)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyBoy(boys, heroIndex)
    })

    cy.intercept('PUT', `${Cypress.env('API_URL')}/boys/*`, {
      statusCode: 500,
      delay: 100,
    }).as('isUpdateError')

    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@isUpdateError')
    cy.getByCy('error')
  })

  it('should navigate to add from an existing boy (ui-integration)', () => {
    cy.visitStubbedEntities('boys')

    cy.fixture('boys').then(boys => {
      const heroIndex = randomBoyIndex(boys)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyBoy(boys, heroIndex)

      cy.getByCy('add-button').click()
      cy.getByCy('input-detail-id').should('not.exist')
      cy.findByDisplayValue(boys[heroIndex].name).should('not.exist')
      cy.findByDisplayValue(boys[heroIndex].description).should('not.exist')
    })
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const newBoy: Boy = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'boys', {body: newBoy})

    cy.visit(`boys/edit-boy/${newBoy.id}`, {
      qs: {name: newBoy.name, description: newBoy.description},
    })

    const editedBoy = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.getByCy('input-detail-name')
      .find('.input')
      .clear()
      .type(`${editedBoy.name}`)
    cy.getByCy('input-detail-description')
      .find('.input')
      .clear()
      .type(`${editedBoy.description}`)
    cy.getByCy('save-button').click()

    cy.getByCy('boy-list')
      .should('be.visible')
      .should('contain', editedBoy.name)
      .and('contain', editedBoy.description)

    cy.getEntityByProperty('boy', newBoy.id).then((myBoy: Boy) =>
      cy.crud('DELETE', `boys/${myBoy.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/edit-hero.cy.ts
================================================
/* eslint-disable cypress/unsafe-to-chain-command */
import {faker} from '@faker-js/faker'
import {Hero} from '../../src/models/Hero'
import '@testing-library/cypress/add-commands'
describe('Edit hero', () => {
  before(cy.resetData)

  /** Verifies hero info on Edit page */
  const verifyHero = (heroes: Hero[], heroIndex: number) => {
    cy.location('pathname').should('include', '/heroes/edit-hero/')
    cy.getByCy('hero-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('be.visible')
    cy.findByDisplayValue(heroes[heroIndex].id)
    cy.findByDisplayValue(heroes[heroIndex].name)
    cy.findByDisplayValue(heroes[heroIndex].description)
  }

  const randomHeroIndex = (heroes: Hero[]) =>
    Cypress._.random(0, heroes.length - 1)

  it('should go through the cancel flow for a random hero (ui-integration)', () => {
    cy.visitStubbedEntities('heroes')

    cy.fixture('heroes').then(heroes => {
      const heroIndex = randomHeroIndex(heroes)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyHero(heroes, heroIndex)
    })

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/heroes')
    cy.getByCy('hero-list').should('be.visible')
  })

  it('should go through the PUT error flow (ui-integration)', () => {
    cy.visitStubbedEntities('heroes')

    cy.fixture('heroes').then(heroes => {
      const heroIndex = randomHeroIndex(heroes)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyHero(heroes, heroIndex)
    })

    cy.intercept('PUT', `${Cypress.env('API_URL')}/heroes/*`, {
      statusCode: 500,
      delay: 100,
    }).as('isUpdateError')

    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@isUpdateError')
    cy.getByCy('error')
  })

  it('should navigate to add from an existing hero (ui-integration)', () => {
    cy.visitStubbedEntities('heroes')

    cy.fixture('heroes').then(heroes => {
      const heroIndex = randomHeroIndex(heroes)
      cy.getByCy('edit-button').eq(heroIndex).click()
      verifyHero(heroes, heroIndex)

      cy.getByCy('add-button').click()
      cy.getByCy('input-detail-id').should('not.exist')
      cy.findByDisplayValue(heroes[heroIndex].name).should('not.exist')
      cy.findByDisplayValue(heroes[heroIndex].description).should('not.exist')
    })
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const newHero: Hero = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'heroes', {body: newHero})

    cy.visit(`heroes/edit-hero/${newHero.id}`, {
      qs: {name: newHero.name, description: newHero.description},
    })

    const editedHero = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.getByCy('input-detail-name')
      .find('.input')
      .clear()
      .type(`${editedHero.name}`)
    cy.getByCy('input-detail-description')
      .find('.input')
      .clear()
      .type(`${editedHero.description}`)
    cy.getByCy('save-button').click()

    cy.getByCy('hero-list')
      .should('be.visible')
      .should('contain', editedHero.name)
      .and('contain', editedHero.description)

    cy.getEntityByProperty('hero', newHero.id).then((myHero: Hero) =>
      cy.crud('DELETE', `heroes/${myHero.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/edit-villain.cy.ts
================================================
/* eslint-disable cypress/unsafe-to-chain-command */
import {faker} from '@faker-js/faker'
import {Villain} from '../../src/models/Villain'
import '@testing-library/cypress/add-commands'
describe('Edit villain', () => {
  before(cy.resetData)

  /** Verifies villain info on Edit page */
  const verifyVillain = (villains: Villain[], villainIndex: number) => {
    cy.location('pathname').should('include', '/villains/edit-villain/')
    cy.getByCy('villain-detail').should('be.visible')
    cy.getByCy('input-detail-id').should('be.visible')
    cy.findByDisplayValue(villains[villainIndex].id)
    cy.findByDisplayValue(villains[villainIndex].name)
    cy.findByDisplayValue(villains[villainIndex].description)
  }

  const randomVillainIndex = (villains: Villain[]) =>
    Cypress._.random(0, villains.length - 1)

  it('should go through the cancel flow for a random villain (ui-integration)', () => {
    cy.visitStubbedEntities('villains')

    cy.fixture('villains').then(villains => {
      const villainIndex = randomVillainIndex(villains)
      cy.getByCy('edit-button').eq(villainIndex).click()
      verifyVillain(villains, villainIndex)
    })

    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/villains')
    cy.getByCy('villain-list').should('be.visible')
  })

  it('should go through the PUT error flow (ui-integration)', () => {
    cy.visitStubbedEntities('villains')

    cy.fixture('villains').then(villains => {
      const villainIndex = randomVillainIndex(villains)
      cy.getByCy('edit-button').eq(villainIndex).click()
      verifyVillain(villains, villainIndex)
    })

    cy.intercept('PUT', `${Cypress.env('API_URL')}/villains/*`, {
      statusCode: 500,
      delay: 100,
    }).as('isUpdateError')

    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@isUpdateError')
    cy.getByCy('error')
  })

  it('should navigate to add from an existing villain (ui-integration)', () => {
    cy.visitStubbedEntities('villains')

    cy.fixture('villains').then(villains => {
      const villainIndex = randomVillainIndex(villains)
      cy.getByCy('edit-button').eq(villainIndex).click()
      verifyVillain(villains, villainIndex)

      cy.getByCy('add-button').click()
      cy.getByCy('input-detail-id').should('not.exist')
      cy.findByDisplayValue(villains[villainIndex].name).should('not.exist')
      cy.findByDisplayValue(villains[villainIndex].description).should(
        'not.exist',
      )
    })
  })

  it('should go through the edit flow (ui-e2e)', () => {
    const newVillain: Villain = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'villains', {body: newVillain})

    cy.visit(`villains/edit-villain/${newVillain.id}`, {
      qs: {name: newVillain.name, description: newVillain.description},
    })

    const editedVillain = {
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.getByCy('input-detail-name')
      .find('.input')
      .clear()
      .type(`${editedVillain.name}`)
    cy.getByCy('input-detail-description')
      .find('.input')
      .clear()
      .type(`${editedVillain.description}`)
    cy.getByCy('save-button').click()

    cy.getByCy('villain-list')
      .should('be.visible')
      .should('contain', editedVillain.name)
      .and('contain', editedVillain.description)

    cy.getEntityByProperty('villain', newVillain.id).then(
      (myVillain: Villain) => cy.crud('DELETE', `villains/${myVillain.id}`),
    )
  })
})



================================================
FILE: cypress/e2e/routes-nav.cy.ts
================================================
describe('routes navigation (ui-integration)', () => {
  beforeEach(() => {
    cy.intercept('GET', `${Cypress.env('API_URL')}/heroes`, {
      fixture: 'heroes',
    }).as('stubbedGetHeroes')
  })
  it('should land on baseUrl, redirect to /heroes', () => {
    cy.visit('/')
    cy.getByCy('header-bar').should('be.visible')
    cy.getByCy('nav-bar').should('be.visible')

    cy.location('pathname').should('eq', '/heroes')
    cy.getByCy('heroes').should('be.visible')
  })

  it('should direct-navigate to /heroes', () => {
    const route = '/heroes'
    cy.visit(route)
    cy.location('pathname').should('eq', route)
    cy.getByCy('heroes').should('be.visible')
  })

  it('should direct-navigate to /villains', () => {
    const route = '/villains'
    cy.visit(route)
    cy.location('pathname').should('eq', route)
    cy.getByCy('villains').should('be.visible')
  })

  it('should land on not found when visiting an non-existing route', () => {
    const route = '/route48'
    cy.visit(route)
    cy.location('pathname').should('eq', route)
    cy.getByCy('not-found').should('be.visible')
  })

  it('should direct-navigate to about', () => {
    const route = '/about'
    cy.visit(route)
    cy.location('pathname').should('eq', route)
    cy.getByCy('about').contains('CCTDD')
  })

  it('should cover route history with browser back and forward', () => {
    cy.visit('/about')
    const routes = ['villains', 'heroes', 'about']
    cy.wrap(routes).each((route: string) =>
      cy.get(`[href="/${route}"]`).click(),
    )

    const lastIndex = routes.length - 1
    cy.location('pathname').should('include', routes[lastIndex])
    cy.go('back')
    cy.location('pathname').should('include', routes[lastIndex - 1])
    cy.go('back')
    cy.location('pathname').should('include', routes[lastIndex - 2])
    cy.go('forward').go('forward')
    cy.location('pathname').should('include', routes[lastIndex])
  })
})



================================================
FILE: cypress/e2e/backend/crud.cy.ts
================================================
import {faker} from '@faker-js/faker'
import {Hero} from '../../../src/models/Hero'
import {Villain} from '../../../src/models/Villain'
import {Boy} from '../../../src/models/Boy'

describe('Backend e2e', () => {
  const assertProperties = (entity: Hero | Villain | Boy) => {
    expect(entity.id).to.be.a('string')
    expect(entity.name).to.be.a('string')
    expect(entity.description).to.be.a('string')
  }

  before(() => cy.resetData())

  it('should GET heroes and villains ', () => {
    cy.crud('GET', 'heroes')
      .its('body')
      .should('have.length.gt', 0)
      .each(assertProperties)

    cy.crud('GET', 'villains')
      .its('body')
      .should('have.length.gt', 0)
      .each(assertProperties)
  })

  it('should CRUD a new hero entity', () => {
    const newHero = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'heroes', {body: newHero}).its('status').should('eq', 201)

    cy.crud('GET', 'heroes')
      .its('body')
      .then(body => {
        expect(body.at(-1)).to.deep.eq(newHero)
      })

    const editedHero = {...newHero, name: 'Murat'}
    cy.crud('PUT', `heroes/${editedHero.id}`, {body: editedHero})
      .its('status')
      .should('eq', 200)
    cy.crud('GET', `heroes/${editedHero.id}`)
      .its('body')
      .should('deep.eq', editedHero)

    cy.crud('DELETE', `heroes/${editedHero.id}`).its('status').should('eq', 200)
    cy.crud('GET', `heroes/${editedHero.id}`, {allowedToFail: true})
      .its('status')
      .should('eq', 404)
  })

  it('should CRUD a new villain entity', () => {
    const newVillain = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'villains', {body: newVillain})
      .its('status')
      .should('eq', 201)

    cy.crud('GET', 'villains')
      .its('body')
      .then(body => {
        expect(body.at(-1)).to.deep.eq(newVillain)
      })

    const editedVillain = {...newVillain, name: 'Murat'}
    cy.crud('PUT', `villains/${editedVillain.id}`, {body: editedVillain})
      .its('status')
      .should('eq', 200)
    cy.crud('GET', `villains/${editedVillain.id}`)
      .its('body')
      .should('deep.eq', editedVillain)

    cy.crud('DELETE', `villains/${editedVillain.id}`)
      .its('status')
      .should('eq', 200)
    cy.crud('GET', `villains/${editedVillain.id}`, {allowedToFail: true})
      .its('status')
      .should('eq', 404)
  })

  it('should CRUD a new boy entity', () => {
    const newVillain = {
      id: faker.datatype.uuid(),
      name: faker.internet.userName(),
      description: `description ${faker.internet.userName()}`,
    }

    cy.crud('POST', 'boys', {body: newVillain}).its('status').should('eq', 201)

    cy.crud('GET', 'boys')
      .its('body')
      .then(body => {
        expect(body.at(-1)).to.deep.eq(newVillain)
      })

    const editedVillain = {...newVillain, name: 'Murat'}
    cy.crud('PUT', `boys/${editedVillain.id}`, {body: editedVillain})
      .its('status')
      .should('eq', 200)
    cy.crud('GET', `boys/${editedVillain.id}`)
      .its('body')
      .should('deep.eq', editedVillain)

    cy.crud('DELETE', `boys/${editedVillain.id}`)
      .its('status')
      .should('eq', 200)
    cy.crud('GET', `boys/${editedVillain.id}`, {allowedToFail: true})
      .its('status')
      .should('eq', 404)
  })
})



================================================
FILE: cypress/fixtures/boys.json
================================================
[
  {
    "id": "BoyHomelander",
    "name": "Homelander",
    "description": "Like Superman, but a jerk."
  },
  {
    "id": "BoyAnnieJanuary",
    "name": "Annie January",
    "description": "The Defender of Des Moines."
  },
  {
    "id": "BoyBillyButcher",
    "name": "Billy Butcher",
    "description": "A former member of the British special forces turned vigilante."
  },
  {
    "id": "BoyBlackNoir",
    "name": "Black Noir",
    "description": "Master Martial Artist, expert hand-to-hand combatant highly trained in various forms of martial arts."
  }
]



================================================
FILE: cypress/fixtures/db.json
================================================
{
  "heroes": [
    {
      "id": "HeroAslaug",
      "name": "Aslaug",
      "description": "warrior queen"
    },
    {
      "id": "HeroBjorn",
      "name": "Bjorn Ironside",
      "description": "king of 9th century Sweden"
    },
    {
      "id": "HeroIvar",
      "name": "Ivar the Boneless",
      "description": "commander of the Great Heathen Army"
    },
    {
      "id": "HeroLagertha",
      "name": "Lagertha the Shieldmaiden",
      "description": "aka Hlaðgerðr"
    },
    {
      "id": "HeroRagnar",
      "name": "Ragnar Lothbrok",
      "description": "aka Ragnar Sigurdsson"
    },
    {
      "id": "HeroThora",
      "name": "Thora Town-hart",
      "description": "daughter of Earl Herrauðr of Götaland"
    }
  ],
  "villains": [
    {
      "id": "VillainMadelyn",
      "name": "Madelyn",
      "description": "the cat whisperer"
    },
    {
      "id": "VillainHaley",
      "name": "Haley",
      "description": "pen wielder"
    },
    {
      "id": "VillainElla",
      "name": "Ella",
      "description": "fashionista"
    },
    {
      "id": "VillainLandon",
      "name": "Landon",
      "description": "Mandalorian mauler"
    }
  ],
  "boys": [
    {
      "id": "BoyHomelander",
      "name": "Homelander",
      "description": "Like Superman, but a jerk."
    },
    {
      "id": "BoyAnnieJanuary",
      "name": "Annie January",
      "description": "The Defender of Des Moines."
    },
    {
      "id": "BoyBillyButcher",
      "name": "Billy Butcher",
      "description": "A former member of the British special forces turned vigilante."
    },
    {
      "id": "BoyBlackNoir",
      "name": "Black Noir",
      "description": "Master Martial Artist, expert hand-to-hand combatant highly trained in various forms of martial arts."
    }
  ]
}



================================================
FILE: cypress/fixtures/heroes.json
================================================
[
  {
    "id": "HeroAslaug",
    "name": "Aslaug",
    "description": "warrior queen"
  },
  {
    "id": "HeroBjorn",
    "name": "Bjorn Ironside",
    "description": "king of 9th century Sweden"
  },
  {
    "id": "HeroIvar",
    "name": "Ivar the Boneless",
    "description": "commander of the Great Heathen Army"
  },
  {
    "id": "HeroLagertha",
    "name": "Lagertha the Shieldmaiden",
    "description": "aka Hlaðgerðr"
  },
  {
    "id": "HeroRagnar",
    "name": "Ragnar Lothbrok",
    "description": "aka Ragnar Sigurdsson"
  },
  {
    "id": "HeroThora",
    "name": "Thora Town-hart",
    "description": "daughter of Earl Herrauðr of Götaland"
  }
]



================================================
FILE: cypress/fixtures/villains.json
================================================
[
  {
    "id": "VillainMadelyn",
    "name": "Madelyn",
    "description": "the cat whisperer"
  },
  {
    "id": "VillainHaley",
    "name": "Haley",
    "description": "pen wielder"
  },
  {
    "id": "VillainElla",
    "name": "Ella",
    "description": "fashionista"
  },
  {
    "id": "VillainLandon",
    "name": "Landon",
    "description": "Mandalorian mauler"
  }
]



================================================
FILE: cypress/support/commands.ts
================================================
// put e2e + CT common commands here
// import '@testing-library/cypress/add-commands' // better to import plugins where relevant, speeds up test warmup
import '@bahmutov/cypress-code-coverage/support'

Cypress.Commands.add('getByCy', (selector, ...args) =>
  cy.get(`[data-cy="${selector}"]`, ...args),
)

Cypress.Commands.add('getByCyLike', (selector, ...args) =>
  cy.get(`[data-cy*=${selector}]`, ...args),
)

Cypress.Commands.add('getByClassLike', (selector, ...args) =>
  cy.get(`[class*=${selector}]`, ...args),
)

/* istanbul ignore file */



================================================
FILE: cypress/support/component-index.html
================================================
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Components App</title>
    <script>
      if (window.parent !== window) {
        window['__REACT_DEVTOOLS_GLOBAL_HOOK__'] =
          window.parent['__REACT_DEVTOOLS_GLOBAL_HOOK__']
      }
    </script>
  </head>

  <body>
    <div data-cy-root></div>
  </body>
</html>



================================================
FILE: cypress/support/component.tsx
================================================
// put CT-only commands here

import './commands'
import {mount} from 'cypress/react18'
import {BrowserRouter} from 'react-router-dom'
import {QueryClient, QueryClientProvider} from 'react-query'
import {ErrorBoundary} from 'react-error-boundary'
import ErrorComp from '../../src/components/ErrorComp'
import PageSpinner from '../../src/components/PageSpinner'
import {Suspense} from 'react'
import '../../src/styles.scss' // import styles here so you don't have to import everywhere

Cypress.Commands.add('mount', mount)

Cypress.Commands.add(
  'wrappedMount',
  (WrappedComponent: React.ReactNode, options = {}) => {
    const wrapped = (
      <QueryClientProvider client={new QueryClient()}>
        <ErrorBoundary fallback={<ErrorComp />}>
          <Suspense fallback={<PageSpinner />}>
            <BrowserRouter>{WrappedComponent}</BrowserRouter>
          </Suspense>
        </ErrorBoundary>
      </QueryClientProvider>
    )
    return cy.mount(wrapped, options)
  },
)

/* istanbul ignore file */



================================================
FILE: cypress/support/e2e.ts
================================================
// put e2e only commands and plugins here

import './commands'
import {Villain} from './../../src/models/Villain'
import {Hero} from '../../src/models/Hero'
import {Boy} from '../../src/models/Boy'
import {
  entityRoute,
  EntityRoute,
  EntityType,
  HeroProperty,
  VillainProperty,
  BoyProperty,
} from '../../src/models/types'
import data from '../fixtures/db.json'

Cypress.Commands.add(
  'crud',
  (
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    route: string,
    {
      body,
      allowedToFail = false,
    }: {body?: Hero | Villain | Boy | object; allowedToFail?: boolean} = {},
  ) =>
    cy.request<(Hero[] & Hero) | (Villain[] & Villain) | (Boy[] & Boy)>({
      method: method,
      url: `${Cypress.env('API_URL')}/${route}`,
      body: method === 'POST' || method === 'PUT' ? body : undefined,
      retryOnStatusCodeFailure: !allowedToFail,
      failOnStatusCode: !allowedToFail,
    }),
)

Cypress.Commands.add('resetData', () => cy.crud('POST', 'reset', {body: data}))

const {_} = Cypress

const propExists =
  (property: HeroProperty | VillainProperty | BoyProperty) =>
  (entity: Hero | Villain | Boy) =>
    entity.name === property ||
    entity.description === property ||
    entity.id === property

const getEntities = (entityRoute: EntityRoute) =>
  cy.crud('GET', entityRoute).its('body')

Cypress.Commands.add(
  'getEntityByProperty',
  (
    entityType: EntityType,
    property: HeroProperty | VillainProperty | BoyProperty,
  ) =>
    getEntities(entityRoute(entityType)).then(entities =>
      _.find(entities, propExists(property)),
    ),
)

Cypress.Commands.add(
  'findEntityIndex',
  (
    entityType: EntityType,
    property: HeroProperty | VillainProperty | BoyProperty,
  ) =>
    getEntities(entityRoute(entityType)).then(
      (body: Hero[] | Villain[] | Boy[]) => ({
        entityIndex: _.findIndex(body, propExists(property)),
        entityArray: body,
      }),
    ),
)

Cypress.Commands.add('visitStubbedEntities', (entityRoute: EntityRoute) => {
  cy.intercept('GET', `${Cypress.env('API_URL')}/${entityRoute}`, {
    fixture: `${entityRoute}.json`,
  }).as(`stubbed${_.startCase(entityRoute)}`)
  cy.visit(`/${entityRoute}`)
  cy.wait(`@stubbed${_.startCase(entityRoute)}`)
  return cy.location('pathname').should('eq', `/${entityRoute}`)
})

Cypress.Commands.add('visitEntities', (entityRoute: EntityRoute) => {
  cy.intercept('GET', `${Cypress.env('API_URL')}/${entityRoute}`).as(
    `get${_.startCase(entityRoute)}`,
  )
  cy.visit(`/${entityRoute}`)
  cy.wait(`@get${_.startCase(entityRoute)}`)
  return cy.location('pathname').should('eq', `/${entityRoute}`)
})



================================================
FILE: cypress/support/esbuild-preprocessor.ts
================================================
import createBundler from '@bahmutov/cypress-esbuild-preprocessor'
import {polyfillNode} from 'esbuild-plugin-polyfill-node'

/**
 * The collection of tasks to use with `cy.task()`
 * @param on `on` is used to hook into various events Cypress emits
 */
export default function tasks(on: Cypress.PluginEvents): void {
  on(
    'file:preprocessor',
    createBundler({
      plugins: [polyfillNode()],
    }),
  )
}



================================================
FILE: cypress/support/log.ts
================================================
// an example task that logs to the CLI console
// cy.task('log', 'e2e sanity passed')

const log = (x: string) => {
  console.log(x)

  return null
}

export default log



================================================
FILE: cypress/support/plugins.ts
================================================
const cyCodeCov = require('@bahmutov/cypress-code-coverage/plugin')

/**
 * The collection of plugins to use with Cypress
 * @param on  `on` is used to hook into various events Cypress emits
 * @param config  `config` is the resolved Cypress config
 */
export default function plugins(
  on: Cypress.PluginEvents,
  config: Cypress.PluginConfigOptions,
) {
  return {
    // add plugins here
    // ...cyDataSession(on, config), // example
    ...cyCodeCov(on, config),
  }
}



================================================
FILE: cypress/support/tasks.ts
================================================
import log from './log'

/**
 * The collection of tasks to use with `cy.task()`
 * @param on `on` is used to hook into various events Cypress emits
 */
export default function tasks(on: Cypress.PluginEvents) {
  on('task', {log})

  // add tasks here
}



================================================
FILE: public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>



================================================
FILE: public/manifest.json
================================================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}



================================================
FILE: public/robots.txt
================================================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:



================================================
FILE: scripts/reset-database.js
================================================
const path = require('path')
const write = require('fs').writeFileSync

const filename = path.join(__dirname, '..', 'db.json')

const resetDatabase = () => {
  // overwrite the data file
  const db = {
    heroes: [
      {
        id: 'HeroAslaug',
        name: 'Aslaug',
        description: 'warrior queen',
      },
      {
        id: 'HeroBjorn',
        name: 'Bjorn Ironside',
        description: 'king of 9th century Sweden',
      },
      {
        id: 'HeroIvar',
        name: 'Ivar the Boneless',
        description: 'commander of the Great Heathen Army',
      },
      {
        id: 'HeroLagertha',
        name: 'Lagertha the Shieldmaiden',
        description: 'aka Hlaðgerðr',
      },
      {
        id: 'HeroRagnar',
        name: 'Ragnar Lothbrok',
        description: 'aka Ragnar Sigurdsson',
      },
      {
        id: 'HeroThora',
        name: 'Thora Town-hart',
        description: 'daughter of Earl Herrauðr of Götaland',
      },
    ],
    villains: [
      {
        id: 'VillainMadelyn',
        name: 'Madelyn',
        description: 'the cat whisperer',
      },
      {
        id: 'VillainHaley',
        name: 'Haley',
        description: 'pen wielder',
      },
      {
        id: 'VillainElla',
        name: 'Ella',
        description: 'fashionista',
      },
      {
        id: 'VillainLandon',
        name: 'Landon',
        description: 'Mandalorian mauler',
      },
    ],
  }
  const str = JSON.stringify(db, null, 2) + '\n'
  write(filename, str)
}

resetDatabase()



================================================
FILE: scripts/run_cyct_changed_tests.sh
================================================
#!/bin/bash

# Use GitHub Actions environment variable for the branch name if it exists, otherwise use the local branch name
current_branch=${GITHUB_HEAD_REF:-$(git branch --show-current)}

# Get the list of changed files compared to the main branch
changed_files=$(git diff --name-only main "$current_branch")

# Initialize an empty string to hold our spec paths
spec_paths=""

# Loop through each changed file
for file in $changed_files; do
    # Check if the file is under the 'src' directory and has a .tsx extension
    if [[ $file == src/*.tsx ]]; then
        # Replace the .tsx extension with .cy.tsx to point to the corresponding test file
        test_file="${file//.tsx/.cy.tsx}"
        # Append the test file to the spec paths, separated by a comma
        if [ -z "$spec_paths" ]; then
            spec_paths="$test_file"
        else
            spec_paths="$spec_paths,$test_file"
        fi
    fi

    # Check if the file itself is a Cypress test file (ending with .cy.tsx)
    if [[ $file == *.cy.tsx ]]; then
        # Append the test file to the spec paths, separated by a comma
        if [ -z "$spec_paths" ]; then
            spec_paths="$file"
        else
            spec_paths="$spec_paths,$file"
        fi
    fi
done

# Run Cypress component tests if there are spec paths
if [ ! -z "$spec_paths" ]; then
    yarn cy:run-ct --spec "$spec_paths"
else
    echo "No spec files to run."
fi



================================================
FILE: scripts/run_jest_changed_tests.sh
================================================
#!/bin/bash

# Use GitHub Actions environment variable for the branch name if it exists, otherwise use the local branch name
current_branch=${GITHUB_HEAD_REF:-$(git branch --show-current)}

# Get the list of changed files compared to the main branch
changed_files=$(git diff --name-only main "$current_branch")

# Initialize an empty string to hold our test spec paths
test_spec_paths=""

# Loop through each changed file
for file in $changed_files; do
    # Check if the file is a source file under the 'src' directory with a .tsx extension
    if [[ $file == src/*.tsx ]]; then
        # Construct the corresponding Jest test file path
        test_file="${file//.tsx/.test.tsx}"
        # Check if the test file exists
        if [ -f "$test_file" ]; then
            # Append the test file to the test spec paths, separated by a space
            test_spec_paths="$test_spec_paths $test_file"
        fi
    fi

    # Check if the file itself is a Jest test file (ending with .test.tsx)
    if [[ $file == *.test.tsx ]]; then
        # Append the test file to the test spec paths, separated by a space
        test_spec_paths="$test_spec_paths $file"
    fi
done

# Run Jest tests if there are spec paths
if [ ! -z "$test_spec_paths" ]; then
    yarn jest $test_spec_paths
else
    echo "No Jest test files to run."
fi



================================================
FILE: src/About.tsx
================================================
export default function About() {
  return (
    <div data-cy="about" className="content-container">
      <div className="content-title-group not-found">
        <h2 className="title">Tour of Heroes</h2>
        <p>
          This project was created to provide a perspective on Test Driven
          Design using Cypress component and e2e testing to develop a React
          application. There are many versions of Angular's Tour of Heroes
          tutorial and John Papa has re-created them in Angular, Vue and React.
          The 3 apps are consistent in their styles and design decisions. This
          one inspires from them, uses CCTDD and takes variances along the way.
        </p>

        <br />
        <h2 className="title">Live applications by John Papa</h2>

        <ul>
          <li>
            <a href="https://papa-heroes-angular.azurewebsites.net">
              Tour of Heroes with Angular
            </a>
          </li>
          <li>
            <a href="https://papa-heroes-react.azurewebsites.net">
              Tour of Heroes with React
            </a>
          </li>
          <li>
            <a href="https://papa-heroes-vue.azurewebsites.net">
              Tour of Heroes with Vue
            </a>
          </li>
        </ul>
      </div>
    </div>
  )
}



================================================
FILE: src/App.css
================================================
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}



================================================
FILE: src/App.cy.tsx
================================================
import App from './App'

describe('ct sanity', () => {
  it('should render the App', () => {
    cy.intercept('GET', `${Cypress.env('API_URL')}/heroes`, {
      fixture: 'heroes.json',
    }).as('getHeroes')

    cy.intercept('GET', `${Cypress.env('API_URL')}/villains`, {
      fixture: 'villains.json',
    }).as('getVillains')

    cy.intercept('GET', `${Cypress.env('API_URL')}/boys`, {
      fixture: 'boys.json',
    })

    cy.mount(<App />)
    cy.getByCy('not-found').should('be.visible')

    cy.contains('Heroes').click()
    cy.getByCy('heroes').should('be.visible')

    cy.contains('Villains').click()
    cy.getByCy('villains').should('be.visible')

    cy.contains('Boys').click()
    cy.getByCy('boys').should('be.visible')

    cy.contains('About').click()
    cy.getByCy('about').should('be.visible')
  })
})



================================================
FILE: src/App.tsx
================================================
import {lazy, Suspense} from 'react'
import {BrowserRouter, Routes, Route, Navigate} from 'react-router-dom'
import {QueryClient, QueryClientProvider} from 'react-query'
import {ErrorBoundary} from 'react-error-boundary'
import HeaderBar from 'components/HeaderBar'
import NavBar from 'components/NavBar'
import PageSpinner from 'components/PageSpinner'
import ErrorComp from 'components/ErrorComp'
import Villains from 'villains/Villains'
import Boys from 'boys/Boys'
import './styles.scss'
const Heroes = lazy(() => import('heroes/Heroes'))
const NotFound = lazy(() => import('components/NotFound'))
const About = lazy(() => import('./About'))

const queryClient = new QueryClient()

export default function App() {
  return (
    <BrowserRouter>
      <HeaderBar />
      <div className="section columns">
        <NavBar />
        <main className="column">
          <QueryClientProvider client={queryClient}>
            <ErrorBoundary fallback={<ErrorComp />}>
              <Suspense fallback={<PageSpinner />}>
                <Routes>
                  <Route path="/" element={<Navigate replace to="/heroes" />} />
                  <Route path="/heroes/*" element={<Heroes />} />
                  <Route path="/villains/*" element={<Villains />} />
                  <Route path="/boys/*" element={<Boys />} />
                  <Route path="/about" element={<About />} />
                  <Route path="*" element={<NotFound />} />
                </Routes>
              </Suspense>
            </ErrorBoundary>
          </QueryClientProvider>
        </main>
      </div>
    </BrowserRouter>
  )
}

// why react-query? https://react-query.tanstack.com/
// to prevent duplicated data-fetching, we want to move all the data-fetching code into a central store
// and access that single source from the components that need it.
// With React Query, we don’t need to do any of the work involved in creating such a store.
// It lets us keep the data-fetching code in the components that need the data,
// but behind the scenes it manages a data cache, passing already-fetched data to components when they ask for them

// For components to access a shared React Query cache,
// we make the cache available by wrapping our app JSX in a provider component

/* istanbul ignore file */



================================================
FILE: src/index.css
================================================
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



================================================
FILE: src/index.tsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App'
import reportWebVitals from './reportWebVitals'

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals()

/* istanbul ignore file */



================================================
FILE: src/react-app-env.d.ts
================================================
/// <reference types="react-scripts" />



================================================
FILE: src/reportWebVitals.ts
================================================
import type {ReportHandler} from 'web-vitals'

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {
      getCLS(onPerfEntry)
      getFID(onPerfEntry)
      getFCP(onPerfEntry)
      getLCP(onPerfEntry)
      getTTFB(onPerfEntry)
    })
  }
}

export default reportWebVitals

/* istanbul ignore file */



================================================
FILE: src/setupTests.ts
================================================
import '@testing-library/jest-dom'

import {configure} from '@testing-library/react'

configure({testIdAttribute: 'data-cy'})



================================================
FILE: src/styles.scss
================================================
$vue: #42b883;
$vue-light: #42b883;
$angular: #b52e31;
$angular-light: #eb7a7c;
$react: #00b3e6;
$react-light: #61dafb;
$primary: $react;
$primary-light: $react-light;
$link: $primary; // #00b3e6; // #ff4081;

$shade-light: #fafafa;

@import 'bulma/bulma.sass';

.menu-list .active-link,
.menu-list .router-link-active {
  color: #fff;
  background-color: $link;
}

.not-found {
  i {
    font-size: 20px;
    margin-right: 8px;
  }
  .title {
    letter-spacing: 0px;
    font-weight: normal;
    font-size: 24px;
    text-transform: none;
  }
}

header {
  font-weight: bold;
  font-family: Arial;
  span {
    letter-spacing: 0px;
    &.tour {
      color: #fff;
    }
    &.of {
      color: #ccc;
    }
    &.heroes {
      color: $primary-light;
    }
  }
  .navbar-item.nav-home {
    border: 3px solid transparent;
    border-radius: 0%;
    &:hover {
      border-right: 3px solid $primary-light;
      border-left: 3px solid $primary-light;
    }
  }
  .fab {
    font-size: 24px;
    &.js-logo {
      color: $primary-light;
    }
  }
  .buttons {
    i.fab {
      color: #fff;
      margin-left: 20px;
      margin-right: 10px;
      &:hover {
        color: $primary-light;
      }
    }
  }
}

.edit-detail {
  .input[readonly] {
    background-color: $shade-light;
  }
}

.content-title-group {
  margin-bottom: 16px;
  h2 {
    border-left: 16px solid $primary;
    border-bottom: 2px solid $primary;
    padding-left: 8px;
    padding-right: 16px;
    display: inline-block;
    text-transform: uppercase;
    color: #555;
    letter-spacing: 0px;
    &:hover {
      color: $link;
    }
  }
  button.button {
    border: 0;
    color: #999;
    &:hover {
      color: $link;
    }
  }
}
ul.list {
  box-shadow: none;
}
div.card-content {
  background-color: $shade-light;
  .name {
    font-size: 28px;
    color: #000;
  }
  .description {
    font-size: 20px;
    color: #999;
  }
  background-color: $shade-light;
}
.card {
  margin-bottom: 2em;
}

label.label {
  font-weight: normal;
}

p.card-header-title {
  background-color: $primary;
  text-transform: uppercase;
  letter-spacing: 4px;
  color: #fff;
  display: block;
  padding-left: 24px;
}
.card-footer button {
  font-size: 16px;
  i {
    margin-right: 10px;
  }
  color: #888;
  &:hover {
    color: $link;
  }
}

.modal-card-foot button {
  display: inline-block;
  width: 80px;
}

.modal-card-head,
.modal-card-body {
  text-align: center;
}

.field {
  margin-bottom: 0.75rem;
}

.navbar-burger {
  margin-left: auto;
}

button.link {
  background: none;
  border: none;
  cursor: pointer;
}

.page-loading {
  font-size: 300%;
  position: fixed;
  z-index: 999;
  overflow: show;
  margin: auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 50px;
  height: 50px;
}

.icon-loading {
  animation: circle 1.2s steps(8) infinite;
}

@keyframes circle {
  from {
    transform: rotate(90deg);
  }

  to {
    transform: rotate(450deg);
  }
}



================================================
FILE: src/test-utils.tsx
================================================
import type {FC} from 'react'
import React, {Suspense} from 'react'
import type {RenderOptions} from '@testing-library/react'
import {render} from '@testing-library/react'
import {BrowserRouter} from 'react-router-dom'
import {QueryClient, QueryClientProvider} from 'react-query'
import {ErrorBoundary} from 'react-error-boundary'
import ErrorComp from 'components/ErrorComp'
import PageSpinner from 'components/PageSpinner'

const AllTheProviders: FC<{children: React.ReactNode}> = ({children}) => {
  return (
    <QueryClientProvider client={new QueryClient()}>
      <ErrorBoundary fallback={<ErrorComp />}>
        <Suspense fallback={<PageSpinner />}>
          <BrowserRouter>{children}</BrowserRouter>
        </Suspense>
      </ErrorBoundary>
    </QueryClientProvider>
  )
}

/** Renders the component wrapped by all the providers:
 * QueryClientProvider, ErrorBoundary, Suspense, BrowserRouter.
 */
const wrappedRender = (
  ui: React.ReactNode,
  options?: Omit<RenderOptions, 'wrapper'>,
  // @ts-expect-error - ok to ignore
) => render(ui, {wrapper: AllTheProviders, ...options})

export * from '@testing-library/react'
export {wrappedRender}



================================================
FILE: src/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["esnext", "dom"],
    "types": ["cypress", "node", "@testing-library/cypress"],
    "baseUrl": "./"
  },
  "include": ["**/*.ts*", "../cypress.d.ts"],
  "extends": "../tsconfig.json"
}



================================================
FILE: src/api/api.ts
================================================
import axios from 'axios'
import type {Hero} from 'models/Hero'

export type CrudType = 'GET' | 'POST' | 'PUT' | 'DELETE'
export type CrudOptions = {item?: Hero | object; config?: object}

export const client = (route: string, method: CrudType, item?: Hero | object) =>
  axios({
    method,
    baseURL: `${process.env.VITE_API_URL}/${route}`,
    data: method === 'POST' || method === 'PUT' ? item : undefined,
  })
    .then(res => res.data)
    .catch(err => {
      throw Error(`There was a problem fetching data: ${err}`)
    })

export const createItem = (route: string, item: Hero | object) =>
  client(route, 'POST', item)

export const editItem = (route: string, item: Hero | object) =>
  client(route, 'PUT', item)

export const deleteItem = (route: string) => client(route, 'DELETE')

export const getItem = (route: string) => client(route, 'GET')



================================================
FILE: src/boys/BoyDetail.cy.tsx
================================================
import BoyDetail from './BoyDetail'

import React from 'react'
import * as postHook from 'hooks/usePostEntity' // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
import '@testing-library/cypress/add-commands'

describe('BoyDetail', () => {
  beforeEach(() => {
    cy.wrappedMount(<BoyDetail />)
  })

  it('should handle Save', () => {
    // example of testing implementation details
    cy.spy(React, 'useState').as('useState')
    cy.spy(postHook, 'usePostEntity').as('usePostEntity') // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
    // instead prefer to test at a higher level
    cy.intercept('POST', '*', {statusCode: 200}).as('postBoy')
    cy.getByCy('save-button').click()

    // test at a higher level
    cy.wait('@postBoy')
    // test implementation details (what not to do)
    cy.get('@useState').should('have.been.called')
    cy.get('@usePostEntity').should('have.been.called') // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
  })

  it('should handle non-200 Save', () => {
    cy.intercept('POST', '*', {statusCode: 400, delay: 100}).as('postBoy')
    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@postBoy')
    cy.getByCy('error')
  })

  it('should handle Cancel', () => {
    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/boys')
  })

  it('should handle name change', () => {
    const newBoyName = 'abc'
    cy.getByCy('input-detail-name').type(newBoyName)

    cy.findByDisplayValue(newBoyName).should('be.visible')
  })

  it('should handle description change', () => {
    const newBoyDescription = '123'
    cy.getByCy('input-detail-description').type(newBoyDescription)

    cy.findByDisplayValue(newBoyDescription).should('be.visible')
  })

  it('id: false, name: false - should verify the minimal state of the component', () => {
    cy.get('p').then($el => cy.wrap($el.text()).should('equal', ''))
    cy.getByCyLike('input-detail').should('have.length', 2)
    cy.getByCy('input-detail-id').should('not.exist')

    cy.findByPlaceholderText('e.g. Colleen').should('be.visible')
    cy.findByPlaceholderText('e.g. dance fight!').should('be.visible')

    cy.getByCy('save-button').should('be.visible')
    cy.getByCy('cancel-button').should('be.visible')
  })
})



================================================
FILE: src/boys/BoyDetail.test.tsx
================================================
import BoyDetail from './BoyDetail'
import '@testing-library/jest-dom'
import {wrappedRender, act, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'

describe('BoyDetail', () => {
  beforeEach(() => {
    wrappedRender(<BoyDetail />)
  })

  // with msw, it is not recommended to use verify XHR calls going out of the app
  // instead, the advice is the verify the changes in the UI
  // alas, sometimes there are no changes in the component itself
  // therefore we cannot test everything 1:1 versus Cypress component test
  // should handle Save and should handle non-200 Save have no RTL mirrors

  it('should handle Cancel', async () => {
    // code that causes React state updates (ex: BrowserRouter)
    // should be wrapped into act(...):
    // userEvent.click(await screen.findByTestId('cancel-button')) // won't work
    act(() => screen.getByTestId('cancel-button').click())

    expect(window.location.pathname).toBe('/boys')
  })

  it('should handle name change', async () => {
    const newBoyName = 'abc'
    const inputDetailName = await screen.findByPlaceholderText('e.g. Colleen')
    userEvent.type(inputDetailName, newBoyName)

    await waitFor(async () =>
      expect(inputDetailName).toHaveDisplayValue(newBoyName),
    )
  })

  const inputDetailDescription = async () =>
    screen.findByPlaceholderText('e.g. dance fight!')

  it('should handle description change', async () => {
    const newBoyDescription = '123'

    userEvent.type(await inputDetailDescription(), newBoyDescription)
    await waitFor(async () =>
      expect(await inputDetailDescription()).toHaveDisplayValue(
        newBoyDescription,
      ),
    )
  })

  it('id: false, name: false - should verify the minimal state of the component', async () => {
    expect(await screen.findByTestId('input-detail-name')).toBeVisible()
    expect(await screen.findByTestId('input-detail-description')).toBeVisible()
    expect(screen.queryByTestId('input-detail-id')).not.toBeInTheDocument()

    expect(await inputDetailDescription()).toBeVisible()

    expect(await screen.findByTestId('save-button')).toBeVisible()
    expect(await screen.findByTestId('cancel-button')).toBeVisible()
  })
})



================================================
FILE: src/boys/BoyDetail.tsx
================================================
import {useState} from 'react'
import type {ChangeEvent} from 'react'
import {useNavigate, useParams} from 'react-router-dom'
import {FaUndo, FaRegSave} from 'react-icons/fa'
import InputDetail from 'components/InputDetail'
import ButtonFooter from 'components/ButtonFooter'
import PageSpinner from 'components/PageSpinner'
import ErrorComp from 'components/ErrorComp'
import {useEntityParams} from 'hooks/useEntityParams'
import {usePostEntity} from 'hooks/usePostEntity'
import type {Boy} from 'models/Boy'
import {usePutEntity} from 'hooks/usePutEntity'
import {partial, ifElse} from 'ramda'
import {isTruthy} from 'ramda-adjunct'

export default function BoyDetail() {
  const {id} = useParams()
  const {name, description} = useEntityParams()
  const [boy, setBoy] = useState({id, name, description})
  const {mutate: createBoy, status, error: postError} = usePostEntity('boy')
  const {
    updateEntity: updateBoy,
    isUpdating,
    isUpdateError,
  } = usePutEntity('boy')

  const navigate = useNavigate()

  const handleCancel = partial(navigate, ['/boys'])

  const handleSave = ifElse(
    () => isTruthy(name),
    () => updateBoy(boy as Boy),
    () => createBoy(boy as Boy),
  )

  const handleNameChange = (e: ChangeEvent<HTMLInputElement>) =>
    setBoy({...boy, name: e.target.value})

  const handleDescriptionChange = (e: ChangeEvent<HTMLInputElement>) =>
    setBoy({...boy, description: e.target.value})

  if (status === 'loading' || isUpdating) {
    return <PageSpinner />
  }

  if (postError || isUpdateError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="boy-detail" className="card edit-detail">
      <header className="card-header">
        <p className="card-header-title">{name}</p>
        &nbsp;
      </header>
      <div className="card-content">
        <div className="content">
          {id && (
            <InputDetail name={'id'} value={id} readOnly={true}></InputDetail>
          )}
          <InputDetail
            name={'name'}
            value={name ? name : ''}
            placeholder="e.g. Colleen"
            onChange={handleNameChange}
          ></InputDetail>
          <InputDetail
            name={'description'}
            value={description ? description : ''}
            placeholder="e.g. dance fight!"
            onChange={handleDescriptionChange}
          ></InputDetail>
        </div>
      </div>
      <footer className="card-footer">
        <ButtonFooter
          label="Cancel"
          IconClass={FaUndo}
          onClick={handleCancel}
        />
        <ButtonFooter label="Save" IconClass={FaRegSave} onClick={handleSave} />
      </footer>
    </div>
  )
}



================================================
FILE: src/boys/BoyList.cy.tsx
================================================
import BoyList from './BoyList'
import boys from '../../cypress/fixtures/boys.json'

describe('BoyList', () => {
  it('no boys should not display a list nor search bar', () => {
    cy.wrappedMount(
      <BoyList boys={[]} handleDeleteBoy={cy.stub().as('handleDeleteBoy')} />,
    )

    cy.getByCy('boy-list').should('exist')
    cy.getByCyLike('boy-list-item').should('not.exist')
    cy.getByCy('search').should('not.exist')
  })

  context('with boys in the list', () => {
    beforeEach(() => {
      cy.wrappedMount(
        <BoyList
          boys={boys}
          handleDeleteBoy={cy.stub().as('handleDeleteBoy')}
        />,
      )
    })

    it('should render the boy layout', () => {
      cy.getByCyLike('boy-list-item').should('have.length', boys.length)

      cy.getByCy('card-content')
      cy.contains(boys[0].name)
      cy.contains(boys[0].description)

      cy.get('footer')
        .first()
        .within(() => {
          cy.getByCy('delete-button')
          cy.getByCy('edit-button')
        })
    })

    it('should search and filter boy by name and description', () => {
      cy.getByCy('search').type(boys[0].name)
      cy.getByCyLike('boy-list-item')
        .should('have.length', 1)
        .contains(boys[0].name)

      cy.getByCy('search').clear().type(boys[2].description)
      cy.getByCyLike('boy-list-item')
        .should('have.length', 1)
        .contains(boys[2].description)
    })

    it('should handle delete', () => {
      cy.getByCy('delete-button').first().click()
      cy.get('@handleDeleteBoy').should('have.been.called')
    })

    it('should handle edit', () => {
      cy.getByCy('edit-button').first().click()
      cy.location('pathname').should('eq', '/boys/edit-boy/' + boys[0].id)
    })
  })
})



================================================
FILE: src/boys/BoyList.test.tsx
================================================
import BoyList from './BoyList'
import {wrappedRender, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {boys} from '../../db.json'

describe('BoyList', () => {
  const handleDeleteBoy = jest.fn()

  it('no boys should not display a list nor search bar', async () => {
    wrappedRender(<BoyList boys={[]} handleDeleteBoy={handleDeleteBoy} />)

    expect(await screen.findByTestId('boy-list')).toBeInTheDocument()
    expect(screen.queryByTestId('boy-list-item-1')).not.toBeInTheDocument()
    expect(screen.queryByTestId('search-bar')).not.toBeInTheDocument()
  })

  describe('with boys in the list', () => {
    beforeEach(() => {
      wrappedRender(<BoyList boys={boys} handleDeleteBoy={handleDeleteBoy} />)
    })

    const cardContents = async () => screen.findAllByTestId('card-content')
    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const editButtons = async () => screen.findAllByTestId('edit-button')

    it('should render the boy layout', async () => {
      expect(
        await screen.findByTestId(`boy-list-item-${boys.length - 1}`),
      ).toBeInTheDocument()

      expect(await screen.findByText(boys[0].name)).toBeInTheDocument()
      expect(await screen.findByText(boys[0].description)).toBeInTheDocument()
      expect(await cardContents()).toHaveLength(boys.length)
      expect(await deleteButtons()).toHaveLength(boys.length)
      expect(await editButtons()).toHaveLength(boys.length)
    })

    it('should search and filter boy by name and description', async () => {
      const search = await screen.findByTestId('search')

      userEvent.type(search, boys[0].name)
      await waitFor(async () => expect(await cardContents()).toHaveLength(4))
      await screen.findByText(boys[0].name)

      userEvent.clear(search)
      await waitFor(async () =>
        expect(await cardContents()).toHaveLength(boys.length),
      )

      userEvent.type(search, boys[2].description)
      await waitFor(async () => expect(await cardContents()).toHaveLength(1))
    })

    it('should handle delete', async () => {
      userEvent.click((await deleteButtons())[0])
      expect(handleDeleteBoy).toHaveBeenCalled()
    })

    it('should handle edit', async () => {
      userEvent.click((await editButtons())[0])
      await waitFor(() =>
        expect(window.location.pathname).toEqual(
          '/boys/edit-boy/' + boys[0].id,
        ),
      )
    })
  })
})



================================================
FILE: src/boys/BoyList.tsx
================================================
import {useNavigate} from 'react-router-dom'
import CardContent from 'components/CardContent'
import ButtonFooter from 'components/ButtonFooter'
import {FaEdit, FaRegSave} from 'react-icons/fa'
import type {ChangeEvent, MouseEvent} from 'react'
import {useTransition, useEffect, useState, useDeferredValue} from 'react'
import type {Boy} from 'models/Boy'
import type {BoyProperty} from 'models/types'
import {indexOf, find, curry, toLower, pipe, values, filter} from 'ramda'

type BoyListProps = {
  boys: Boy[]
  handleDeleteBoy: (boy: Boy) => (e: MouseEvent<HTMLButtonElement>) => void
}

export default function BoyList({boys, handleDeleteBoy}: BoyListProps) {
  const deferredBoys = useDeferredValue(boys)
  const isStale = deferredBoys !== boys
  const [filteredBoys, setFilteredBoys] = useState(deferredBoys)
  const navigate = useNavigate()
  const [isPending, startTransition] = useTransition()

  // needed to refresh the list after deleting a boy
  useEffect(() => setFilteredBoys(deferredBoys), [deferredBoys])

  const handleSelectBoy = curry(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (boyId: string, e: MouseEvent<HTMLButtonElement>) => {
      const boy = deferredBoys.find((b: Boy) => b.id === boyId)
      navigate(
        `/boys/edit-boy/${boy?.id}?name=${boy?.name}&description=${boy?.description}`,
      )
    },
  )

  /** returns a boolean whether the boy properties exist in the search field */
  const searchExists = (searchField: string, searchProperty: BoyProperty) =>
    indexOf(toLower(searchField), toLower(searchProperty)) !== -1

  /** finds the given boy's property in the search field  */
  const propertyExists = curry(
    (searchField: string, item: Boy) =>
      !!pipe(
        values,
        find((property: BoyProperty) => searchExists(searchField, property)),
      )(item),
  )
  /** given the search field and the boy array, returns the boy in which the search field exists */
  const searchProperties = (
    searchField: string,
  ): (<P extends Boy, C extends readonly P[]>(collection: C) => C) =>
    filter(propertyExists(searchField) as (value: unknown) => boolean)

  /** filters the boys data to see if the any of the properties exist in the list */
  const handleSearch =
    (data: Boy[]) => (event: ChangeEvent<HTMLInputElement>) => {
      const searchField = event.target.value
      const searchedBoy = searchProperties(searchField)(data)

      return startTransition(() =>
        setFilteredBoys(searchedBoy as React.SetStateAction<Boy[]>),
      )
    }

  return (
    <div
      style={{
        opacity: isPending ? 0.5 : 1,
        color: isStale ? 'dimgray' : 'black',
      }}
    >
      {deferredBoys.length > 0 && (
        <div className="card-content">
          <span>Search </span>
          <input data-cy="search" onChange={handleSearch(deferredBoys)} />
        </div>
      )}
      &nbsp;
      <ul data-cy="boy-list" className="list">
        {filteredBoys.map((boy, index) => (
          <li data-cy={`boy-list-item-${index}`} key={boy.id}>
            <div className="card">
              <CardContent name={boy.name} description={boy.description} />
              <footer className="card-footer">
                <ButtonFooter
                  label="Delete"
                  IconClass={FaRegSave}
                  onClick={handleDeleteBoy(boy)}
                />
                <ButtonFooter
                  label="Edit"
                  IconClass={FaEdit}
                  onClick={handleSelectBoy(boy.id)}
                />
              </footer>
            </div>
          </li>
        ))}
      </ul>
    </div>
  )
}



================================================
FILE: src/boys/Boys.cy.tsx
================================================
import Boys from './Boys'

describe('Boys', () => {
  it('should see error on initial load with GET', () => {
    Cypress.on('uncaught:exception', () => false)
    cy.clock()
    cy.intercept('GET', `${Cypress.env('API_URL')}/boys`, {
      statusCode: 400,
      delay: 100,
    }).as('notFound')

    cy.wrappedMount(<Boys />)

    cy.getByCy('page-spinner').should('be.visible')
    Cypress._.times(3, () => {
      cy.tick(5100)
      cy.wait('@notFound')
    })
    cy.tick(5100)

    cy.getByCy('error')
  })

  context('200 flows', () => {
    beforeEach(() => {
      cy.intercept('GET', `${Cypress.env('API_URL')}/boys`, {
        fixture: 'boys.json',
      }).as('getBoys')

      cy.wrappedMount(<Boys />)
    })

    it('should display the boy list on render, and go through boy add & refresh flow', () => {
      cy.wait('@getBoys')

      cy.getByCy('list-header').should('be.visible')
      cy.getByCy('boy-list').should('be.visible')

      cy.getByCy('add-button').click()
      cy.location('pathname').should('eq', '/boys/add-boy')

      cy.getByCy('refresh-button').click()
      cy.location('pathname').should('eq', '/boys')
    })

    const invokeBoyDelete = () => {
      cy.getByCy('delete-button').first().click()
      cy.getByCy('modal-yes-no').should('be.visible')
    }
    it('should go through the modal flow, and cover error on DELETE', () => {
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('do not delete flow')
      invokeBoyDelete()
      cy.getByCy('button-no').click()
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('delete flow')
      invokeBoyDelete()
      cy.intercept('DELETE', '*', {statusCode: 500}).as('deleteBoy')

      cy.getByCy('button-yes').click()
      cy.wait('@deleteBoy')
      cy.getByCy('modal-yes-no').should('not.exist')
      cy.getByCy('error').should('be.visible')
    })
  })
})



================================================
FILE: src/boys/Boys.test.tsx
================================================
import Boys from './Boys'
import {wrappedRender, screen, waitForElementToBeRemoved} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {rest} from 'msw'
import {setupServer} from 'msw/node'
import {boys} from '../../db.json'

describe('Boys', () => {
  // mute the expected console.error message, because we are mocking non-200 responses
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  jest.spyOn(console, 'error').mockImplementation(() => {})

  beforeEach(() => wrappedRender(<Boys />))

  it('should see error on initial load with GET', async () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/boys`, async (_req, res, ctx) =>
        res(ctx.status(400)),
      ),
    ]
    const server = setupServer(...handlers)
    server.listen({
      onUnhandledRequest: 'warn',
    })
    jest.useFakeTimers()

    expect(await screen.findByTestId('page-spinner')).toBeVisible()

    jest.advanceTimersByTime(25000)
    await waitForElementToBeRemoved(
      () => screen.queryByTestId('page-spinner'),
      {
        timeout: 25000,
      },
    )

    expect(await screen.findByTestId('error')).toBeVisible()
    jest.useRealTimers()
    server.resetHandlers()
    server.close()
  })

  describe('200 flows', () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/boys`, async (_req, res, ctx) =>
        res(ctx.status(200), ctx.json(boys)),
      ),
      rest.delete(
        `${process.env.VITE_API_URL}/boys/${boys[0].id}`, // use /.*/ for all requests
        async (_req, res, ctx) =>
          res(ctx.status(400), ctx.json('expected error')),
      ),
    ]
    const server = setupServer(...handlers)
    beforeAll(() => {
      server.listen({
        onUnhandledRequest: 'warn',
      })
    })
    afterEach(server.resetHandlers)
    afterAll(server.close)

    it('should display the boy list on render, and go through boy add & refresh flow', async () => {
      expect(await screen.findByTestId('list-header')).toBeVisible()
      expect(await screen.findByTestId('boy-list')).toBeVisible()

      await userEvent.click(await screen.findByTestId('add-button'))
      expect(window.location.pathname).toBe('/boys/add-boy')

      await userEvent.click(await screen.findByTestId('refresh-button'))
      expect(window.location.pathname).toBe('/boys')
    })

    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const modalYesNo = async () => screen.findByTestId('modal-yes-no')
    const maybeModalYesNo = () => screen.queryByTestId('modal-yes-no')
    const invokeBoyDelete = async () => {
      userEvent.click((await deleteButtons())[0])
      expect(await modalYesNo()).toBeVisible()
    }

    it('should go through the modal flow, and cover error on DELETE', async () => {
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()

      await invokeBoyDelete()
      await userEvent.click(await screen.findByTestId('button-no'))
      expect(maybeModalYesNo()).not.toBeInTheDocument()

      await invokeBoyDelete()
      await userEvent.click(await screen.findByTestId('button-yes'))

      expect(maybeModalYesNo()).not.toBeInTheDocument()
      expect(await screen.findByTestId('error')).toBeVisible()
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()
    })
  })
})



================================================
FILE: src/boys/Boys.tsx
================================================
import {useState} from 'react'
import {useNavigate, Routes, Route} from 'react-router-dom'
import ListHeader from 'components/ListHeader'
import ModalYesNo from 'components/ModalYesNo'
import ErrorComp from 'components/ErrorComp'
import BoyList from './BoyList'
import BoyDetail from './BoyDetail'
import {useGetEntities} from 'hooks/useGetEntities'
import {useDeleteEntity} from 'hooks/useDeleteEntity'
import type {Boy} from 'models/Boy'
import {partial, pipe} from 'ramda'

export default function Boys() {
  const [showModal, setShowModal] = useState<boolean>(false)
  const {entities: boys, getError} = useGetEntities('boys')
  const [boyToDelete, setBoyToDelete] = useState<Boy | null>(null)
  const {deleteEntity: deleteBoy, isDeleteError} = useDeleteEntity('boy')

  const navigate = useNavigate()
  const addNewBoy = partial(navigate, ['/boys/add-boy'])
  const handleRefresh = partial(navigate, ['/boys'])

  const handleCloseModal = pipe(
    partial(setBoyToDelete, [null]),
    partial(setShowModal, [false]),
  )

  const handleDeleteBoy = (boy: Boy) =>
    pipe(partial(setBoyToDelete, [boy]), partial(setShowModal, [true]))

  const handleDeleteFromModal = pipe(
    () => (boyToDelete ? deleteBoy(boyToDelete) : null),
    partial(setShowModal, [false]),
  )

  if (getError || isDeleteError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="boys">
      <ListHeader
        title="Boys"
        handleAdd={addNewBoy}
        handleRefresh={handleRefresh}
      />
      <div>
        <div>
          <Routes>
            <Route
              path=""
              element={
                <BoyList boys={boys} handleDeleteBoy={handleDeleteBoy} />
              }
            />
            <Route path="/add-boy" element={<BoyDetail />} />
            <Route path="/edit-boy/:id" element={<BoyDetail />} />
            <Route
              path="*"
              element={
                <BoyList boys={boys} handleDeleteBoy={handleDeleteBoy} />
              }
            />
          </Routes>
        </div>
      </div>

      {showModal && (
        <ModalYesNo
          message="Would you like to delete the boy?"
          onNo={handleCloseModal}
          onYes={handleDeleteFromModal}
        />
      )}
    </div>
  )
}

// remove later: a change to a src file



================================================
FILE: src/components/ButtonFooter.cy.tsx
================================================
import ButtonFooter from './ButtonFooter'
import {FaEdit, FaRegSave} from 'react-icons/fa'

describe('ButtonFooter', () => {
  const doAssertions = (label: string) => {
    cy.contains('span', label)
    cy.get('svg').should('be.visible')

    cy.getByCy(`${label.toLowerCase()}-button`).click()
    cy.get('@click').should('be.called')
  }

  it('should render and Edit button, the label, and trigger an onClick', () => {
    const label = 'Edit'
    cy.mount(
      <ButtonFooter
        label={label}
        IconClass={FaEdit}
        onClick={cy.stub().as('click')}
      />,
    )

    doAssertions(label)
  })

  it('should render and Save button, the label, and trigger an onClick', () => {
    const label = 'Save'
    cy.mount(
      <ButtonFooter
        label={label}
        IconClass={FaRegSave}
        onClick={cy.stub().as('click')}
      />,
    )

    doAssertions(label)
  })
})



================================================
FILE: src/components/ButtonFooter.test.tsx
================================================
import ButtonFooter from './ButtonFooter'
import {FaEdit, FaRegSave} from 'react-icons/fa'
import {render, screen} from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ButtonFooter', () => {
  const click = jest.fn()

  const doAssertions = async (label: string) => {
    expect(await screen.findByText(label)).toBeVisible()

    await userEvent.click(
      await screen.findByTestId(`${label.toLowerCase()}-button`),
    )
    expect(click).toHaveBeenCalled()
  }

  it('should render and Edit button, the label, and trigger an onClick', async () => {
    const label = 'Edit'
    render(<ButtonFooter label={label} IconClass={FaEdit} onClick={click} />)

    await doAssertions(label)
  })

  it('should render and Save button, the label, and trigger an onClick', async () => {
    const label = 'Save'
    render(<ButtonFooter label={label} IconClass={FaRegSave} onClick={click} />)

    await doAssertions(label)
  })
})



================================================
FILE: src/components/ButtonFooter.tsx
================================================
import type {FaUndo, FaRegSave, FaEdit, FaTrash} from 'react-icons/fa'
import type {MouseEvent} from 'react'

type ButtonFooterProps = {
  label: 'Cancel' | 'Save' | 'Edit' | 'Delete'
  IconClass: typeof FaUndo | typeof FaRegSave | typeof FaEdit | typeof FaTrash
  onClick: (e: MouseEvent<HTMLButtonElement>) => void
}

export default function ButtonFooter({
  label,
  IconClass,
  onClick,
}: ButtonFooterProps) {
  return (
    <button
      data-cy={`${label.toLowerCase()}-button`}
      aria-label={label}
      onClick={onClick}
    >
      <IconClass />
      &nbsp;
      <span>{label}</span>
    </button>
  )
}



================================================
FILE: src/components/CardContent.cy.tsx
================================================
import CardContent from './CardContent'

describe('CardContent', () => {
  it('should render the card content', () => {
    const name = 'Bjorn Ironside'
    const description = 'king of 9th century Sweden'
    cy.mount(<CardContent name={name} description={description} />)

    cy.contains('div', name)
    cy.contains('div', description)
  })
})



================================================
FILE: src/components/CardContent.test.tsx
================================================
import CardContent from './CardContent'
import {render, screen} from '@testing-library/react'

describe('CardContent', () => {
  it('should render the card content', async () => {
    const name = 'Bjorn Ironside'
    const description = 'king of 9th century Sweden'
    render(<CardContent name={name} description={description} />)

    expect(await screen.findByText(name)).toBeVisible()
    expect(await screen.findByText(description)).toBeVisible()
  })
})



================================================
FILE: src/components/CardContent.tsx
================================================
type CardContentProps = {
  name: string
  description: string
}

export default function CardContent({name, description}: CardContentProps) {
  return (
    <div data-cy="card-content" className="card-content">
      <div className="name">{name}</div>
      <div className="description">{description}</div>
    </div>
  )
}



================================================
FILE: src/components/ErrorComp.cy.tsx
================================================
import ErrorComp from './ErrorComp'

describe('ErrorComp', () => {
  it('should render error', () => {
    cy.mount(<ErrorComp />)
    cy.getByCy('error').should('be.visible')
  })
})



================================================
FILE: src/components/ErrorComp.test.tsx
================================================
import ErrorComp from './ErrorComp'
import {render, screen} from '@testing-library/react'
import '@testing-library/jest-dom'

describe('ErrorComp', () => {
  it('should render error', async () => {
    render(<ErrorComp />)
    expect(await screen.findByTestId('error')).toBeVisible()
  })
})



================================================
FILE: src/components/ErrorComp.tsx
================================================
export default function ErrorComp() {
  return (
    <>
      <h1 data-cy="error">Something went wrong!</h1>
      <p>Try reloading the page.</p>
    </>
  )
}



================================================
FILE: src/components/HeaderBar.cy.tsx
================================================
import HeaderBar from './HeaderBar'

import {BrowserRouter} from 'react-router-dom'

describe('HeaderBar', () => {
  it('should render', () => {
    cy.mount(
      <BrowserRouter>
        <HeaderBar />
      </BrowserRouter>,
    )
    cy.getByCy('header-bar-brand')
  })
})



================================================
FILE: src/components/HeaderBar.test.tsx
================================================
import HeaderBar from './HeaderBar'
import {render, screen} from '@testing-library/react'
import {BrowserRouter} from 'react-router-dom'

describe('HeaderBar', () => {
  it('should render error', async () => {
    render(
      <BrowserRouter>
        <HeaderBar />
      </BrowserRouter>,
    )
    expect(await screen.findByTestId('header-bar-brand')).toBeVisible()
  })
})



================================================
FILE: src/components/HeaderBar.tsx
================================================
import HeaderBarBrand from './HeaderBarBrand'

export default function HeaderBar() {
  return (
    <header data-cy="header-bar">
      <nav
        className="navbar has-background-dark is-dark"
        role="navigation"
        aria-label="main navigation"
      >
        <HeaderBarBrand />
      </nav>
    </header>
  )
}



================================================
FILE: src/components/HeaderBarBrand.cy.tsx
================================================
import HeaderBarBrand from './HeaderBarBrand'
import {BrowserRouter} from 'react-router-dom'

describe('HeaderBarBrand', () => {
  beforeEach(() => {
    cy.mount(
      <BrowserRouter>
        <HeaderBarBrand />
      </BrowserRouter>,
    )
  })

  it('should verify external link attributes', () => {
    cy.get('a')
      .should('have.attr', 'href', 'https://reactjs.org/')
      .and('have.attr', 'target', '_blank')
      .and('have.attr', 'rel', 'noopener noreferrer')
    cy.getByCy('header-bar-brand').within(() => cy.get('svg'))
  })

  it('should verify internal link spans and navigation', () => {
    cy.getByCy('navLink').within(() =>
      ['TOUR', 'OF', 'HEROES'].map((part: string) => cy.contains('span', part)),
    )
    cy.getByCy('navLink').click()
    cy.url().should('contain', '/')
  })
})



================================================
FILE: src/components/HeaderBarBrand.test.tsx
================================================
import HeaderBarBrand from './HeaderBarBrand'
import {render, screen, within} from '@testing-library/react'
import {BrowserRouter} from 'react-router-dom'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'

describe('HeaderBarBrand', () => {
  beforeEach(() => {
    render(
      <BrowserRouter>
        <HeaderBarBrand />
      </BrowserRouter>,
    )
  })
  it('should verify external link attributes', async () => {
    const link = await screen.findByTestId('header-bar-brand-link')
    expect(link).toHaveAttribute('href', 'https://reactjs.org/')
    expect(link).toHaveAttribute('target', '_blank')
    expect(link).toHaveAttribute('rel', 'noopener noreferrer')

    // not easy to get a tag with RTL, needed to use a test id
    within(await screen.findByTestId('header-bar-brand')).getByTestId(
      'react-icon-svg',
    )
  })

  it('should verify internal link spans and navigation', async () => {
    const navLink = await screen.findByTestId('navLink')
    const withinNavLink = within(navLink)
    ;['TOUR', 'OF', 'HEROES'].forEach(part => withinNavLink.getByText(part))

    await userEvent.click(navLink)
    expect(window.location.pathname).toBe('/')
  })
})



================================================
FILE: src/components/HeaderBarBrand.tsx
================================================
import {FaReact} from 'react-icons/fa'
import {NavLink} from 'react-router-dom'

export default function HeaderBarBrand() {
  return (
    <div data-cy="header-bar-brand" className="navbar-brand">
      <a
        href="https://reactjs.org/"
        target="_blank"
        rel="noopener noreferrer"
        className="navbar-item"
        data-cy="header-bar-brand-link"
      >
        <div data-cy="react-icon-svg">
          <FaReact />
        </div>
      </a>
      <NavLink data-cy="navLink" to="/" className="navbar-item navbar-home">
        <span className="tour">TOUR</span>
        <span className="of">OF</span>
        <span className="heroes">HEROES</span>
      </NavLink>
    </div>
  )
}



================================================
FILE: src/components/InputDetail.cy.tsx
================================================
import InputDetail from './InputDetail'

import '@testing-library/cypress/add-commands'

describe('InputDetail', () => {
  const placeholder = 'Aslaug'
  const name = 'name'
  const value = 'some value'
  const newValue = '42'

  it('should allow the input field to be modified', () => {
    cy.mount(
      <InputDetail
        name={name}
        value={value}
        placeholder={placeholder}
        onChange={cy.stub().as('onChange')}
      />,
    )

    cy.contains('label', name)
    cy.findByPlaceholderText(placeholder).clear().type(newValue)
    cy.findByDisplayValue(newValue).should('be.visible')
    cy.get('@onChange').its('callCount').should('eq', newValue.length)
  })

  it('should not allow the input field to be modified', () => {
    cy.mount(
      <InputDetail
        name={name}
        value={value}
        placeholder={placeholder}
        readOnly={true}
      />,
    )

    cy.contains('label', name)
    cy.findByPlaceholderText(placeholder)
      .should('have.value', value)
      .and('have.attr', 'readOnly')
  })
})



================================================
FILE: src/components/InputDetail.test.tsx
================================================
import InputDetail from './InputDetail'
import {render, screen} from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('InputDetail', () => {
  const placeholder = 'Aslaug'
  const name = 'name'
  const value = 'some value'
  const newValue = '42'

  it('should allow the input field to be modified', async () => {
    const onChange = jest.fn()
    render(
      <InputDetail
        name={name}
        value={value}
        placeholder={placeholder}
        onChange={onChange}
      />,
    )

    await screen.findByText(name)
    const inputField = await screen.findByPlaceholderText(placeholder)
    await userEvent.clear(inputField)
    await userEvent.type(inputField, newValue)
    expect(inputField).toHaveDisplayValue(newValue)
    expect(onChange).toHaveBeenCalledTimes(newValue.length)
  })

  it('should not allow the input field to be modified', async () => {
    render(
      <InputDetail
        name={name}
        value={value}
        placeholder={placeholder}
        readOnly={true}
      />,
    )

    await screen.findByText(name)
    const inputField = await screen.findByPlaceholderText(placeholder)
    expect(inputField).toHaveDisplayValue(value)
    expect(inputField).toHaveAttribute('readOnly')
  })
})



================================================
FILE: src/components/InputDetail.tsx
================================================
import type {ChangeEvent} from 'react'
import {useEffect, useState} from 'react'

type InputDetailProps = {
  name: string
  value: string
  placeholder?: string
  onChange?: (e: ChangeEvent<HTMLInputElement>) => void
  readOnly?: boolean
}

export default function InputDetail({
  name,
  value,
  placeholder,
  onChange,
  readOnly,
}: InputDetailProps) {
  const [shownValue, setShownValue] = useState('')
  useEffect(() => {
    setShownValue(value)
  }, [value])

  return (
    <div data-cy={`input-detail-${name}`} className="field">
      <label className="label" htmlFor={name}>
        {name}
      </label>
      <input
        name={name}
        role={name}
        defaultValue={shownValue}
        placeholder={placeholder}
        onChange={onChange}
        readOnly={readOnly}
        className="input"
        type="text"
      ></input>
    </div>
  )
}



================================================
FILE: src/components/ListHeader.cy.tsx
================================================
import ListHeader from './ListHeader'
import {BrowserRouter} from 'react-router-dom'

describe('ListHeader', () => {
  it('should call click handlers on add & refresh button clicks', () => {
    const title = 'Heroes'
    cy.mount(
      <BrowserRouter>
        <ListHeader
          title={title}
          handleAdd={cy.stub().as('handleAdd')}
          handleRefresh={cy.stub().as('handleRefresh')}
        />
      </BrowserRouter>,
    )

    cy.getByCy('add-button').click()
    cy.get('@handleAdd').should('be.called')

    cy.getByCy('refresh-button').click()
    cy.get('@handleRefresh').should('be.called')

    cy.getByCy('title').contains(title).click()
    cy.url().should('contain', title)
  })
})



================================================
FILE: src/components/ListHeader.test.tsx
================================================
import ListHeader from './ListHeader'
import {render, screen} from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import {BrowserRouter} from 'react-router-dom'
import '@testing-library/jest-dom'

describe('ListHeader', () => {
  it('should call click handlers on add & refresh button clicks', async () => {
    const handleAdd = jest.fn()
    const handleRefresh = jest.fn()
    const title = 'Heroes'
    render(
      <BrowserRouter>
        <ListHeader
          title={title}
          handleAdd={handleAdd}
          handleRefresh={handleRefresh}
        />
      </BrowserRouter>,
    )

    await userEvent.click(await screen.findByTestId('add-button'))
    expect(handleAdd).toHaveBeenCalled()

    await userEvent.click(await screen.findByTestId('refresh-button'))
    expect(handleRefresh).toHaveBeenCalled()

    await userEvent.click(await screen.findByText(title))
    expect(window.location.pathname).toBe(`/${title}`)
  })
})



================================================
FILE: src/components/ListHeader.tsx
================================================
import type {MouseEvent} from 'react'
import {NavLink} from 'react-router-dom'
import {FiRefreshCcw} from 'react-icons/fi'
import {GrAdd} from 'react-icons/gr'

type ListHeaderProps = {
  title: 'Heroes' | 'Villains' | 'Boys' | 'About'
  handleAdd: (e: MouseEvent<HTMLButtonElement>) => void
  handleRefresh: (e: MouseEvent<HTMLButtonElement>) => void
}

export default function ListHeader({
  title,
  handleAdd,
  handleRefresh,
}: ListHeaderProps) {
  return (
    <div data-cy="list-header" className="content-title-group">
      <NavLink data-cy="title" to={title}>
        <h2>{title}</h2>
      </NavLink>
      <button data-cy="add-button" onClick={handleAdd} aria-label="add">
        <GrAdd />
      </button>
      <button
        data-cy="refresh-button"
        onClick={handleRefresh}
        aria-label="refresh"
      >
        <FiRefreshCcw />
      </button>
    </div>
  )
}



================================================
FILE: src/components/Modal.tsx
================================================
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import type {ReactNode} from 'react'
import {useEffect, useRef} from 'react'
import {createPortal} from 'react-dom'

type ModalProps = {
  children?: ReactNode
}

const Modal = ({children}: ModalProps) => {
  const el = useRef(document.createElement('div'))

  let modalRoot = document.getElementById('modal-root')
  if (!modalRoot) {
    modalRoot = document.createElement('div')
    modalRoot.setAttribute('id', 'modal-root')
    document.body.appendChild(modalRoot)
  }

  useEffect(() => {
    const currentEl = el.current

    modalRoot!.appendChild(currentEl)

    return () => {
      modalRoot!.removeChild(currentEl)
    }
  }, [modalRoot])

  return createPortal(children, el.current)
}

export default Modal



================================================
FILE: src/components/ModalYesNo.cy.tsx
================================================
import ModalYesNo from './ModalYesNo'

describe('ModalYesNo', () => {
  it('should render the modal and call onClick handlers', () => {
    const message = 'Are you sure?'
    cy.mount(
      <ModalYesNo
        message={message}
        onYes={cy.stub().as('onYes')}
        onNo={cy.stub().as('onNo')}
      />,
    )

    cy.get('#modal-root').should('exist')

    cy.get('div')
      .last()
      .within(() => {
        cy.get('header').contains('Confirm')
        cy.get('section').contains(message)
        cy.get('footer')
        cy.getByCy('button-yes').contains('Yes')
        cy.getByCy('button-no').contains('No')
      })

    cy.getByCy('button-yes').click()
    cy.get('@onYes').should('be.called')

    cy.getByCy('button-no').click()
    cy.get('@onNo').should('be.called')
  })

  it('should not render the modal with if conditional render is false', () => {
    function ParentComponent(): JSX.Element | boolean {
      return (
        false && (
          <ModalYesNo
            message={'yo'}
            onYes={cy.stub().as('onYes')}
            onNo={cy.stub().as('onNo')}
          />
        )
      )
    }

    // @ts-expect-error: replicating useState
    cy.mount(<ParentComponent />)
    cy.getByCy('modal-yes-no').should('not.exist')
  })
})



================================================
FILE: src/components/ModalYesNo.test.tsx
================================================
import ModalYesNo from './ModalYesNo'
import {render, screen} from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe('ModalYesNo', () => {
  const message = 'Are you sure?'
  const onYes = jest.fn()
  const onNo = jest.fn()

  it('should render the modal and call onClick handlers', async () => {
    render(<ModalYesNo message={message} onYes={onYes} onNo={onNo} />)

    await screen.findByText('Confirm')
    await screen.findByText(message)

    const buttonYes = await screen.findByTestId('button-yes')
    const buttonNo = await screen.findByTestId('button-no')

    expect(buttonYes).toBeVisible()
    expect(buttonNo).toBeVisible()

    await userEvent.click(buttonYes)
    expect(onYes).toHaveBeenCalled()

    await userEvent.click(buttonNo)
    expect(onNo).toHaveBeenCalled()
  })

  it('should not render the modal with if conditional render is false', async () => {
    function ParentComponent(): JSX.Element | boolean {
      return false && <ModalYesNo message={'yo'} onYes={onYes} onNo={onNo} />
    }
    // @ts-expect-error: replicating useState
    render(<ParentComponent />)
    expect(screen.queryByTestId('modal-yes-no')).not.toBeInTheDocument()
  })
})



================================================
FILE: src/components/ModalYesNo.tsx
================================================
import Modal from './Modal'
import type {MouseEvent} from 'react'

type ModalYesNoProps = {
  message: string
  onYes: (e: MouseEvent<HTMLButtonElement>) => void
  onNo: (e: MouseEvent<HTMLButtonElement>) => void
}

export default function ModalYesNo({message, onYes, onNo}: ModalYesNoProps) {
  return (
    <Modal>
      <div data-cy="modal-yes-no" className="modal is-active">
        <div className="modal-background" />
        <div className="modal-card">
          <header className="modal-card-head">
            <p className="modal-card-title">Confirm</p>
          </header>
          <section className="modal-card-body">{message}</section>
          <footer className="modal-card-foot card-footer">
            <button
              data-cy="button-no"
              onClick={onNo}
              className="button modal-no"
            >
              No
            </button>
            <button
              data-cy="button-yes"
              onClick={onYes}
              className="button is-primary modal-yes"
            >
              Yes
            </button>
          </footer>
        </div>
      </div>
    </Modal>
  )
}



================================================
FILE: src/components/NavBar.cy.tsx
================================================
import NavBar from './NavBar'
import {BrowserRouter} from 'react-router-dom'

const routes = ['heroes', 'villains', 'boys', 'about']

describe('NavBar', () => {
  it('should navigate to the correct routes', () => {
    cy.mount(
      <BrowserRouter>
        <NavBar />
      </BrowserRouter>,
    )

    cy.contains('p', 'Menu')
    cy.getByCy('menu-list').children().should('have.length', routes.length)

    routes.forEach((route: string) => {
      cy.get(`[href="/${route}"]`)
        .contains(route, {matchCase: false})
        .click()
        .should('have.class', 'active-link')
        .siblings()
        .should('not.have.class', 'active-link')

      cy.url().should('contain', route)
    })
  })
})



================================================
FILE: src/components/NavBar.test.tsx
================================================
import NavBar from './NavBar'
import {render, screen, within, waitFor} from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import {BrowserRouter} from 'react-router-dom'
import '@testing-library/jest-dom'

const routes = ['Heroes', 'Villains', 'Boys', 'About']

describe('NavBar', () => {
  beforeEach(() => {
    render(
      <BrowserRouter>
        <NavBar />
      </BrowserRouter>,
    )
  })

  it('should verify route layout', async () => {
    expect(await screen.findByText('Menu')).toBeVisible()

    const menuList = await screen.findByTestId('menu-list')
    expect(within(menuList).queryAllByRole('link').length).toBe(routes.length)

    routes.forEach(route => within(menuList).getByText(route))
  })

  it.each(routes)('should navigate to route %s', async (route: string) => {
    const link = async (name: string) => screen.findByRole('link', {name})
    const activeRouteLink = await link(route)
    userEvent.click(activeRouteLink)
    await waitFor(() => expect(activeRouteLink).toHaveClass('active-link'))
    expect(window.location.pathname).toEqual(`/${route.toLowerCase()}`)

    const remainingRoutes = routes.filter(r => r !== route)
    remainingRoutes.forEach(async inActiveRoute => {
      expect(await link(inActiveRoute)).not.toHaveClass('active-link')
    })
  })
})



================================================
FILE: src/components/NavBar.tsx
================================================
import {NavLink} from 'react-router-dom'

export default function NavBar() {
  const linkIsActive = (link: {isActive: boolean}) =>
    link.isActive ? 'active-link' : ''

  return (
    <nav data-cy="nav-bar" className="column is-2 menu">
      <p className="menu-label">Menu</p>
      <ul data-cy="menu-list" className="menu-list">
        <NavLink to="/heroes" className={linkIsActive}>
          Heroes
        </NavLink>
        <NavLink to="/villains" className={linkIsActive}>
          Villains
        </NavLink>
        <NavLink to="/boys" className={linkIsActive}>
          Boys
        </NavLink>
        <NavLink to="/about" className={linkIsActive}>
          About
        </NavLink>
      </ul>
    </nav>
  )
}



================================================
FILE: src/components/NotFound.cy.tsx
================================================
import NotFound from './NotFound'

describe('NotFound', () => {
  it('should', () => {
    cy.mount(<NotFound />)

    cy.getByCy('not-found').should('be.visible')
    cy.get('svg')
    cy.get('span').contains("These aren't the bits you're looking for")
  })
})



================================================
FILE: src/components/NotFound.test.tsx
================================================
import NotFound from './NotFound'
import {render, screen} from '@testing-library/react'

describe('NotFound', () => {
  it('should', async () => {
    render(<NotFound />)

    expect(await screen.findByTestId('not-found')).toBeVisible()
    expect(await screen.findByTestId('exclamation')).toBeVisible()
    expect(
      await screen.findByText("These aren't the bits you're looking for"),
    ).toBeVisible()
  })
})



================================================
FILE: src/components/NotFound.tsx
================================================
import {FaExclamationTriangle} from 'react-icons/fa'

export default function NotFound() {
  return (
    <div data-cy="not-found" className="content-container">
      <div className="content-title-group not-found">
        <div data-cy="exclamation">
          <FaExclamationTriangle />
        </div>
        &nbsp;
        <span className="title">These aren't the bits you're looking for</span>
      </div>
    </div>
  )
}



================================================
FILE: src/components/PageSpinner.cy.tsx
================================================
import PageSpinner from './PageSpinner'

describe('PageSpinner', () => {
  it('should render the page spinner', () => {
    cy.mount(<PageSpinner />)
    cy.getByCyLike('page-spinner').should('be.visible')
  })
})



================================================
FILE: src/components/PageSpinner.test.tsx
================================================
import PageSpinner from './PageSpinner'
import {render, screen} from '@testing-library/react'
import '@testing-library/jest-dom'

describe('PageSpinner', () => {
  it('should render a PageSpinner', async () => {
    render(<PageSpinner />)
    await screen.findByTestId('page-spinner')
  })
})



================================================
FILE: src/components/PageSpinner.tsx
================================================
import Spinner from './Spinner'

export default function PageSpinner() {
  return (
    <p className="page-loading" data-cy="page-spinner">
      <Spinner />
    </p>
  )
}



================================================
FILE: src/components/Spinner.cy.tsx
================================================
import Spinner from './Spinner'

describe('Spinner', () => {
  it('should render a spinner', () => {
    cy.mount(<Spinner />)
    cy.getByCy('spinner').should('be.visible')
  })
})



================================================
FILE: src/components/Spinner.test.tsx
================================================
import Spinner from './Spinner'
import {render, screen} from '@testing-library/react'

describe('Spinner', () => {
  it('should render a spinner', async () => {
    render(<Spinner />)
    await screen.findByTestId('spinner')
  })
})



================================================
FILE: src/components/Spinner.tsx
================================================
import React from 'react'
import {FaSpinner} from 'react-icons/fa'

export default function Spinner(
  props: JSX.IntrinsicAttributes &
    React.ClassAttributes<HTMLSpanElement> &
    React.HTMLAttributes<HTMLSpanElement>,
) {
  return (
    <span {...props}>
      <FaSpinner className="icon-loading" data-cy="spinner" />
    </span>
  )
}



================================================
FILE: src/heroes/HeroDetail.cy.tsx
================================================
import HeroDetail from './HeroDetail'

import '@testing-library/cypress/add-commands'

describe('HeroDetail', () => {
  beforeEach(() => {
    cy.wrappedMount(<HeroDetail />)
  })

  it('should handle Save', () => {
    cy.intercept('POST', '*', {statusCode: 200}).as('postHero')
    cy.getByCy('save-button').click()
    cy.wait('@postHero')
  })

  it('should handle non-200 Save', () => {
    cy.intercept('POST', '*', {statusCode: 400, delay: 100}).as('postHero')
    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@postHero')
    cy.getByCy('error')
  })

  it('should handle Cancel', () => {
    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/heroes')
  })

  it('should handle name change', () => {
    const newHeroName = 'abc'
    cy.getByCy('input-detail-name').type(newHeroName)

    cy.findByDisplayValue(newHeroName).should('be.visible')
  })

  it('should handle description change', () => {
    const newHeroDescription = '123'
    cy.getByCy('input-detail-description').type(newHeroDescription)

    cy.findByDisplayValue(newHeroDescription).should('be.visible')
  })

  it('id: false, name: false - should verify the minimal state of the component', () => {
    cy.get('p').then($el => cy.wrap($el.text()).should('equal', ''))
    cy.getByCyLike('input-detail').should('have.length', 2)
    cy.getByCy('input-detail-id').should('not.exist')

    cy.findByPlaceholderText('e.g. Colleen').should('be.visible')
    cy.findByPlaceholderText('e.g. dance fight!').should('be.visible')

    cy.getByCy('save-button').should('be.visible')
    cy.getByCy('cancel-button').should('be.visible')
  })
})



================================================
FILE: src/heroes/HeroDetail.test.tsx
================================================
import HeroDetail from './HeroDetail'
import '@testing-library/jest-dom'
import {wrappedRender, act, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'

describe('HeroDetail', () => {
  beforeEach(() => {
    wrappedRender(<HeroDetail />)
  })

  // with msw, it is not recommended to use verify XHR calls going out of the app
  // instead, the advice is the verify the changes in the UI
  // alas, sometimes there are no changes in the component itself
  // therefore we cannot test everything 1:1 versus Cypress component test
  // should handle Save and should handle non-200 Save have no RTL mirrors

  it('should handle Cancel', async () => {
    // code that causes React state updates (ex: BrowserRouter)
    // should be wrapped into act(...):
    // userEvent.click(await screen.findByTestId('cancel-button')) // won't work
    act(() => screen.getByTestId('cancel-button').click())

    expect(window.location.pathname).toBe('/heroes')
  })

  it('should handle name change', async () => {
    const newHeroName = 'abc'
    const inputDetailName = await screen.findByPlaceholderText('e.g. Colleen')
    userEvent.type(inputDetailName, newHeroName)

    await waitFor(async () =>
      expect(inputDetailName).toHaveDisplayValue(newHeroName),
    )
  })

  const inputDetailDescription = async () =>
    screen.findByPlaceholderText('e.g. dance fight!')

  it('should handle description change', async () => {
    const newHeroDescription = '123'

    userEvent.type(await inputDetailDescription(), newHeroDescription)
    await waitFor(async () =>
      expect(await inputDetailDescription()).toHaveDisplayValue(
        newHeroDescription,
      ),
    )
  })

  it('id: false, name: false - should verify the minimal state of the component', async () => {
    expect(await screen.findByTestId('input-detail-name')).toBeVisible()
    expect(await screen.findByTestId('input-detail-description')).toBeVisible()
    expect(screen.queryByTestId('input-detail-id')).not.toBeInTheDocument()

    expect(await inputDetailDescription()).toBeVisible()

    expect(await screen.findByTestId('save-button')).toBeVisible()
    expect(await screen.findByTestId('cancel-button')).toBeVisible()
  })
})



================================================
FILE: src/heroes/HeroDetail.tsx
================================================
import type {ChangeEvent} from 'react'
import {useState} from 'react'
import {useNavigate, useParams} from 'react-router-dom'
import {FaUndo, FaRegSave} from 'react-icons/fa'
import InputDetail from 'components/InputDetail'
import ButtonFooter from 'components/ButtonFooter'
import PageSpinner from 'components/PageSpinner'
import ErrorComp from 'components/ErrorComp'
import {useEntityParams} from 'hooks/useEntityParams'
import {usePostEntity} from 'hooks/usePostEntity'
import type {Hero} from 'models/Hero'
import {usePutEntity} from 'hooks/usePutEntity'

export default function HeroDetail() {
  const {id} = useParams()
  const {name, description} = useEntityParams()
  const [hero, setHero] = useState({id, name, description})
  const {mutate: createHero, status, error: postError} = usePostEntity('hero')
  const {
    updateEntity: updateHero,
    isUpdating,
    isUpdateError,
  } = usePutEntity('hero')

  const navigate = useNavigate()
  const handleCancel = () => navigate('/heroes')
  const handleSave = () =>
    name ? updateHero(hero as Hero) : createHero(hero as Hero)
  const handleNameChange = (e: ChangeEvent<HTMLInputElement>) => {
    setHero({...hero, name: e.target.value})
  }
  const handleDescriptionChange = (e: ChangeEvent<HTMLInputElement>) => {
    setHero({...hero, description: e.target.value})
  }

  if (status === 'loading' || isUpdating) {
    return <PageSpinner />
  }

  if (postError || isUpdateError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="hero-detail" className="card edit-detail">
      <header className="card-header">
        <p className="card-header-title">{name}</p>
        &nbsp;
      </header>
      <div className="card-content">
        <div className="content">
          {id && (
            <InputDetail name={'id'} value={id} readOnly={true}></InputDetail>
          )}
          <InputDetail
            name={'name'}
            value={name ? name : ''}
            placeholder="e.g. Colleen"
            onChange={handleNameChange}
          ></InputDetail>
          <InputDetail
            name={'description'}
            value={description ? description : ''}
            placeholder="e.g. dance fight!"
            onChange={handleDescriptionChange}
          ></InputDetail>
        </div>
      </div>
      <footer className="card-footer">
        <ButtonFooter
          label="Cancel"
          IconClass={FaUndo}
          onClick={handleCancel}
        />
        <ButtonFooter label="Save" IconClass={FaRegSave} onClick={handleSave} />
      </footer>
    </div>
  )
}



================================================
FILE: src/heroes/Heroes.cy.tsx
================================================
import Heroes from './Heroes'

describe('Heroes', () => {
  it('should see error on initial load with GET', () => {
    Cypress.on('uncaught:exception', () => false)
    cy.clock()
    cy.intercept('GET', `${Cypress.env('API_URL')}/heroes`, {
      statusCode: 400,
      delay: 100,
    }).as('notFound')

    cy.wrappedMount(<Heroes />)

    cy.getByCy('page-spinner').should('be.visible')
    Cypress._.times(3, () => {
      cy.tick(5100)
      cy.wait('@notFound')
    })
    cy.tick(5100)
  })

  context('200 flows', () => {
    beforeEach(() => {
      cy.intercept('GET', `${Cypress.env('API_URL')}/heroes`, {
        fixture: 'heroes.json',
      }).as('getHeroes')

      cy.wrappedMount(<Heroes />)
    })

    it('should display the hero list on render, and go through hero add & refresh flow', () => {
      cy.wait('@getHeroes')

      cy.getByCy('list-header').should('be.visible')
      cy.getByCy('hero-list').should('be.visible')

      cy.getByCy('add-button').click()
      cy.location('pathname').should('eq', '/heroes/add-hero')

      cy.getByCy('refresh-button').click()
      cy.location('pathname').should('eq', '/heroes')
    })

    const invokeHeroDelete = () => {
      cy.getByCy('delete-button').first().click()
      cy.getByCy('modal-yes-no').should('be.visible')
    }
    it('should go through the modal flow, and cover error on DELETE', () => {
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('do not delete flow')
      invokeHeroDelete()
      cy.getByCy('button-no').click()
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('delete flow')
      invokeHeroDelete()
      cy.intercept('DELETE', '*', {statusCode: 500}).as('deleteHero')

      cy.getByCy('button-yes').click()
      cy.wait('@deleteHero')
      cy.getByCy('modal-yes-no').should('not.exist')
      cy.getByCy('error').should('be.visible')
    })
  })
})



================================================
FILE: src/heroes/Heroes.test.tsx
================================================
import Heroes from './Heroes'
import {wrappedRender, screen, waitForElementToBeRemoved} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {rest} from 'msw'
import {setupServer} from 'msw/node'
import {heroes} from '../../db.json'

describe('Heroes', () => {
  // mute the expected console.error message, because we are mocking non-200 responses
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  jest.spyOn(console, 'error').mockImplementation(() => {})

  beforeEach(() => wrappedRender(<Heroes />))

  it('should see error on initial load with GET', async () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/heroes`, async (_req, res, ctx) =>
        res(ctx.status(400)),
      ),
    ]
    const server = setupServer(...handlers)
    server.listen({
      onUnhandledRequest: 'warn',
    })
    jest.useFakeTimers()

    expect(await screen.findByTestId('page-spinner')).toBeVisible()

    jest.advanceTimersByTime(25000)
    await waitForElementToBeRemoved(
      () => screen.queryByTestId('page-spinner'),
      {
        timeout: 25000,
      },
    )

    expect(await screen.findByTestId('error')).toBeVisible()
    jest.useRealTimers()
    server.resetHandlers()
    server.close()
  })

  describe('200 flows', () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/heroes`, async (_req, res, ctx) =>
        res(ctx.status(200), ctx.json(heroes)),
      ),
      rest.delete(
        `${process.env.VITE_API_URL}/heroes/${heroes[0].id}`, // use /.*/ for all requests
        async (_req, res, ctx) =>
          res(ctx.status(400), ctx.json('expected error')),
      ),
    ]
    const server = setupServer(...handlers)
    beforeAll(() => {
      server.listen({
        onUnhandledRequest: 'warn',
      })
    })
    afterEach(server.resetHandlers)
    afterAll(server.close)

    it('should display the hero list on render, and go through hero add & refresh flow', async () => {
      expect(await screen.findByTestId('list-header')).toBeVisible()
      expect(await screen.findByTestId('hero-list')).toBeVisible()

      await userEvent.click(await screen.findByTestId('add-button'))
      expect(window.location.pathname).toBe('/heroes/add-hero')

      await userEvent.click(await screen.findByTestId('refresh-button'))
      expect(window.location.pathname).toBe('/heroes')
    })

    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const modalYesNo = async () => screen.findByTestId('modal-yes-no')
    const maybeModalYesNo = () => screen.queryByTestId('modal-yes-no')
    const invokeHeroDelete = async () => {
      userEvent.click((await deleteButtons())[0])
      expect(await modalYesNo()).toBeVisible()
    }

    it('should go through the modal flow, and cover error on DELETE', async () => {
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()

      await invokeHeroDelete()
      await userEvent.click(await screen.findByTestId('button-no'))
      expect(maybeModalYesNo()).not.toBeInTheDocument()

      await invokeHeroDelete()
      await userEvent.click(await screen.findByTestId('button-yes'))

      expect(maybeModalYesNo()).not.toBeInTheDocument()
      expect(await screen.findByTestId('error')).toBeVisible()
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()
    })
  })
})



================================================
FILE: src/heroes/Heroes.tsx
================================================
import React, {useState} from 'react'
import {useNavigate, Routes, Route} from 'react-router-dom'
import ListHeader from 'components/ListHeader'
import ModalYesNo from 'components/ModalYesNo'
import ErrorComp from 'components/ErrorComp'
import HeroList from './HeroList'
import HeroDetail from './HeroDetail'
import {useGetEntities} from 'hooks/useGetEntities'
import {useDeleteEntity} from 'hooks/useDeleteEntity'
import type {Hero} from 'models/Hero'
import {curry} from 'ramda'

export default function Heroes() {
  const [showModal, setShowModal] = useState<boolean>(false)
  const {entities: heroes, getError} = useGetEntities('heroes')
  const [heroToDelete, setHeroToDelete] = useState<Hero | null>(null)
  const {deleteEntity: deleteHero, isDeleteError} = useDeleteEntity('hero')

  const navigate = useNavigate()
  const addNewHero = () => navigate('/heroes/add-hero')
  const handleRefresh = () => navigate('/heroes')

  const handleCloseModal = () => {
    setHeroToDelete(null)
    setShowModal(false)
  }
  // currying: the outer fn takes our custom arg and returns a fn that takes the event
  // const handleDeleteHero = (hero: Hero) => () => {
  //   setHeroToDelete(hero)
  //   setShowModal(true)
  // }
  // we can use Ramda curry instead, we have to pass the unused event argument though
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const handleDeleteHero = curry((hero: Hero, e: React.MouseEvent) => {
    setHeroToDelete(hero)
    setShowModal(true)
  })

  const handleDeleteFromModal = () => {
    heroToDelete ? deleteHero(heroToDelete) : null
    setShowModal(false)
  }

  if (getError || isDeleteError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="heroes">
      <ListHeader
        title="Heroes"
        handleAdd={addNewHero}
        handleRefresh={handleRefresh}
      />
      <div>
        <div>
          <Routes>
            <Route
              path=""
              element={
                <HeroList heroes={heroes} handleDeleteHero={handleDeleteHero} />
              }
            />
            <Route path="/add-hero" element={<HeroDetail />} />
            <Route path="/edit-hero/:id" element={<HeroDetail />} />
            <Route
              path="*"
              element={
                <HeroList heroes={heroes} handleDeleteHero={handleDeleteHero} />
              }
            />
          </Routes>
        </div>
      </div>

      {showModal && (
        <ModalYesNo
          message="Would you like to delete the hero?"
          onNo={handleCloseModal}
          onYes={handleDeleteFromModal}
        />
      )}
    </div>
  )
}



================================================
FILE: src/heroes/HeroList.cy.tsx
================================================
import HeroList from './HeroList'

import heroes from '../../cypress/fixtures/heroes.json'

describe('HeroList', () => {
  it('no heroes should not display a list nor search bar', () => {
    cy.wrappedMount(
      <HeroList
        heroes={[]}
        handleDeleteHero={cy.stub().as('handleDeleteHero')}
      />,
    )

    cy.getByCy('hero-list').should('exist')
    cy.getByCyLike('hero-list-item').should('not.exist')
    cy.getByCy('search').should('not.exist')
  })

  context('with heroes in the list', () => {
    beforeEach(() => {
      cy.wrappedMount(
        <HeroList
          heroes={heroes}
          handleDeleteHero={cy.stub().as('handleDeleteHero')}
        />,
      )
    })

    it('should render the hero layout', () => {
      cy.getByCyLike('hero-list-item').should('have.length', heroes.length)

      cy.getByCy('card-content')
      cy.contains(heroes[0].name)
      cy.contains(heroes[0].description)

      cy.get('footer')
        .first()
        .within(() => {
          cy.getByCy('delete-button')
          cy.getByCy('edit-button')
        })
    })

    it('should search and filter hero by name and description', () => {
      cy.getByCy('search').type(heroes[0].name)
      cy.getByCyLike('hero-list-item')
        .should('have.length', 1)
        .contains(heroes[0].name)

      cy.getByCy('search').clear().type(heroes[2].description)
      cy.getByCyLike('hero-list-item')
        .should('have.length', 1)
        .contains(heroes[2].description)
    })

    it('should handle delete', () => {
      cy.getByCy('delete-button').first().click()
      cy.get('@handleDeleteHero').should('have.been.called')
    })

    it('should handle edit', () => {
      cy.getByCy('edit-button').first().click()
      cy.location('pathname').should('eq', '/heroes/edit-hero/' + heroes[0].id)
    })
  })
})



================================================
FILE: src/heroes/HeroList.test.tsx
================================================
import HeroList from './HeroList'
import {wrappedRender, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {heroes} from '../../db.json'

describe('HeroList', () => {
  const handleDeleteHero = jest.fn()

  it('no heroes should not display a list nor search bar', async () => {
    wrappedRender(<HeroList heroes={[]} handleDeleteHero={handleDeleteHero} />)

    expect(await screen.findByTestId('hero-list')).toBeInTheDocument()
    expect(screen.queryByTestId('hero-list-item-1')).not.toBeInTheDocument()
    expect(screen.queryByTestId('search-bar')).not.toBeInTheDocument()
  })

  describe('with heroes in the list', () => {
    beforeEach(() => {
      wrappedRender(
        <HeroList heroes={heroes} handleDeleteHero={handleDeleteHero} />,
      )
    })

    const cardContents = async () => screen.findAllByTestId('card-content')
    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const editButtons = async () => screen.findAllByTestId('edit-button')

    it('should render the hero layout', async () => {
      expect(
        await screen.findByTestId(`hero-list-item-${heroes.length - 1}`),
      ).toBeInTheDocument()

      expect(await screen.findByText(heroes[0].name)).toBeInTheDocument()
      expect(await screen.findByText(heroes[0].description)).toBeInTheDocument()
      expect(await cardContents()).toHaveLength(heroes.length)
      expect(await deleteButtons()).toHaveLength(heroes.length)
      expect(await editButtons()).toHaveLength(heroes.length)
    })

    it('should search and filter hero by name and description', async () => {
      const search = await screen.findByTestId('search')

      userEvent.type(search, heroes[0].name)
      await waitFor(async () => expect(await cardContents()).toHaveLength(6))
      await screen.findByText(heroes[0].name)

      userEvent.clear(search)
      await waitFor(async () =>
        expect(await cardContents()).toHaveLength(heroes.length),
      )

      userEvent.type(search, heroes[2].description)
      await waitFor(async () => expect(await cardContents()).toHaveLength(1))
    })

    it('should handle delete', async () => {
      userEvent.click((await deleteButtons())[0])
      expect(handleDeleteHero).toHaveBeenCalled()
    })

    it('should handle edit', async () => {
      userEvent.click((await editButtons())[0])
      await waitFor(() =>
        expect(window.location.pathname).toEqual(
          '/heroes/edit-hero/' + heroes[0].id,
        ),
      )
    })
  })
})



================================================
FILE: src/heroes/HeroList.tsx
================================================
import {useNavigate} from 'react-router-dom'
import CardContent from 'components/CardContent'
import ButtonFooter from 'components/ButtonFooter'
import {FaEdit, FaRegSave} from 'react-icons/fa'
import type {ChangeEvent, MouseEvent} from 'react'
import {useTransition, useEffect, useState, useDeferredValue} from 'react'
import type {Hero} from 'models/Hero'
import type {HeroProperty} from 'models/types'
import {curry} from 'ramda'

type HeroListProps = {
  heroes: Hero[]
  handleDeleteHero: (hero: Hero) => (e: MouseEvent<HTMLButtonElement>) => void
}

export default function HeroList({heroes, handleDeleteHero}: HeroListProps) {
  const deferredHeroes = useDeferredValue(heroes)
  const isStale = deferredHeroes !== heroes
  const [filteredHeroes, setFilteredHeroes] = useState(deferredHeroes)
  const navigate = useNavigate()
  const [isPending, startTransition] = useTransition()

  // needed to refresh the list after deleting a hero
  useEffect(() => setFilteredHeroes(deferredHeroes), [deferredHeroes])

  // currying: the outer fn takes our custom arg and returns a fn that takes the event
  // const handleSelectHero = (heroId: string) => () => {
  //   const hero = deferredHeroes.find((h: Hero) => h.id === heroId)
  //   navigate(
  //     `/heroes/edit-hero/${hero?.id}?name=${hero?.name}&description=${hero?.description}`,
  //   )
  // }
  // we can use Ramda curry instead, we have to pass the unused event argument though
  const handleSelectHero = curry(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (heroId: string, e: MouseEvent<HTMLButtonElement>) => {
      const hero = deferredHeroes.find((h: Hero) => h.id === heroId)
      navigate(
        `/heroes/edit-hero/${hero?.id}?name=${hero?.name}&description=${hero?.description}`,
      )
    },
  )

  /** returns a boolean whether the hero properties exist in the search field */
  const searchExists = (searchProperty: HeroProperty, searchField: string) =>
    String(searchProperty).toLowerCase().indexOf(searchField.toLowerCase()) !==
    -1

  /** given the data and the search field, returns the data in which the search field exists */
  const searchProperties = (searchField: string, data: Hero[]) =>
    [...data].filter((item: Hero) =>
      Object.values(item).find((property: HeroProperty) =>
        searchExists(property, searchField),
      ),
    )

  /** filters the heroes data to see if the any of the properties exist in the list */
  const handleSearch =
    (data: Hero[]) => (event: ChangeEvent<HTMLInputElement>) => {
      const searchField = event.target.value

      return startTransition(() =>
        setFilteredHeroes(searchProperties(searchField, data)),
      )
    }

  return (
    <div
      style={{
        opacity: isPending ? 0.5 : 1,
        color: isStale ? 'dimgray' : 'black',
      }}
    >
      {deferredHeroes.length > 0 && (
        <div className="card-content">
          <span>Search </span>
          <input data-cy="search" onChange={handleSearch(deferredHeroes)} />
        </div>
      )}
      &nbsp;
      <ul data-cy="hero-list" className="list">
        {filteredHeroes.map((hero, index) => (
          <li data-cy={`hero-list-item-${index}`} key={hero.id}>
            <div className="card">
              <CardContent name={hero.name} description={hero.description} />
              <footer className="card-footer">
                <ButtonFooter
                  label="Delete"
                  IconClass={FaRegSave}
                  onClick={handleDeleteHero(hero)}
                />
                <ButtonFooter
                  label="Edit"
                  IconClass={FaEdit}
                  onClick={handleSelectHero(hero.id)}
                />
              </footer>
            </div>
          </li>
        ))}
      </ul>
    </div>
  )
}



================================================
FILE: src/hooks/useDeleteEntity.ts
================================================
import type {Boy} from 'models/Boy'
import type {Hero} from 'models/Hero'
import type {EntityType} from 'models/types'
import {entityRoute} from 'models/types'
import type {Villain} from 'models/Villain'
import {useMutation, useQueryClient} from 'react-query'
import {useNavigate} from 'react-router-dom'
import {deleteItem} from '../api/api'

/**
 * Helper for DELETE to `/heroes`, `/villains` or 'boys' routes.
 * @returns {object} {deleteEntity, isDeleting, isDeleteError, deleteError}
 */
export function useDeleteEntity(entityType: EntityType) {
  const route = entityRoute(entityType)
  const navigate = useNavigate()
  const queryClient = useQueryClient()

  const mutation = useMutation(
    (item: Hero | Villain | Boy) => deleteItem(`${route}/${item.id}`),
    {
      // on success receives the original item as a second argument
      // if you recall, the first argument is the created item
      onSuccess: (_, deletedEntity: Hero | Villain | Boy) => {
        // get all the entities from the cache
        const entities: Hero[] | Villain[] | Boy[] =
          queryClient.getQueryData([`${route}`]) || []
        // set the entities cache without the delete one
        queryClient.setQueryData(
          [`${route}`],
          entities.filter(h => h.id !== deletedEntity.id),
        )

        navigate(`/${route}`)
      },
    },
  )

  return {
    deleteEntity: mutation.mutate,
    isDeleting: mutation.isLoading,
    isDeleteError: mutation.isError,
    deleteError: mutation.error,
  }
}



================================================
FILE: src/hooks/useEntityParams.ts
================================================
import {useSearchParams} from 'react-router-dom'

export function useEntityParams() {
  const [searchParams] = useSearchParams()
  const name = searchParams.get('name')
  const description = searchParams.get('description')

  return {name, description}
}



================================================
FILE: src/hooks/useGetEntities.ts
================================================
import type {EntityRoute} from 'models/types'
import {useQuery} from 'react-query'
import {getItem} from '../api/api'

/**
 * Helper for GET to `/heroes` or `/villains` routes
 * @returns {object} {entities, status, getError}
 */
export const useGetEntities = (entityRoute: EntityRoute) => {
  const query = useQuery(entityRoute, () => getItem(entityRoute), {
    suspense: true,
  })

  return {
    entities: query.data,
    status: query.status,
    getError: query.error,
  }
}

// useQuery is similar to our custom useAxios: takes a url, returns an object of data, status & error
// the key arg is a unique identifier for the query / data in cache; string, array or object
// the 2nd arg an async function that returns the data
// const { data, status, error } = useQuery(key, () => fetch(url))
// Whenever any component subsequently calls useQuery with the key,
// React Query will return the previously fetched  data from its cache
// and then fetch the latest data in the background (very similar to PWAs and service workers)
// useQuery takes a third arg as a configuration option
// which tells useQuery to suspend (throw a promise) when loading its initial data



================================================
FILE: src/hooks/usePostEntity.ts
================================================
import type {Boy} from 'models/Boy'
import type {Hero} from 'models/Hero'
import type {EntityType} from 'models/types'
import {entityRoute} from 'models/types'
import type {Villain} from 'models/Villain'
import {useMutation, useQueryClient} from 'react-query'
import {useNavigate} from 'react-router-dom'
import {createItem} from '../api/api'

/**
 * Helper for simple POST to `/heroes`, `/villains`, `/boys` routes
 * @returns {object} {mutate, status, error}
 */
export function usePostEntity(entityType: EntityType) {
  const route = entityRoute(entityType)
  const queryClient = useQueryClient()
  const navigate = useNavigate()
  return useMutation((item: Hero | Villain | Boy) => createItem(route, item), {
    onSuccess: (newData: Hero | Villain | Boy) => {
      //  use queryClient's setQueryData to set the cache
      // takes a key as the first arg, the 2nd arg is a cb that takes the old query cache and returns the new one
      queryClient.setQueryData(
        [route],
        (oldData: Hero[] | Villain[] | Boy[] | undefined) => [
          ...(oldData || []),
          newData,
        ],
      )

      return navigate(`/${route}`)
    },
  })
}

// why useMutation?
// useParams and useQuery fetch state: UI state <- server/url , and caches it
// useMutation is just the opposite: UI state -> server , and still caches it
// yields data, status, error just like useQuery (10.4.2)
// const { dataToMutate, status, error } = useMutation((item) => createItem(url, item)
// the first arg is a function that that executes a non-idempotent request
// the second arg is an object with onSuccess property



================================================
FILE: src/hooks/usePutEntity.ts
================================================
import type {Hero} from 'models/Hero'
import type {Boy} from 'models/Boy'
import type {Villain} from 'models/Villain'
import type {EntityType} from 'models/types'
import {entityRoute} from 'models/types'
import {useMutation, useQueryClient} from 'react-query'
import type {QueryClient} from 'react-query'
import {useNavigate} from 'react-router-dom'
import {editItem} from '../api/api'

/**
 * Helper for PUT to `/heroes` route
 * @returns {object} {updateHero, isUpdating, isUpdateError, updateError}
 */
export function usePutEntity(entityType: EntityType) {
  const route = entityRoute(entityType)
  const queryClient = useQueryClient()
  const navigate = useNavigate()
  const mutation = useMutation(
    (item: Hero | Villain | Boy) => editItem(`${route}/${item.id}`, item),
    {
      onSuccess: (updatedEntity: Hero | Villain | Boy) => {
        updateEntityCache(entityType, updatedEntity, queryClient)
        navigate(`/${route}`)
      },
    },
  )

  return {
    updateEntity: mutation.mutate,
    isUpdating: mutation.isLoading,
    isUpdateError: mutation.isError,
    updateError: mutation.error,
  }
}

/** Replace a hero in the cache with the updated version. */
function updateEntityCache(
  entityType: EntityType,
  updatedEntity: Hero | Villain | Boy,
  queryClient: QueryClient,
) {
  const route = entityRoute(entityType)
  // get all the heroes from the cache
  let entityCache: Hero[] | Villain[] | Boy[] =
    queryClient.getQueryData(route) || []

  // find the index in the cache of the hero that's been edited
  const entityIndex = entityCache.findIndex(h => h.id === updatedEntity.id)

  if (entityIndex !== -1) {
    // if the entity is found, replace the pre-edited entity with the updated one
    // this is just replacing an array item in place,
    // while not mutating the original array
    entityCache = entityCache.map(preEditedEntity =>
      preEditedEntity.id === updatedEntity.id ? updatedEntity : preEditedEntity,
    )
    console.log('entityCache is', entityCache)
    // use queryClient's setQueryData to set the cache
    // takes a key as the first arg, the 2nd arg is the new cache
    return queryClient.setQueryData([route], entityCache)
  }
}



================================================
FILE: src/hooks/useVillainsContext.ts
================================================
import type {SetStateAction, Dispatch} from 'react'
import {createContext, useContext} from 'react'
import type {Villain} from 'models/Villain'

// Context api lets us pass a value deep into the component tree
// without explicitly threading it through every component (2nd tier state management)

const VillainsContext = createContext<Villain[]>([])
// to be used as VillainsContext.Provider,
// takes a prop as `value`, which is the context/data/state to share
export default VillainsContext

const VillainsSetContext = createContext<Dispatch<
  SetStateAction<Villain[] | null>
> | null>(null)

// Manage state and effects related to a hook’s functionality
// within the hook and return only the value(s) that components need

export function useVillainsContext() {
  const villains = useContext(VillainsContext)
  const setVillains = useContext(VillainsSetContext)

  return [villains, setVillains] as const
}



================================================
FILE: src/models/Boy.ts
================================================
export interface Boy {
  id: string
  name: string
  description: string
}

/* istanbul ignore file */



================================================
FILE: src/models/Hero.ts
================================================
export interface Hero {
  id: string
  name: string
  description: string
}

/* istanbul ignore file */



================================================
FILE: src/models/types.ts
================================================
import type {Hero} from './Hero'
import type {Villain} from './Villain'
import type {Boy} from './Boy'

export type HeroProperty = Hero['name'] | Hero['description'] | Hero['id']
export type VillainProperty =
  | Villain['name']
  | Villain['description']
  | Villain['id']

export type BoyProperty = Boy['name'] | Boy['description'] | Boy['id']
export type EntityRoute = 'heroes' | 'villains' | 'boys'
export type EntityType = 'hero' | 'villain' | 'boy'

/** Returns the corresponding route for the entity;
 *
 * `hero` -> `/heroes`, `villain` -> `/villains`, `boy` -> `/boys` */
export const entityRoute = (entityType: EntityType) =>
  entityType === 'hero'
    ? 'heroes'
    : entityType === 'villain'
    ? 'villains'
    : 'boys'

/* istanbul ignore file */



================================================
FILE: src/models/Villain.ts
================================================
export interface Villain {
  id: string
  name: string
  description: string
}

/* istanbul ignore file */



================================================
FILE: src/villains/VillainDetail.cy.tsx
================================================
import VillainDetail from './VillainDetail'

import React from 'react'
import * as postHook from 'hooks/usePostEntity' // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
import '@testing-library/cypress/add-commands'

describe('VillainDetail', () => {
  beforeEach(() => {
    cy.wrappedMount(<VillainDetail />)
  })

  it('should handle Save', () => {
    // example of testing implementation details
    cy.spy(React, 'useState').as('useState')
    cy.spy(postHook, 'usePostEntity').as('usePostEntity') // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
    // instead prefer to test at a higher level
    cy.intercept('POST', '*', {statusCode: 200}).as('postVillain')
    cy.getByCy('save-button').click()

    // test at a higher level
    cy.wait('@postVillain')
    // test implementation details (what not to do)
    cy.get('@useState').should('have.been.called')
    cy.get('@usePostEntity').should('have.been.called') // TODO: wait for https://github.com/cypress-io/cypress/issues/22355
  })

  it('should handle non-200 Save', () => {
    cy.intercept('POST', '*', {statusCode: 400, delay: 100}).as('postVillain')
    cy.getByCy('save-button').click()
    cy.getByCy('spinner')
    cy.wait('@postVillain')
    cy.getByCy('error')
  })

  it('should handle Cancel', () => {
    cy.getByCy('cancel-button').click()
    cy.location('pathname').should('eq', '/villains')
  })

  it('should handle name change', () => {
    const newVillainName = 'abc'
    cy.getByCy('input-detail-name').type(newVillainName)

    cy.findByDisplayValue(newVillainName).should('be.visible')
  })

  it('should handle description change', () => {
    const newVillainDescription = '123'
    cy.getByCy('input-detail-description').type(newVillainDescription)

    cy.findByDisplayValue(newVillainDescription).should('be.visible')
  })

  it('id: false, name: false - should verify the minimal state of the component', () => {
    cy.get('p').then($el => cy.wrap($el.text()).should('equal', ''))
    cy.getByCyLike('input-detail').should('have.length', 2)
    cy.getByCy('input-detail-id').should('not.exist')

    cy.findByPlaceholderText('e.g. Colleen').should('be.visible')
    cy.findByPlaceholderText('e.g. dance fight!').should('be.visible')

    cy.getByCy('save-button').should('be.visible')
    cy.getByCy('cancel-button').should('be.visible')
  })
})



================================================
FILE: src/villains/VillainDetail.test.tsx
================================================
import VillainDetail from './VillainDetail'
import '@testing-library/jest-dom'
import {wrappedRender, act, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'

describe('VillainDetail', () => {
  beforeEach(() => {
    wrappedRender(<VillainDetail />)
  })

  // with msw, it is not recommended to use verify XHR calls going out of the app
  // instead, the advice is the verify the changes in the UI
  // alas, sometimes there are no changes in the component itself
  // therefore we cannot test everything 1:1 versus Cypress component test
  // should handle Save and should handle non-200 Save have no RTL mirrors

  it('should handle Cancel', async () => {
    // code that causes React state updates (ex: BrowserRouter)
    // should be wrapped into act(...):
    // userEvent.click(await screen.findByTestId('cancel-button')) // won't work
    act(() => screen.getByTestId('cancel-button').click())

    expect(window.location.pathname).toBe('/villains')
  })

  it('should handle name change', async () => {
    const newVillainName = 'abc'
    const inputDetailName = await screen.findByPlaceholderText('e.g. Colleen')
    userEvent.type(inputDetailName, newVillainName)

    await waitFor(async () =>
      expect(inputDetailName).toHaveDisplayValue(newVillainName),
    )
  })

  const inputDetailDescription = async () =>
    screen.findByPlaceholderText('e.g. dance fight!')

  it('should handle description change', async () => {
    const newVillainDescription = '123'

    userEvent.type(await inputDetailDescription(), newVillainDescription)
    await waitFor(async () =>
      expect(await inputDetailDescription()).toHaveDisplayValue(
        newVillainDescription,
      ),
    )
  })

  it('id: false, name: false - should verify the minimal state of the component', async () => {
    expect(await screen.findByTestId('input-detail-name')).toBeVisible()
    expect(await screen.findByTestId('input-detail-description')).toBeVisible()
    expect(screen.queryByTestId('input-detail-id')).not.toBeInTheDocument()

    expect(await inputDetailDescription()).toBeVisible()

    expect(await screen.findByTestId('save-button')).toBeVisible()
    expect(await screen.findByTestId('cancel-button')).toBeVisible()
  })
})



================================================
FILE: src/villains/VillainDetail.tsx
================================================
import type {ChangeEvent} from 'react'
import {useState} from 'react'
import {useNavigate, useParams} from 'react-router-dom'
import {FaUndo, FaRegSave} from 'react-icons/fa'
import InputDetail from 'components/InputDetail'
import ButtonFooter from 'components/ButtonFooter'
import PageSpinner from 'components/PageSpinner'
import ErrorComp from 'components/ErrorComp'
import {useEntityParams} from 'hooks/useEntityParams'
import {usePostEntity} from 'hooks/usePostEntity'
import type {Villain} from 'models/Villain'
import {usePutEntity} from 'hooks/usePutEntity'

export default function VillainDetail() {
  const {id} = useParams()
  const {name, description} = useEntityParams()
  const [villain, setVillain] = useState({id, name, description})
  const {
    mutate: createVillain,
    status,
    error: postError,
  } = usePostEntity('villain')
  const {
    updateEntity: updateVillain,
    isUpdating,
    isUpdateError,
  } = usePutEntity('villain')

  const navigate = useNavigate()
  const handleCancel = () => navigate('/villains')
  const handleSave = () =>
    name ? updateVillain(villain as Villain) : createVillain(villain as Villain)
  const handleNameChange = (e: ChangeEvent<HTMLInputElement>) => {
    setVillain({...villain, name: e.target.value})
  }
  const handleDescriptionChange = (e: ChangeEvent<HTMLInputElement>) => {
    setVillain({...villain, description: e.target.value})
  }

  if (status === 'loading' || isUpdating) {
    return <PageSpinner />
  }

  if (postError || isUpdateError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="villain-detail" className="card edit-detail">
      <header className="card-header">
        <p className="card-header-title">{name}</p>
        &nbsp;
      </header>
      <div className="card-content">
        <div className="content">
          {id && (
            <InputDetail name={'id'} value={id} readOnly={true}></InputDetail>
          )}
          <InputDetail
            name={'name'}
            value={name ? name : ''}
            placeholder="e.g. Colleen"
            onChange={handleNameChange}
          ></InputDetail>
          <InputDetail
            name={'description'}
            value={description ? description : ''}
            placeholder="e.g. dance fight!"
            onChange={handleDescriptionChange}
          ></InputDetail>
        </div>
      </div>
      <footer className="card-footer">
        <ButtonFooter
          label="Cancel"
          IconClass={FaUndo}
          onClick={handleCancel}
        />
        <ButtonFooter label="Save" IconClass={FaRegSave} onClick={handleSave} />
      </footer>
    </div>
  )
}



================================================
FILE: src/villains/VillainList.cy.tsx
================================================
import VillainList from './VillainList'

import villains from '../../cypress/fixtures/villains.json'
import VillainsContext from 'hooks/useVillainsContext'

describe('VillainList', () => {
  it('no villains should not display a list nor search bar', () => {
    cy.wrappedMount(
      <VillainList handleDeleteVillain={cy.stub().as('handleDeleteVillain')} />,
    )

    cy.getByCy('villain-list').should('exist')
    cy.getByCyLike('villain-list-item').should('not.exist')
    cy.getByCy('search').should('not.exist')
  })

  context('with villains in the list', () => {
    beforeEach(() => {
      cy.wrappedMount(
        <VillainsContext.Provider value={villains}>
          <VillainList
            handleDeleteVillain={cy.stub().as('handleDeleteVillain')}
          />
        </VillainsContext.Provider>,
      )
    })

    it('should render the villain layout', () => {
      cy.getByCyLike('villain-list-item').should('have.length', villains.length)

      cy.getByCy('card-content')
      cy.contains(villains[0].name)
      cy.contains(villains[0].description)

      cy.get('footer')
        .first()
        .within(() => {
          cy.getByCy('delete-button')
          cy.getByCy('edit-button')
        })
    })

    it('should search and filter villain by name and description', () => {
      cy.getByCy('search').type(villains[0].name)
      cy.getByCyLike('villain-list-item')
        .should('have.length', 1)
        .contains(villains[0].name)

      cy.getByCy('search').clear().type(villains[2].description)
      cy.getByCyLike('villain-list-item')
        .should('have.length', 1)
        .contains(villains[2].description)
    })

    it('should handle delete', () => {
      cy.getByCy('delete-button').first().click()
      cy.get('@handleDeleteVillain').should('have.been.called')
    })

    it('should handle edit', () => {
      cy.getByCy('edit-button').first().click()
      cy.location('pathname').should(
        'eq',
        '/villains/edit-villain/' + villains[0].id,
      )
    })
  })
})



================================================
FILE: src/villains/VillainList.test.tsx
================================================
import VillainList from './VillainList'
import {wrappedRender, screen, waitFor} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {villains} from '../../db.json'
import VillainsContext from 'hooks/useVillainsContext'

describe('VillainList', () => {
  const handleDeleteVillain = jest.fn()

  it('no villains should not display a list nor search bar', async () => {
    wrappedRender(<VillainList handleDeleteVillain={handleDeleteVillain} />)

    expect(await screen.findByTestId('villain-list')).toBeInTheDocument()
    expect(screen.queryByTestId('villain-list-item-1')).not.toBeInTheDocument()
    expect(screen.queryByTestId('search-bar')).not.toBeInTheDocument()
  })

  describe('with villains in the list', () => {
    beforeEach(() => {
      wrappedRender(
        <VillainsContext.Provider value={villains}>
          <VillainList handleDeleteVillain={handleDeleteVillain} />
        </VillainsContext.Provider>,
      )
    })

    const cardContents = async () => screen.findAllByTestId('card-content')
    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const editButtons = async () => screen.findAllByTestId('edit-button')

    it('should render the villain layout', async () => {
      expect(
        await screen.findByTestId(`villain-list-item-${villains.length - 1}`),
      ).toBeInTheDocument()

      expect(await screen.findByText(villains[0].name)).toBeInTheDocument()
      expect(
        await screen.findByText(villains[0].description),
      ).toBeInTheDocument()
      expect(await cardContents()).toHaveLength(villains.length)
      expect(await deleteButtons()).toHaveLength(villains.length)
      expect(await editButtons()).toHaveLength(villains.length)
    })

    it('should search and filter villain by name and description', async () => {
      const search = await screen.findByTestId('search')

      userEvent.type(search, villains[0].name)
      await waitFor(async () => expect(await cardContents()).toHaveLength(4))
      await screen.findByText(villains[0].name)

      userEvent.clear(search)
      await waitFor(async () =>
        expect(await cardContents()).toHaveLength(villains.length),
      )

      userEvent.type(search, villains[2].description)
      await waitFor(async () => expect(await cardContents()).toHaveLength(1))
    })

    it('should handle delete', async () => {
      userEvent.click((await deleteButtons())[0])
      expect(handleDeleteVillain).toHaveBeenCalled()
    })

    it('should handle edit', async () => {
      userEvent.click((await editButtons())[0])
      await waitFor(() =>
        expect(window.location.pathname).toEqual(
          '/villains/edit-villain/' + villains[0].id,
        ),
      )
    })
  })
})



================================================
FILE: src/villains/VillainList.tsx
================================================
import {useNavigate} from 'react-router-dom'
import CardContent from 'components/CardContent'
import ButtonFooter from 'components/ButtonFooter'
import {FaEdit, FaRegSave} from 'react-icons/fa'
import type {ChangeEvent, MouseEvent} from 'react'
import {useTransition, useEffect, useState, useDeferredValue} from 'react'
import {useVillainsContext} from 'hooks/useVillainsContext'
import type {Villain} from 'models/Villain'

type VillainListProps = {
  handleDeleteVillain: (
    villain: Villain,
  ) => (e: MouseEvent<HTMLButtonElement>) => void
}

export default function VillainList({handleDeleteVillain}: VillainListProps) {
  const [villains] = useVillainsContext()

  const deferredVillains = useDeferredValue(villains)
  const isStale = deferredVillains !== villains
  const [filteredVillains, setFilteredVillains] = useState(deferredVillains)
  const navigate = useNavigate()
  const [isPending, startTransition] = useTransition()

  // needed to refresh the list after deleting a villain
  useEffect(() => setFilteredVillains(deferredVillains), [deferredVillains])

  // currying: the outer fn takes our custom arg and returns a fn that takes the event
  const handleSelectVillain = (villainId: string) => () => {
    const villain = deferredVillains.find((h: Villain) => h.id === villainId)
    navigate(
      `/villains/edit-villain/${villain?.id}?name=${villain?.name}&description=${villain?.description}`,
    )
  }

  type VillainProperty =
    | Villain['name']
    | Villain['description']
    | Villain['id']

  /** returns a boolean whether the villain properties exist in the search field */
  const searchExists = (searchProperty: VillainProperty, searchField: string) =>
    String(searchProperty).toLowerCase().indexOf(searchField.toLowerCase()) !==
    -1

  /** given the data and the search field, returns the data in which the search field exists */
  const searchProperties = (searchField: string, data: Villain[]) =>
    [...data].filter((item: Villain) =>
      Object.values(item).find((property: VillainProperty) =>
        searchExists(property, searchField),
      ),
    )

  /** filters the villains data to see if the any of the properties exist in the list */
  const handleSearch =
    (data: Villain[]) => (event: ChangeEvent<HTMLInputElement>) => {
      const searchField = event.target.value

      return startTransition(() =>
        setFilteredVillains(searchProperties(searchField, data)),
      )
    }

  return (
    <div
      style={{
        opacity: isPending ? 0.5 : 1,
        color: isStale ? 'dimgray' : 'black',
      }}
    >
      {deferredVillains.length > 0 && (
        <div className="card-content">
          <span>Search </span>
          <input data-cy="search" onChange={handleSearch(deferredVillains)} />
        </div>
      )}
      &nbsp;
      <ul data-cy="villain-list" className="list">
        {filteredVillains.map((villain, index) => (
          <li data-cy={`villain-list-item-${index}`} key={villain.id}>
            <div className="card">
              <CardContent
                name={villain.name}
                description={villain.description}
              />
              <footer className="card-footer">
                <ButtonFooter
                  label="Delete"
                  IconClass={FaRegSave}
                  onClick={handleDeleteVillain(villain)}
                />
                <ButtonFooter
                  label="Edit"
                  IconClass={FaEdit}
                  onClick={handleSelectVillain(villain.id)}
                />
              </footer>
            </div>
          </li>
        ))}
      </ul>
    </div>
  )
}



================================================
FILE: src/villains/Villains.cy.tsx
================================================
import Villains from './Villains'

describe('Villains', () => {
  it('should see error on initial load with GET', () => {
    Cypress.on('uncaught:exception', () => false)
    cy.clock()
    cy.intercept('GET', `${Cypress.env('API_URL')}/villains`, {
      statusCode: 400,
      delay: 100,
    }).as('notFound')

    cy.wrappedMount(<Villains />)

    cy.getByCy('page-spinner').should('be.visible')
    Cypress._.times(3, () => {
      cy.tick(5100)
      cy.wait('@notFound')
    })
    cy.tick(5100)

    cy.getByCy('error')
  })

  context('200 flows', () => {
    beforeEach(() => {
      cy.intercept('GET', `${Cypress.env('API_URL')}/villains`, {
        fixture: 'villains.json',
      }).as('getVillains')

      cy.wrappedMount(<Villains />)
    })

    it('should display the villain list on render, and go through villain add & refresh flow', () => {
      cy.wait('@getVillains')

      cy.getByCy('list-header').should('be.visible')
      cy.getByCy('villain-list').should('be.visible')

      cy.getByCy('add-button').click()
      cy.location('pathname').should('eq', '/villains/add-villain')

      cy.getByCy('refresh-button').click()
      cy.location('pathname').should('eq', '/villains')
    })

    const invokeVillainDelete = () => {
      cy.getByCy('delete-button').first().click()
      cy.getByCy('modal-yes-no').should('be.visible')
    }
    it('should go through the modal flow, and cover error on DELETE', () => {
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('do not delete flow')
      invokeVillainDelete()
      cy.getByCy('button-no').click()
      cy.getByCy('modal-yes-no').should('not.exist')

      cy.log('delete flow')
      invokeVillainDelete()
      cy.intercept('DELETE', '*', {statusCode: 500}).as('deleteVillain')

      cy.getByCy('button-yes').click()
      cy.wait('@deleteVillain')
      cy.getByCy('modal-yes-no').should('not.exist')
      cy.getByCy('error').should('be.visible')
    })
  })
})



================================================
FILE: src/villains/Villains.test.tsx
================================================
import Villains from './Villains'
import {wrappedRender, screen, waitForElementToBeRemoved} from '../test-utils'
import userEvent from '@testing-library/user-event'
import {rest} from 'msw'
import {setupServer} from 'msw/node'
import {villains} from '../../db.json'

describe('Villains', () => {
  // mute the expected console.error message, because we are mocking non-200 responses
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  jest.spyOn(console, 'error').mockImplementation(() => {})

  beforeEach(() => wrappedRender(<Villains />))

  it('should see error on initial load with GET', async () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/villains`, async (_req, res, ctx) =>
        res(ctx.status(500)),
      ),
    ]
    const server = setupServer(...handlers)
    server.listen({
      onUnhandledRequest: 'warn',
    })
    jest.useFakeTimers()

    expect(await screen.findByTestId('page-spinner')).toBeVisible()

    jest.advanceTimersByTime(30000)
    await waitForElementToBeRemoved(
      () => screen.queryByTestId('page-spinner'),
      {
        timeout: 30000,
      },
    )

    expect(await screen.findByTestId('error')).toBeVisible()
    jest.useRealTimers()
    server.resetHandlers()
    server.close()
  })

  describe('200 flows', () => {
    const handlers = [
      rest.get(`${process.env.VITE_API_URL}/villains`, async (_req, res, ctx) =>
        res(ctx.status(200), ctx.json(villains)),
      ),
      rest.delete(
        `${process.env.VITE_API_URL}/villains/${villains[0].id}`, // use /.*/ for all requests
        async (_req, res, ctx) =>
          res(ctx.status(400), ctx.json('expected error')),
      ),
    ]
    const server = setupServer(...handlers)
    beforeAll(() => {
      server.listen({
        onUnhandledRequest: 'warn',
      })
    })
    afterEach(server.resetHandlers)
    afterAll(server.close)

    it('should display the villain list on render, and go through villain add & refresh flow', async () => {
      expect(await screen.findByTestId('list-header')).toBeVisible()
      expect(await screen.findByTestId('villain-list')).toBeVisible()

      await userEvent.click(await screen.findByTestId('add-button'))
      expect(window.location.pathname).toBe('/villains/add-villain')

      await userEvent.click(await screen.findByTestId('refresh-button'))
      expect(window.location.pathname).toBe('/villains')
    })

    const deleteButtons = async () => screen.findAllByTestId('delete-button')
    const modalYesNo = async () => screen.findByTestId('modal-yes-no')
    const maybeModalYesNo = () => screen.queryByTestId('modal-yes-no')
    const invokeVillainDelete = async () => {
      userEvent.click((await deleteButtons())[0])
      expect(await modalYesNo()).toBeVisible()
    }

    it('should go through the modal flow, and cover error on DELETE', async () => {
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()

      await invokeVillainDelete()
      await userEvent.click(await screen.findByTestId('button-no'))
      expect(maybeModalYesNo()).not.toBeInTheDocument()

      await invokeVillainDelete()
      await userEvent.click(await screen.findByTestId('button-yes'))

      expect(maybeModalYesNo()).not.toBeInTheDocument()
      expect(await screen.findByTestId('error')).toBeVisible()
      expect(screen.queryByTestId('modal-dialog')).not.toBeInTheDocument()
    })
  })
})



================================================
FILE: src/villains/Villains.tsx
================================================
import {useState} from 'react'
import {useNavigate, Routes, Route} from 'react-router-dom'
import ListHeader from 'components/ListHeader'
import ModalYesNo from 'components/ModalYesNo'
import ErrorComp from 'components/ErrorComp'
import VillainList from './VillainList'
import VillainDetail from './VillainDetail'
import {useGetEntities} from 'hooks/useGetEntities'
import {useDeleteEntity} from 'hooks/useDeleteEntity'
import type {Villain} from 'models/Villain'
import VillainsContext from 'hooks/useVillainsContext'

export default function Villains() {
  const [showModal, setShowModal] = useState<boolean>(false)
  const {entities: villains, getError} = useGetEntities('villains')
  const [villainToDelete, setVillainToDelete] = useState<Villain | null>(null)
  const {deleteEntity: deleteVillain, isDeleteError} =
    useDeleteEntity('villain')

  const navigate = useNavigate()
  const addNewVillain = () => navigate('/villains/add-villain')
  const handleRefresh = () => navigate('/villains')

  const handleCloseModal = () => {
    setVillainToDelete(null)
    setShowModal(false)
  }
  // currying: the outer fn takes our custom arg and returns a fn that takes the event
  const handleDeleteVillain = (villain: Villain) => () => {
    setVillainToDelete(villain)
    setShowModal(true)
  }
  const handleDeleteFromModal = () => {
    villainToDelete ? deleteVillain(villainToDelete) : null
    setShowModal(false)
  }

  if (getError || isDeleteError) {
    return <ErrorComp />
  }

  return (
    <div data-cy="villains">
      <ListHeader
        title="Villains"
        handleAdd={addNewVillain}
        handleRefresh={handleRefresh}
      />
      <div>
        <div>
          <VillainsContext.Provider value={villains}>
            <Routes>
              <Route
                path=""
                element={
                  <VillainList handleDeleteVillain={handleDeleteVillain} />
                }
              />
              <Route path="/add-villain" element={<VillainDetail />} />
              <Route path="/edit-villain/:id" element={<VillainDetail />} />
              <Route
                path="*"
                element={
                  <VillainList handleDeleteVillain={handleDeleteVillain} />
                }
              />
            </Routes>
          </VillainsContext.Provider>
        </div>
      </div>

      {showModal && (
        <ModalYesNo
          message="Would you like to delete the villain?"
          onNo={handleCloseModal}
          onYes={handleDeleteFromModal}
        />
      )}
    </div>
  )
}

// remove later: a change to a src file



================================================
FILE: .github/workflows/badges.yml
================================================
name: badges
on:
  push:
    # update README badge only if the README file changes
    # or if the package.json file changes, or this file changes
    branches:
      - main
    paths:
      - README.md
      - package.json
      - .github/workflows/badges.yml
  schedule:
    # update badges every night
    # because we have a few badges that are linked
    # to the external repositories
    - cron: '0 3 * * *'

  workflow_dispatch:

jobs:
  badges:
    name: Badges
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout 🛎
        uses: actions/checkout@v4

      - name: Update version badges 🏷
        run:
          npx -p dependency-version-badge update-badge react vite cypress
          typescript

      - name: Commit any changed files 💾
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: Updated badges
          branch: main
          file_pattern: README.md
          push_options: '--force'
          skip_fetch: true



================================================
FILE: .github/workflows/main.yml
================================================
name: unit-lint-typecheck-e2e-ct
on:
  push:
  workflow_dispatch:

concurrency:
  group: ${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  # if you want to enable parallelization
  CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  install-dependencies:
    name: Install Dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Install dependencies
        uses: cypress-io/github-action@v6
        with:
          runTests: false

  unit-test:
    needs: [install-dependencies]
    name: Run Unit Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Install dependencies
        uses: cypress-io/github-action@v6
        with:
          runTests: false
      - name: unit-test
        run: yarn test:coverage

      # if you want to enable codecov
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage-jest-${{ matrix.machines }}
          path: coverage/
          retention-days: 1

      - name: ✅ Upload Jest coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          directory: coverage/
          flags: jest-rtl-coverage
          token: ${{ secrets.CODECOV_TOKEN }}

  lint:
    needs: install-dependencies
    name: Run Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Install dependencies
        uses: cypress-io/github-action@v6
        with:
          runTests: false
      - name: lint
        run: yarn lint

  typecheck:
    needs: install-dependencies
    name: Run typecheck
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Install dependencies
        uses: cypress-io/github-action@v6
        with:
          runTests: false
      - name: typecheck
        run: yarn typecheck

  cypress-e2e-test:
    #    if you want to enable parallelization
    strategy:
      fail-fast: false
      matrix:
        machines: [1, 2, 3]
    needs: [install-dependencies]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Install Specific Chrome Version
        run: |
          sudo apt-get install -y wget
          sudo wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo apt-get install ./google-chrome-stable_current_amd64.deb

      - name: Cypress e2e tests 🧪
        uses: cypress-io/github-action@v6
        with:
          start: yarn dev
          wait-on: 'http://localhost:3000'
          browser: chrome
          # if you want to enable parallelization
          record: true
          parallel: true
          group: e2e-tests
          tag: e2e-tests

      # if you want to enable codecov
      - name: Upload artifacts (Coverage_step3)
        uses: actions/upload-artifact@v4
        with:
          name: coverage-cy-e2e-${{ matrix.machines }}
          path: coverage-cy/
          retention-days: 1

      - name: ✅ Upload e2e coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          directory: coverage-cy/
          flags: cypress-e2e-coverage
          token: ${{ secrets.CODECOV_TOKEN }}

  cypress-ct-test:
    # if you want to enable parallelization
    strategy:
      fail-fast: false
      matrix:
        machines: [1, 2, 3]
    needs: [install-dependencies]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Install Specific Chrome Version
        run: |
          sudo apt-get install -y wget
          sudo wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo apt-get install ./google-chrome-stable_current_amd64.deb

      - name: Cypress component tests 🧪
        uses: cypress-io/github-action@v6
        with:
          component: true
          browser: chrome
          # if you want to enable parallelization
          record: true
          parallel: true
          group: ct-tests
          tag: ct-tests

      # if you want to enable codecov
      - name: Upload artifacts (Coverage_step3)
        uses: actions/upload-artifact@v4
        with:
          name: coverage-cy-ct-${{ matrix.machines }}
          path: coverage-cy/
          retention-days: 1

      - name: ✅ Upload CT coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          directory: coverage-cy/
          flags: cypress-ct-coverage
          token: ${{ secrets.CODECOV_TOKEN }}



================================================
FILE: .github/workflows/merge-gatekeeper.yml
================================================
name: Merge Gatekeeper

on:
  pull_request:
    branches:
      - main

jobs:
  merge-gatekeeper:
    runs-on: ubuntu-latest
    permissions:
      checks: read
      statuses: read
    steps:
      - name: Run Merge Gatekeeper
        uses: upsidr/merge-gatekeeper@v1.2.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}


